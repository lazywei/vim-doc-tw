*undo.txt*      For Vim version 7.3.   最後更改：2010年7月


		     Vim 參考手冊    作者：Bram Moolenaar
			（譯者: jwdu, tocer http://vimcdoc.sf.net） 

撤銷和重做							*undo-redo*

在用戶手冊的 |02.5| 節對它們的基本操作有解釋。

1. 撤銷和重做操作的命令		|undo-commands|
2. 撤銷操作的兩種方法		|undo-two-ways|
3. 撤銷塊			|undo-blocks|
4. 撤銷分支			|undo-branches|
5. 撤銷的永久保存		|undo-persistence|
6. 撤銷操作的解釋		|undo-remarks|

==============================================================================
1. 撤銷和重做命令					*undo-commands*

<Undo>		或					*undo* *<Undo>* *u*
u			撤銷 [count] 次更改。 		{Vi: 僅有一級}

							*:u* *:un* *:undo*
:u[ndo]			撤銷一次更改。  		{Vi: 僅有一級}

								*E830*
:u[ndo] {N}		轉到改變號 {N} 之後。{N} 的含義參見 |undo-branches|。
			{Vi 無此功能}

							*CTRL-R*
CTRL-R			重做 [count] 次被撤銷的更改。	{Vi: 刷新屏幕}

							*:red* *:redo* *redo*
:red[o]			重做一個被撤銷的更改。		{Vi: 沒有 redo}

							*U*
U			撤銷最近對特定行所作的一系列更改。
			{Vi: 僅當這些修改不超出該行的範圍}

由於最近所作的更改是被記住的，因此，你可以應用上面的撤銷和重做命令把文件倒轉到
你所作每次更改以前的狀態。當然，你也可以重新應用這些修改，把文件重做到執行撤銷
操作以前的狀態。

對於撤銷/重做 (undo/redo) 來說，"U" 命令和其他命令是同等對待的。所以 "u" 可以
撤銷一個 "U" 命令、'CTRL-R' 也可以重做對 "U" 命令的撤銷。當 "U"、"u" 和
'CTRL-R' 三個命令混合使用時，你將注意到 "U" 命令決意將被該行還原到前一個 "U"
命令之前的狀態。這或許會令你困惑。多試試，你會習慣的。
"U" 命令總是把緩衝區標記為已改變。即使它把修改過的緩衝區重做到未改變的狀態也是
如此。為此，只有使用 "u" 命令，才能令緩衝區正確地回復到未改變的標記。

==============================================================================
2. 撤銷操作的兩種方法					*undo-two-ways*

撤銷和重做的工作模式依賴於 'cpoptions' 中 'u' 標誌位。這裡有兩種模式，Vim 模式
(不包含 'u') 和 Vi-兼容模式 (包含 'u')。在 Vim 模式下，"uu" 命令撤銷兩次改變，
在 Vi-兼容模式下，"uu" 命令什麼也不做 (撤銷第一次撤銷)。

不包含 'u' 的 Vim 模式:
及時的撤銷命令可以回到先前的狀態。你也可以使用重做命令再次前進。不過，如果在撤
銷命令後你做了一個新的改變，重做上次的撤銷便不再可能。

包含 'u' 的 Vi-兼容模式:
撤銷命令撤銷包含以前的撤銷命令在內的任何更改。重做命令重複前一個撤銷命令。但它
_不_用來重複改變命令。為此請用 "." 命令。

舉例		Vim 模式		Vi-兼容模式	~
"uu"		兩次撤銷		空操作
"u CTRL-R"	空操作			兩次撤銷

原理:	Nvi 使用 "." 命令而不是 CTRL-R。不幸的是，這不是 Vi 兼容的。例如
	"dwdwu." 命令，在 Vi 中刪除兩個詞，但在 Nvi 中，它什麼也不做。

==============================================================================
3. 撤銷塊						*undo-blocks*

單個 undo 命令通常撤掉一個輸入的命令，不論這個命令造成多少改變。這個可以撤銷的
改變序列構成了一個撤銷塊。所以如果鍵入的命令調用一個函數，那麼在這個函數中的所
有命令全部被撤銷。

如果你想編寫一個函數或腳本，它不包含新的可撤銷之改變，而合併到之前的改變中，用
以下命令:

						*:undoj* *:undojoin* *E790*
:undoj[oin]		把其後的改變和以前的撤銷塊進行合併。
			警告: 小心使用。它會阻止用戶合理地撤銷改變。不要在撤銷
			或重做後使用。
			{Vi 無此功能}

這最適用於在改變的過程中需要提示用戶的場合。例如調用 |getchar()| 的函數。確保
在這之前有一個相關的必須與之合併的改變。

這條命令不能單獨工作，因為下一個鍵擊會再次造成新改變。但你可以這麼做: >

	:undojoin | delete

在此之後，"u" 命令會同時撤銷 delete 命令和前一次改變。

要反過來，把一個改動分成兩個撤銷塊，在插入模式下用 CTRL-G u。可用於使某個插入
命令部分可撤銷。譬如可分拆到每個句子。|i_CTRL-G_u|
設置 'undolevels' 的值也會破壞撤銷。即使新值和舊值相同。

==============================================================================
4. 撤銷分支					*undo-branches* *undo-tree*

上面我們只討論了單線的撤銷/重做。但你也可以進行分支。考慮你先撤銷了若干改變，
然後又進行了一些其它的改變。此時，被撤銷的改變就成為一個分支。下面的命令使你能
夠到達那個分支。

這在用戶手冊中有解釋: |usr_32.txt|。

							*:undol* *:undolist*
:undol[ist]		列出改變樹的所有葉結點。例如:
				number changes   time ~
				4      10	 10:34:11
				18     4	 11:01:46

			"number" 列是改變號。這個編號持續增加，用於標識特定可
			撤銷的改變，參見 |:undo|。
			"changes" 列是樹的根結點到此葉結點所需的改變數目。
			"time" 列是此改變發生的時間。
			要更詳細的信息可用 |undotree()| 函數.

							*g-*
g-			轉到較早的文本狀態。如果帶計數，重複那麼多次。
			{Vi 無此功能}
							*:ea* *:earlier*
:earlier {count}	轉到 {count} 次較早的文本狀態。
:earlier {N}s		轉到大約 {N} 秒鐘之前的較早的文本狀態。
:earlier {N}m		轉到大約 {N} 分鐘之前的較早的文本狀態。
:earlier {N}h		轉到大約 {N} 小時之前的較早的文本狀態。
:earlier {N}d		轉到大約 {N} 天之前的較早的文本狀態。

:earlier {N}f		轉到 {N} 次文件寫入之前的較早的文本狀態。
			如果上次寫入之後有改動，":earlier 1f" 會恢復文本到上次
			寫入時的狀態。否則會轉到再上一次寫入時的狀態。
			如果在第一次文件寫入的狀態，甚至於從未寫入過文件，
			":earlier 1f" 會轉到首次改變之前的狀態。

							*g+*
g+			轉到較新的文本狀態。如果帶計數，重複那麼多次。
			{Vi 無此功能}
							*:lat* *:later*
:later {count}	轉到 {count} 次較新的文本狀態。
:later {N}s		轉到大約 {N} 秒鐘之後的較新的文本狀態。
:later {N}m		轉到大約 {N} 分鐘之後的較新的文本狀態。
:later {N}h		轉到大約 {N} 小時之後的較新的文本狀態。
:later {N}d		轉到大約 {N} 天之後的較新的文本狀態。

:later {N}f		轉到 {N} 次文件寫入之後較新的文本狀態。
			若在在最後一次文件寫入的狀態，":later 1f" 會轉到最新的
			文本狀態。

注意 如果由於 'undolevels' 選項，撤銷信息被清空，那麼文本狀態將無法訪問。

在不同時間點上移動的時候，不要奇怪一個時間點會同時發生多個改變。通過撤銷樹跳轉
然後又做了新的改變後就會發生這種情況。

示 例

從這一行開始:
	one two three ~

按三次 "x" 刪除第一個單詞:
	ne two three ~
	e two three ~
	 two three ~

現在按 "u" 三次撤銷:
	e two three ~
	ne two three ~
	one two three ~

按三次 "x" 刪除第二個單詞:
	one wo three ~
	one o three ~
	one  three ~

現在按 "g-" 三次撤銷:
	one o three ~
	one wo three ~
	 two three ~

現在，回到第一個撤銷分支，也就是在刪除 "one" 之後。重複 "g-" 會回到原始文本:
	e two three ~
	ne two three ~
	one two three ~

使用 ":later 1h" 跳到最後一次改變:
	one  three ~

使用 ":earlier 1h" 再次回到開始:
	one two three ~


注意 使用 "u" 和 CTRL-R 無法得到全部可能的文本狀態，但是重複 "g-" 和 "g+" 卻可
以。

==============================================================================
5. 撤銷的永久保存		*undo-persistence* *persistent-undo*

卸載緩衝區時，Vim 通常會刪除該緩衝區建立的撤銷樹。通過設置 'undofile' 選項，
Vim 會在寫入文件時自動保存撤銷歷史，而重新編輯文件時，恢復撤銷歷史。

'undofile' 選項在寫入文件之後檢查，而發生在 BufWritePost 自動命令之前。要控制
哪些文件需要保存撤銷信息，可以使用 BufWritePre 自動命令: >
	au BufWritePre /tmp/* setlocal noundofile

Vim 把撤銷樹保存在一個獨立的撤銷文件裡，每個編輯的文件對應一個，使用一個簡單的
方案來對應文件系統的路徑到撤銷文件名。Vim 會檢測是否某個撤銷文件不再和寫它時的
那個文件同步 (使用文件內容的哈希值)，如果文件內容在撤銷文件寫入後有改動，忽略
撤銷文件，以防止文件遭破壞。

撤銷文件通常保存在文件本身相同的目錄裡。這可以用 'undodir' 選項改變。

如果文件被加密，撤銷文件的文件也會加密。使用相同的密鑰和方法。|encryption|

你也可以用 ":wundo" 和 ":rundo" 來相應地保存和恢復撤銷歷史:
							*:wundo* *:rundo*
:wundo[!] {file}
		把撤銷歷史寫入 {file}。
		如果 {file} 已存在而看起來不像撤銷文件 (文件頭部的魔術數字不
		符)，此命令失敗。除非加上 !。
		如果文件存在且看起來像撤銷文件，覆蓋之。
		{Vi 無此功能}

:rundo {file}	從 {file} 讀出撤銷歷史。
		{Vi 無此功能}

你可以在自動命令中用這些命令來顯式指定歷史文件名。例如: >

	au BufReadPost * call ReadUndo()
	au BufWritePost * call WriteUndo()
	func ReadUndo()
	  if filereadable(expand('%:h'). '/UNDO/' . expand('%:t'))
	    rundo %:h/UNDO/%:t
	  endif
	endfunc
	func WriteUndo()
	  let dirname = expand('%:h') . '/UNDO'
	  if !isdirectory(dirname)
	    call mkdir(dirname)
	  endif
	  wundo %:h/UNDO/%:t
	endfunc

此時，應該關閉 'undofile'，否則每次寫入文件時會有兩個撤銷文件。

可以用 |undofile()| 函數來確定 Vim 會使用的文件名。

注意: 讀寫文件時，如果設置了 'undofile'，大部分的錯誤信息會被屏蔽，除非設置了
'verbose'。而 :wundo 和 :rundo 會得到更到的錯誤信息，如文件不能讀或寫等。

注意: Vim 從不刪除撤銷文件。你需要自己進行清除。

讀出已經存在的撤銷文件可能會有以下的失敗原因:
*E822*	不能打開，文件許可權限不許可。
*E823*	文件頭的魔術數字不符。通常這意味著這不是一個撤銷文件。
*E824*	撤銷文件的版本號說明它是由更新的 Vim 版本寫入的。需要更新的版本來讀。
	如果你想保留該文件中的撤銷信息，不要寫入緩衝區。
"File contents changed, cannot use undo info"
	文件文本和撤銷文件寫入時的不同。這意味著不再能使用該撤銷文件，否則會破
	壞文本。這也可能是因為 'encoding' 和撤銷文件寫入時的不同。
*E825*	撤銷文件沒有合法的內容，不能使用。
*E826*	撤銷文件經過加密而解密失敗。
*E827*	撤銷文件經過加密而此版本的 Vim 不支持加密。用別的 Vim 打開該文件。
*E832*	撤銷文件經過加密而 'key' 沒有設置，文本文件本身沒有加密。這可能是因為
	文本文件本來是由 Vim 用加密方式寫入的，後來又用非加密方式進行了覆蓋。
	最好刪除該撤銷文件。
"Not reading undo file, owner differs"
	撤銷文件的擁有者和文本文件的擁有者不同。因為安全原因，不使用該撤銷文
	件。

寫入撤銷文件可能會有以下的失敗原因:
*E828*	待寫入的文件不能建立。可能你沒有該目錄的寫入權限。
"Cannot write undo file in any directory in 'undodir'"
	'undodir' 裡沒有一個可用的目錄。
"Will not overwrite with undo file, cannot read"
	待寫入的撤銷文件已經存在，但不能讀回。你需要先刪除或改名。
"Will not overwrite, this is not an undo file"
	待寫入的撤銷文件已經存在，但開頭沒有正確的魔術數字。你需要先刪除或改
	名。
"Skipping undo file write, noting to undo"
	沒有未寫入的撤銷信息，沒有任何改變，或者 'undolevels' 為負。
*E829*	寫入撤銷文件時有錯。可以多試幾次。

==============================================================================
6. 撤銷操作的解釋					*undo-remarks*

能記憶的最大改變次數由 'undolevels' 選項決定。如果它的值是零，我們總是運行在
Vi-兼容模式。如果它的值是負的，任何撤銷都是不可能的。這只有在內存緊張的時候適
用。

							*clear-undo*
如果設置 'undolevels' 為 -1，撤銷信息不會立即清除。當有新改變時才會。要強迫清
除撤銷信息，可以用: >
	:let old_undolevels = &undolevels
	:set undolevels=-1
	:exe "normal a \<BS>\<Esc>"
	:let &undolevels = old_undolevels
	:unlet old_undolevels

當前緩衝區的位置標記 ('a 至 'z) 隨文本一起被保存和復原。{Vi 的做法稍有不同}

當所有的改變都被撤銷時，緩衝區被標記為未改變。這時可以使用 ":q" 而不一定是
":q!" 退出 Vim 。{Vi 並非如此} 注意未改變是相對文件的最後寫入而言的。在寫入
":w" 後緊跟的撤銷 "u"，實際上改變了被寫入以後緩衝區的狀態。因此，此時緩衝區應
被視為已改變。

當使用手動 |folding| 時，折疊不會被保存和復原。只有完全發生折疊內部的改變才不
會影響該折疊，因為它開頭和最後一行沒有改變。

數字編號的寄存器也可以被用作撤銷刪除操作。你每一次刪除文本，該文本被放在 "1 寄
存器中。同樣的，"1 寄存器的內容被移到 "2 寄存器，依次類推。"9 寄存器的內容則會
丟失。現在，你可以通過命令 '"1P' 得到最近刪除的文本。(如果被刪除的內容來自最近
的刪除或複製操作，'P' 或 'p' 同樣也可得到你要的結果，因為他們會複製未命名寄存
器的內容)。使用 '"3P' 可以得到三個刪除操作之前的文本。

							*redo-register*
如果你想得到多於一處被刪除文本的內容，你可以使用重複命令 "." 一個特殊的特性:
它會遞增所使用寄存器內的序號。所以，你如果先使用 ""1P" ，那麼接下來的 "." 就意
味著 '"2P 。重複這樣的操作，所有編號的寄存器都會被插入。

例如: 如果你用 'dd....' 刪除了內容 (五行文本)，那麼用 '"1P....' 可以恢復之。

如果你不知道被刪除的內容在哪一個寄存器，你可以用 |:display| 命令。還有一個方法
就是先試第一個寄存器 '"1P' ，如果不對，用 'u.' 命令。這將會移走第一次放進的內
容，然後在第二個寄存器上重複 put 命令。重複使用 'u.' 直到你得到想要的內容為
止。

 vim:tw=78:ts=8:ft=help:norl:
