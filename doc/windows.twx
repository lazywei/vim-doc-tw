*windows.txt*	For Vim version 7.3.  最後更新: 2010年8月


		  VIM  參 考 手 冊    作者: Bram Moolenaar
				      譯者: Dasn
				      http://vimcdoc.sf.net


使用多個窗口和緩衝區進行編輯				*windows* *buffers*

本章我們看一下操作多個窗口和緩衝區的命令。另外有些命令在操作多個窗口的時候不同
於單個窗口，這些命令也會在本章被介紹。

一些基本的內容在用戶手冊的第 7、8 兩個章節裡 |usr_07.txt| |usr_08.txt| 已經介
紹過了。

1.  簡介					|windows-intro|
2.  啟動 Vim					|windows-starting|
3.  打開和關閉窗口				|opening-window|
4.  把光標移動到另一個窗口			|window-move-cursor|
5.  移動窗口					|window-moving|
6.  改變窗口大小				|window-resize|
7.  參數和緩衝區列表的命令			|buffer-list|
8.  在所有的緩衝區和窗口裡執行命令		|list-repeat|
9.  當前光標處的標籤和文件名			|window-tag|
10. 預覽窗口					|preview-window|
11. 使用隱藏緩衝區				|buffer-hidden|
12. 特殊類型緩衝區				|special-buffers|

{Vi 沒有這些命令}
{僅當編譯時加入 |+windows| 特性才能使用多窗口功能}
{僅當編譯時加入 |+vertsplit| 特性才能使用垂直分割窗口功能}

==============================================================================
1. 簡介						*windows-intro* *window*

小結:
   緩衝區是內存中的文件文本。
   窗口是緩衝區的視窗。
   標籤頁是窗口的集合。

"窗口" 被用來查看緩衝區裡的內容。你可以用多個窗口觀察同一個緩衝區，也可以用多
個窗口觀察不同的緩衝區。

"緩衝區" 是一塊內存區域，裡面存儲著正在編輯的文件。如果沒有把緩衝區裡的文件存
盤，那麼原始文件不會被更改。

緩衝區的狀態可以是下述三種情況之一：

							*active-buffer*
激活：	  緩衝區的內容在窗口裡顯示。如果該緩衝區是針對某一個文件創建的，那麼該
	  文件已經被讀入緩衝區。如果緩衝區被更改過，其內容便會與原文件不同。
							*hidden-buffer*
隱藏：	  緩衝區的內容不被顯示。如果該緩衝區是針對某一個文件創建的，那麼該文件
	  已經被讀入緩衝區。除此以外，與激活狀態一樣，只是你看不見它。
							*inactive-buffer*
非激活：  緩衝區的內容不被顯示，也不包含任何數據。如果曾經載入過文件，與該緩衝
	  區相關的選項會被記住。它可以包括來自 |viminfo| 文件的位置標記，但是
	  這種緩衝區不包含文本。

用一個表來說明：

狀態		在窗口顯示	文件載入	":buffers" 命令顯示 ~
激活		    是		   是		  'a'
隱藏		    否		   是		  'h'
非激活		    否		   否		  ' '

備註: 所有的 CTRL-W 命令都可以用 |:wincmd| 執行，當我們不能輸入普通模式命令，
或者輸入不方便時可以試一下。

主 Vim 窗口可以容納多個分割的窗口。此外還有標籤頁 |tab-page|，每個標籤頁能容納
多個窗口。

==============================================================================
2. 啟動 Vim						*windows-starting*

在默認情況下，與 Vi 類似，Vim 啟動後只打開一個窗口。

參數 "-o" 和 "-O" 可以讓 Vim 為參數列表裡的每一個文件打開一個窗口。參數 "-o"
水平分割窗口；參數 "-O" 垂直分割窗口。如果 "-o" 和 "-O" 都用了，那麼最後一個參
數決定分割的方向。例如，下面的例子打開三個水平分割的窗口： >
	vim -o file1 file2 file3

參數 "-oN"，這裡的 N 是一個十進制數，用這個參數可以打開 N 個水平分割的窗口。
如果文件名的個數多於窗口數目，則只打開 N 個窗口，這樣有一些文件就得不到窗口來
顯示。如果指定的窗口數多於文件的個數，那麼後面的幾個窗口會編輯空的緩衝區。同
樣， "-ON"  打開 N 個垂直分割的窗口，相應的規則與 "-oN" 相同。

如果你打開了很多的文件，每個窗口都會便得很小。你可能需要設置 'winheight' 和
'winwidth' 選項來創建一個適合工作的環境。

Buf/Win Enter/Leave 等自動命令 |autocommand| 不會在打開窗口或讀取文件時運行，
只有在真正進入緩衝區後才會執行。

							*status-line*
狀態行用來分割窗口。選項 'laststatus' 用來設置最後一個窗口在什麼時候可以有狀態
欄：
	'laststatus' = 0	永遠不會有狀態行
	'laststatus' = 1	窗口數多於一個的時候
	'laststatus' = 2	總是顯示狀態行

你可以通過設置 'statusline' 選項來改變狀態行的內容。此選項可以局部於窗口，所以
你可以為每個窗口設置不同的狀態行。

通常狀態行用反色顯示。你可以通過修改 'highlight' 選項中的 's' 字符來改變。例
如，"sb" 設置為粗體字。如果狀態行沒有啟用高亮 ("sn")，那麼字符 '^' 表示當前窗
口，字符 '=' 表示其它窗口。如果支持鼠標並且已經通過設置 'mouse' 選項使之啟動，
那麼你可以用鼠標拖動狀態行以改變窗口的大小。

備註: 如果你想讓狀態行以反色顯示，但是沒有效果。查看一下 'highlight' 選項是否
包含了 "si"。在 3.0 版本裡，這意味著逆轉 (invert) 狀態行。但是現在應該使用
"sr"，反轉 (reverse) 狀態行，因為 "si" 現在表示斜體 (italic)！如果你的終端不支
持斜體，那麼狀態行還是會以反色顯示；這種問題只會出現在有斜體的 termcap 碼的終
端上。

==============================================================================
3. 打開和關閉窗口					*opening-window* *E36*

CTRL-W s						*CTRL-W_s*
CTRL-W S						*CTRL-W_S*
CTRL-W CTRL-S						*CTRL-W_CTRL-S*
:[N]sp[lit] [++opt] [+cmd]				*:sp* *:split*
		把當前窗口分割成兩個，結果是兩個窗口顯示同一個文件。新打開的窗
		口高度為 N (默認值是當前窗口高度的一半)。減少當前窗口的高度，
		空出地方給新的窗口 (如果你置位了 'equalalways' 選項，並且
		'eadirection' 沒有設置為 "hor"，並且其它窗口中的一個高於當前或
		新窗口的話，其它窗口也被影響)。
		備註: 不是在所有的終端都能使用 CTRL-S，並且可能導致不能繼續輸
		入，遇到這種情況，用 CTRL-Q 繼續。參見 |++opt| 和 |+cmd|。

CTRL-W CTRL-V						*CTRL-W_CTRL-V*
CTRL-W v						*CTRL-W_v*
:[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
		與 |:split| 類似，但垂直分割窗口。滿足以下條件的話，窗口會被均
		勻地水平鋪開:
		1. 沒有指定寬度，
		2. 打開了 'equalalways' 選項，
		3. 'eadirection' 不是 "ver"，且
		4. 其它窗口中的一個寬於當前或新窗口。
		備註: 在其它地方 CTRL-Q 與 CTRL-V 相同，但是在這裡不是！

CTRL-W n						*CTRL-W_n*
CTRL-W CTRL_N						*CTRL-W_CTRL-N*
:[N]new [++opt] [+cmd]					*:new*
		創建一個新窗口並且開始編輯一個空文件。新窗口的高度為 N (默認值
		為現存高度的一半)。減少當前窗口的高度，為新窗口留出空間 (如果
		你打開了 'equalalways' 選項，並且 'eadirection' 沒有設置為
		"hor"，其它窗口也會被影響)。
		參見：|++opt| and |+cmd|。
		如果設置了 'fileformats' 選項，那麼新緩衝區會使用其中的第一個
		格式。如果 'fileformats' 為空，那麼使用當前緩衝區的
		'fileformat' 值。這個值可以被 |++opt| 參數覆蓋。
		自動命令以如下順序被執行：
		1. 在當前窗口執行 WinLeave
		2. 在新窗口裡執行 WinEnter
		3. 在當前緩衝區執行 BufLeave
		4. 在新緩衝區執行 BufEnter
		這跟先執行 ":split"，再執行一個 ":e" 命令的效果差不多。

:[N]vne[w] [++opt] [+cmd] [file]			*:vne* *:vnew*
		與 |:new| 命令相似，但是它垂直分割窗口，如果打開了
		'equalalways' 選項，並且選項 'eadirection' 沒有設置為 "ver"，
		窗口會被均勻地水平鋪開，除非你給出了指定窗口寬度的參數。

:[N]new [++opt] [+cmd] {file}
:[N]sp[lit] [++opt] [+cmd] {file}			*:split_f*
		創建一個新的窗口，並且開始編輯文件 {file}。如果使用了 [+cmd]
		參數，文件加載完畢後會執行命令 |+cmd|。
		也參見：|++opt|。
		新窗口的高度為 N (默認值為現存高度的一半)。減少當前窗口的高
		度，為新窗口留出空間 (如果你打開了 'equalalways' 選項，其它窗
		口也會被影響)。

:[N]sv[iew] [++opt] [+cmd] {file}		*:sv* *:sview* *splitview*
		與 ":split" 命令相同，但是會給緩衝區置位 'readonly' 選項。

:[N]sf[ind] [++opt] [+cmd] {file}		*:sf* *:sfind* *splitfind*
		與 ":split" 命令相同，但是會在 'path' 裡尋找 {file}，就像
		|:find| 那樣。如果找不到，就不會分割窗口。

CTRL-W CTRL-^					*CTRL-W_CTRL-^* *CTRL-W_^*
CTRL-W ^	執行 ":split #" 命令，把窗口分成兩個，並且編輯輪換文件。如果指
		定了計數，就變成了 ":split #N"，分割窗口，並且編輯第 N 個緩衝
		區。

注意 'splitbelow' 和 'splitright' 選項會影響新窗口的位置。

						*:vert* *:vertical*
:vert[ical] {cmd}
		執行 {cmd}。如果包含一個分割窗口的命令，那麼將垂直分割窗口。
		不能用於 |:execute| 和 |:normal|。

:lefta[bove] {cmd}				*:lefta* *:leftabove*
:abo[veleft] {cmd}				*:abo* *:aboveleft*
		執行 {cmd}。如果包含一個分割窗口的命令，那麼將從當前窗口的左
		(垂直分割) 或者上方 (水平分割) 分割窗口，而忽略 'splitbelow'
		和 'splitright' 的設置。
		不能用於 |:execute| 和 |:normal|。

:rightb[elow] {cmd}				*:rightb* *:rightbelow*
:bel[owright] {cmd}				*:bel* *:belowright*
		執行 {cmd}。如果包含一個分割窗口的命令，那麼將從當前窗口的右
		(垂直分割) 或者下方 (水平分割) 分割窗口，而忽略 'splitbelow'
		和 'splitright' 的設置。
		不能用於 |:execute| 和 |:normal|。

						*:topleft* *E442*
:to[pleft] {cmd}
		執行 {cmd}。如果包含一個分割窗口的命令，那麼該窗口出現在頂部，
		並且佔據最大寬度。當垂直分割窗口時，窗口出現在最左邊，並且佔據
		最大高度。
		不能用於 |:execute| 和 |:normal|。

						*:botright*
:bo[tright] {cmd}
		執行 {cmd}。如果包含一個分割窗口的命令，那麼該窗口出現在底部，
		並且佔據最大寬度。當垂直分割窗口時，窗口出現在最右邊，並且佔據
		最大高度。
		不能用於 |:execute| 和 |:normal|。

這些修飾符可以結合使用來打開一個垂直分割的並且佔據最大高度的窗口： >
	:vertical topleft edit tags
在 Vim 窗口最左邊打開一個垂直分割的、最大高度的窗口，用來編輯 tags 文件。


關閉窗口
----------------

CTRL-W q						*CTRL-W_q*
CTRL-W CTRL-Q						*CTRL-W_CTRL-Q*
:q[uit]		退出當前窗口。如果退出的是最後一個窗口 (不包括幫助窗口)，就會
		退出 Vim。
		如果置位了 'hidden' 並且只有此一個窗口監視當前緩衝區，那麼該緩
		沖區被隱藏。
		如果沒有置位 'hidden'，並且只有當前這一個窗口監視該緩衝區，而
		且緩衝區被修改了，那麼該命令不會成功。
		(注意：CTRL-Q 不是在所有的終端下都好用)

:q[uit]!	退出當前窗口。如果這是緩衝區的最後一個窗口，那麼對於此緩衝區的
		改動將全部丟失。如果退出的是最後一個窗口 (不包括幫助窗口)，就
		會退出 Vim。緩衝區裡的全部內容將丟失。即使置位了 'hidden' 選項
		也是如此。

CTRL-W c					*CTRL-W_c* *:clo* *:close*
:clo[se][!]	關閉當前窗口。如果置位了 'hidden'，或者改動了緩衝區但是命令裡
		用了 [!]，緩衝區會被隱藏 (除非還有一個窗口在編輯該緩衝區)。
		如果當前標籤頁只有一個窗口而且有其它標籤頁，關閉當前標籤頁。
		|tab-page|。
		該命令在下述情況下會失敗：			*E444*
		- 屏幕上只剩下最後一個窗口的時候。
		- 當 'hidden' 沒有置位，也沒有用 [!]，並且緩衝區也已經被修改，
		  而且也沒有其它窗口監視該緩衝區的時候。
		對緩衝區的改動既不寫入文件，也不會丟失，所以這是個 "安全" 的命
		令。

CTRL-W CTRL-C						*CTRL-W_CTRL-C*
		你可能會認為 CTRL-W CTRL-C 關閉當前窗口，但是這不行，因為
		CTRL-C 會撤消整個命令。

							*:hide*
:hid[e]		除非是屏幕上的最後一個窗口，退出當前窗口，緩衝區被隱藏起來
		(除非還有另一個窗口正在編輯它，或者 'bufhidden' 設置為
		"unload" 或 "delete")。
		如果這是當前標籤頁的最後一個窗口，關閉此標籤頁。|tab-page|
		此命令不受 'hidden' 的值影響。
		對緩衝區的改動既不寫入文件，也不會丟失，所以這是個 "安全" 的命
		令。

:hid[e] {cmd}	執行 {cmd}，其間置位 'hidden' 選項。{cmd} 執行完畢後，先前的
		'hidden' 選項會被恢復。
		例如： >
		    :hide edit Makefile
<		編輯 "Makefile" 文件，如果當前緩衝區有改動的話，隱藏之。

CTRL-W o						*CTRL-W_o* *E445*
CTRL-W CTRL-O					*CTRL-W_CTRL-O* *:on* *:only*
:on[ly][!]	使當前窗口成為屏幕上唯一的窗口。其它窗口都關閉。
		如果置位了 'hidden' 選項，被關閉窗口裡的所有緩衝區變成隱藏。
		如果沒有置位 'hidden'，但是置位了 'autowrite' 選項，那麼已經更
		改的緩衝區被寫入文件。否則，除非使用 [!] 強制關閉，那些包含修
		改過的緩衝區的窗口不被刪除，它們轉入隱藏狀態。因為修改過的緩衝
		區永遠不會被放棄，緩衝區的改動也永遠不會丟失。

==============================================================================
4. 把光標移動到另一個窗口			*window-move-cursor*

CTRL-W <Down>					*CTRL-W_<Down>*
CTRL-W CTRL-J					*CTRL-W_CTRL-J* *CTRL-W_j*
CTRL-W j	把光標向下移動 N 個窗口。用光標的位置在若干窗口之間做出選擇。

CTRL-W <Up>					*CTRL-W_<Up>*
CTRL-W CTRL-K					*CTRL-W_CTRL-K* *CTRL-W_k*
CTRL-W k	把光標向上移動 N 個窗口。用光標的位置在若干窗口之間做出選擇。

CTRL-W <Left>					*CTRL-W_<Left>*
CTRL-W CTRL-H					*CTRL-W_CTRL-H*
CTRL-W <BS>					*CTRL-W_<BS>* *CTRL-W_h*
CTRL-W h	把光標向左移動 N 個窗口。用光標的位置在若干窗口之間做出選擇。

CTRL-W <Right>					*CTRL-W_<Right>*
CTRL-W CTRL-L					*CTRL-W_CTRL-L* *CTRL-W_l*
CTRL-W l	把光標向右移動 N 個窗口。用光標的位置在若干窗口之間做出選擇。

CTRL-W w					*CTRL-W_w* *CTRL-W_CTRL-W*
CTRL-W CTRL-W	如果沒有添加計數，則將光標移動到當前窗口的右/下方的窗口。如果
		右/下方沒有窗口，就移動到左上角的窗口。
		要是添加了計數，就移動到第 N 個窗口 (從左上方到右下方依次計
		數)。窗口號可以通過 |bufwinnr()| 和 |winnr()| 來獲得。如果 N 
		大於窗口總數，跳到最後一個窗口。

						*CTRL-W_W*
CTRL-W W	如果沒有添加計數，則將光標移動到當前窗口的左/上方的窗口。如
		果左/上方沒有窗口，就移動到右下角的窗口。
		要是添加了計數，就移動到第 N 個窗口，類似於 CTRL-W w。

CTRL-W t					*CTRL-W_t* *CTRL-W_CTRL-T*
CTRL-W CTRL-T	把光標移動到左上角的窗口。

CTRL-W b					*CTRL-W_b* *CTRL-W_CTRL-B*
CTRL-W CTRL-B	把光標移動到右下角的窗口。

CTRL-W p					*CTRL-W_p* *CTRL-W_CTRL-P*
CTRL-W CTRL-P	移動到前一個 (previous) (上次訪問的) 窗口。

						*CTRL-W_P* *E441*
CTRL-W P	移動到預覽窗口。如果沒有預覽窗口就會出錯。
		{僅當編譯時加入 |+quickfix| 特性才有效}

在可視模式下，如果新窗口編輯的是同一個緩衝區，則設置光標位置使得相同的區域被選
擇。如果不是同一個緩衝區，則終止可視模式。

						*:winc* *:wincmd*
這些命令也可以用 ":wincmd" 來執行：

:[count]winc[md] {arg}
		與 CTRL-W [count] {arg} 相同。例如： >
			:wincmd j
<		把光標移動到當前窗口下面的窗口。
		這個命令在普通模式不可用的時候 (比如在 |CursorHold| 自動命令執
		行的時候)，或者在啟用普通模式不方便時，特別好用。
		計數也可以是一個窗口號。例如: >
			:exe nr . "wincmd w"
<		這會切換到窗口 "nr"。

==============================================================================
5. 移動窗口						*window-moving*

CTRL-W r				*CTRL-W_r* *CTRL-W_CTRL-R* *E443*
CTRL-W CTRL-R	向右/下方向旋轉窗口。第一個窗口變成第二個，第二個變成第三個……
		最後一個變成第一個。光標保留在相同窗口裡。
		本操作只在和當前窗口同行或同列的窗口間移動。
		
						*CTRL-W_R*
CTRL-W R	向左/上方向旋轉窗口。第二個窗口變成第一個，第三個變成第二個……
		第一個變成最後一個。光標保留在相同窗口裡。
		本操作只在和當前窗口同行或同列的窗口間移動。

CTRL-W x					*CTRL-W_x* *CTRL-W_CTRL-X*
CTRL-W CTRL-X	若沒有計數：交換當前窗口與下一個窗口。如果沒有下一個窗口，則
		與前一個窗口交換。
		若有計數：交換當前窗口與第 N 個窗口 (第一個窗口為 1)。光標被放
		置在那個窗口裡。
		如果既有垂直分割又有水平分割，那麼只能與當前窗口同行或者同列的
		窗口進行交換。

下面的幾個命令可以被用來改變窗口的佈局。例如，CTRL-W K 可以把兩個垂直分割的窗
口變成水平分割的窗口。CTRL-W H 則正好相反。

						*CTRL-W_K*
CTRL-W K	把當前窗口放到最頂端，並且是最大寬度。這很像在關閉當前窗口之
		後，再用 ":topleft split" 打開一個新的窗口，不過新窗口會包含當
		前窗口的內容。

						*CTRL-W_J*
CTRL-W J	把當前窗口放到最底部，並且是最大寬度。這很像在關閉當前窗口之
		後，再用 ":botright split" 打開一個新的窗口，不過新窗口會包含
		當前窗口的內容。

						*CTRL-W_H*
CTRL-W H	把當前窗口放到最左邊，並且是最大高度。這很像在關閉當前窗口之
		後，再用 ":vert topleft split" 打開一個新的窗口，不過新窗口會
		包含當前窗口的內容。
		{僅當編譯時加入 |+vertsplit| 特性才有效}

						*CTRL-W_L*
CTRL-W L	把當前窗口放到最右邊，並且是最大高度。這很像在關閉當前窗口之
		後，再用 ":vert botright split" 打開一個新的窗口，不過新窗口會
		包含當前窗口的內容。
		{僅當編譯時加入 |+vertsplit| 特性才有效}

						*CTRL-W_T*
CTRL-W T	把當前窗口移到一個新的標籤頁上。如果當前標籤頁只有一個窗口，此
		命令失敗。
		如果給出計數，打開的新標籤頁會出現在該索引給出的標籤頁之前。否
		則，它出現在當前標籤頁之後。

==============================================================================
6. 改變窗口大小						*window-resize*

						*CTRL-W_=*
CTRL-W =	使得所有窗口 (幾乎) 等寬、等高，但當前窗口使用 'winheight' 和
		'winwidth'。
		置位 'winfixheight' 的窗口保持它們的高度，而置位 'winfixwidth'
		的窗口保持它們的寬度。

:res[ize] -N					*:res* *:resize* *CTRL-W_-*
CTRL-W -	使得當前窗口高度減 N (默認值是 1)。
		如果在 |'vertical'| 之後使用，則使得寬度減 N。

:res[ize] +N					*CTRL-W_+*
CTRL-W +	使得當前窗口高度加 N (默認值是 1)。
		如果在 |'vertical'| 之後使用，則使得寬度加 N。

:res[ize] [N]
CTRL-W CTRL-_					*CTRL-W_CTRL-_* *CTRL-W__*
CTRL-W _	設置當前窗口的高度為 N (默認值為最大可能高度)。

z{nr}<CR>	設置當前窗口的高度為 {nr}。

						*CTRL-W_<*
CTRL-W <	使得當前窗口寬度減 N (默認值是 1)。

						*CTRL-W_>*
CTRL-W >	使得當前窗口寬度加 N (默認值是 1)。

:vertical res[ize] [N]			*:vertical-resize* *CTRL-W_bar*
CTRL-W |	設置當前窗口的寬度為 N (默認值為最大可能寬度)。

你也可以用鼠標上下拖動狀態行來改變窗口的高度，或者左右拖動垂直分割線來改變窗口
寬度。這些功能只有在支持鼠標的版本裡，並且設置了 'mouse' 選項才可以用。

選項 'winheight' ('wh') 用來設置當前窗口的最小高度。每當其它窗口變為當前窗口的
時候，這一選項就會生效。如果設置為 0，則禁用。把 'winheight' 設一個很大的值，
例如，'9999'，就使得當前窗口永遠佔據盡可能大的空間。盡量設置成一個編輯時比較舒
服的值，比如說，'10' 就是一個合理的值。

同樣，'winwidth' ('wiw') 選項設定了當前窗口的最小寬度。

如果置位了 'equalalways' ('ea') 選項，在分割或者關閉窗口之後，所有窗口都會變為
相同大小。如果你不置位這個選項，分割窗口時會減少當前窗口的大小，而其它窗口保持
不變。當關閉窗口時，多出來的行會被上面的窗口佔用。

選項 'eadirection' 用來限制 'equalalways' 的作用方向。默認值是 "both"，兩個方
向都改變。當設置為 "ver" 時，只限制所有窗口的高度必須相同，這樣你可以自己調節
窗口的寬度。而垂直分割窗口的大小如果經過手工調整，其寬度也不會被破壞。同樣，
"hor" 使得窗口的寬度都相等。

選項 'cmdheight' ('ch') 用來設置命令行的高度。如果你對 |hit-enter| 的提示信息
感到厭煩，可以將它設置為 2 或 3。

如果只有一個窗口，那麼改變該窗口大小的同時也會改變命令行的高度。如果有多個窗
口，那麼改變當前窗口的大小也會改變它下面的窗口 (有時是上面的窗口) 的高度。

一個窗口的最小高度和最小寬度可以用 'winminheight' 和 'winminwidth' 設定。這是
硬性值，一旦設定，窗口的高度 (或寬度) 將不能小於該值。

==============================================================================
7. 參數和緩衝區列表的命令				*buffer-list*

      參數列表		      緩衝區列表	   含義 ~
1. :[N]argument [N]	11. :[N]buffer [N]	切換至第 N 號參數/緩衝區
2. :[N]next [file ..]	12. :[N]bnext [N]	切換至向後第 N 個參數/緩衝區
3. :[N]Next [N]		13. :[N]bNext [N]	切換至向前第 N 個參數/緩衝區
4. :[N]previous	[N]	14. :[N]bprevious [N]	切換至向前第 N 個參數/緩衝區
5. :rewind / :first	15. :brewind / :bfirst	切換至第一個參數/緩衝區
6. :last		16. :blast		切換至最後一個參數/緩衝區
7. :all			17. :ball		編輯所有的參數/緩衝區
			18. :unhide		編輯所有已載入的緩衝區
			19. :[N]bmod [N]	切換至第 N 個已修改的緩衝區

  分割 & 參數列表	 分割 & 緩衝區列表	   含義 ~
21. :[N]sargument [N]   31. :[N]sbuffer [N]	分割並至第 N 號參數/緩衝區
22. :[N]snext [file ..] 32. :[N]sbnext [N]      分割並至向後第 N 個參數/緩衝區
23. :[N]sNext [N]       33. :[N]sbNext [N]      分割並至向前第 N 個參數/緩衝區
24. :[N]sprevious [N]   34. :[N]sbprevious [N]  分割並至向前第 N 個參數/緩衝區
25. :srewind / :sfirst	35. :sbrewind / :sbfirst 分割並至第一個參數/緩衝區
26. :slast		36. :sblast		分割並至最後一個參數/緩衝區
27. :sall		37: :sball		編輯所有的參數/緩衝區
			38. :sunhide		編輯所有已載入的緩衝區
			39. :[N]sbmod [N]	分割並至第 N 個已修改的緩衝區

40. :args		顯示參數列表
41. :buffers		顯示緩衝區列表

上述命令中的 [N] 的含義取決於你使用的命令：
 [N] 在命令 ?2、?3 和 ?4 中是向前/向後的緩衝區個數。
 [N] 在命令 1 和 21      中是參數號，默認值是當前參數。
 [N] 在命令 11 和 31     中是緩衝區號，默認值是當前緩衝區。
 [N] 在命令 19 和 39     中是計數。

備註: ":next" 是一個例外，因為它必須以文件名列表為參數，這是為了和 Vi 兼容。


參數列表和多窗口
--------------------------------------

每一個窗口所編輯的文件可能位於參數列表的不同位置。記住！用 ":e file" 編輯文件
後，你在參數列表中的位置沒有變化，但你並不是在編輯處於那個位置的文件。為了說明
這一點，文件消息 (和標題欄，如果有的話) 會顯示 "(file (N) of M)"，"(N)" 是當前
文件在列表中的位置，"M" 是列表中文件的數量。

所有參數列表中的條目都被加載到緩衝區列表中，這樣你也可以用緩衝區列表的命令進行
操作，比如 ":bnext"。

:[N]al[l][!] [N]				*:al* *:all* *:sal* *:sall*
:[N]sal[l][!] [N]
		重新整理屏幕，為每一個參數打開一個窗口。其它窗口統統關閉。如果
		使用了計數，則其數值為窗口數目的最大值。
		如果帶 |:tab| 修飾符，為每個參數打開一個標籤頁。如果參數數目多
		於 'tabpagemax'，多餘參數成為最後一個標籤頁的分割窗口。
		如果設置了 'hidden'，所有要關閉的窗口變為隱藏。
		如果沒有設置 'hidden'，但是設置了 'autowrite'，那麼所有改動
		的緩衝區被寫入文件。否則，包含更改過的緩衝區的窗口不會被刪除，
		除非你用 [!] 使它們隱藏。更改過的緩衝區永遠不會被丟棄，所以改
		動不會丟失。
		[N] 是最大可以打開的窗口數。'winheight' 也限制打開的窗口數。
		(如果前加了 |:vertical| 的話 'winwidth')。
		Buf/Win Enter/Leave 自動命令不會被這裡的新窗口執行，只有在它
		們真正進入時才會執行。

:[N]sa[rgument][!] [++opt] [+cmd] [N]			*:sa* *:sargument*
		這是 ":split | argument [N]" 命令的簡寫。分割窗口並切換至第 N
		號參數。但是如果該參數不存在，窗口不會分割。參見 |++opt| 和
		|+cmd|。

:[N]sn[ext][!] [++opt] [+cmd] [file ..]			*:sn* *:snext*
		這是 ":split | [N]next" 命令的簡寫。分割窗口並切換到向後第 N
		個參數。但是如果該參數不存在，窗口不會分割。參見 |++opt| 和
		|+cmd|。

:[N]spr[evious][!] [++opt] [+cmd] [N]			*:spr* *:sprevious*
:[N]sN[ext][!] [++opt] [+cmd] [N]			*:sN* *:sNext*
		這是 ":split | [N]Next" 命令的簡寫。分割窗口並切換到向前第 N
		個參數。但是如果該參數不存在，窗口不會分割。參見 |++opt| 和
		|+cmd|。

						*:sre* *:srewind*
:sre[wind][!] [++opt] [+cmd]
		這是 ":split | rewind" 命令的簡寫。分割窗口並切換到第一個參
		數。但是如果沒有參數列表，窗口不會分割。參見 |++opt| 和
		|+cmd|。

						*:sfir* *:sfirst*
:sfir[st] [++opt] [+cmd]
		與 ":srewind" 相同。

						*:sla* *:slast*
:sla[st][!] [++opt] [+cmd]
		這是 ":split | last" 命令的簡寫。分割窗口並切換到最後一個參
		數。但是如果沒有參數列表，窗口不會分割。參見 |++opt| 和
		|+cmd|。
						*:dr* *:drop*
:dr[op] [++opt] [+cmd] {file} ..
		在一個窗口內編輯第一個 {file}。
		－ 如果該文件已經被打開，切換至該文件所在窗口。
		－ 如果該文件尚未被打開，在當前窗口內打開該文件。如果當前窗口
		   無法被放棄 |abandon|，窗口會先被分割。
		參數列表 |argument-list| 會被象使用 |:next| 命令一樣被設定。
		此命令的目的在於：允許 debugger 之類的程序裡讓 Vim 編輯另一個
		文件。
		如果使用 |:tab| 修飾符，為每個參數打開一個標籤頁。如果為空，使
		用最後一個窗口。
		另見 |++opt| 和 |+cmd|。
		{僅當編譯時有 GUI 才可用}

==============================================================================
8. 在所有的緩衝區或窗口裡執行命令				*list-repeat*

							*:windo*
:windo {cmd}		在每一個窗口裡執行 {cmd}。
			這就像是： >
				CTRL-W t
				:{cmd}
				CTRL-W w
				:{cmd}
				等等……
<			只在當前標籤頁進行操作。
			如果在一個窗口裡檢測到錯誤，餘下的窗口不再訪問。
			最後一個窗口 (或者出錯的那個窗口) 成為當前窗口。
			{cmd} 可以包含 '|' 來連接多個命令。
			{cmd} 不能打開或關閉窗口，也不能更換它們的順序。
			{Vi 無此功能} {僅在編譯時加入 |+listcmds| 特性才有效}
			也參見 |:tabdo|、|:argdo| 和 |:bufdo|。

							*:bufdo*
:bufdo[!] {cmd}		在緩衝區列表的每一個緩衝區裡執行 {cmd}。
			就像是： >
				:bfirst
				:{cmd}
				:bnext
				:{cmd}
				等等……
<			如果當前文件不能被丟棄 |abandon|，並且沒有使用 [!]，命
			令失敗。
			當在一個緩衝區裡檢測到錯誤，剩下的緩衝區不再訪問。
			跳過列表外緩衝區。
			最後一個緩衝區 (或者出錯的那個緩衝區) 成為當前緩衝區。
			{cmd} 可以包含 '|' 來連接多個命令。
			{cmd} 不能刪除或添加緩衝區到緩衝區列表。
			備註: 此命令執行時，通過把 Syntax 加入 'eventignore'
			來屏蔽此自動命令事件。這樣大大加快了每個緩衝區的編輯速
			度。
			{Vi 無此功能} {僅在編譯時加入 |+listcmds| 特性才有效}
			也參見 |:tabdo|、|:argdo| 和 |:windo|。

例子： >

	:windo set nolist nofoldcolumn | normal zn

這個命令會復位 'list' 選項並在所有的窗口裡關閉折疊功能。 >

	:bufdo set fileencoding= | update

此命令在每個緩衝區裡復位 'fileencoding' 選項的值，並將改動的緩衝區存盤。結果是
所有的緩衝區都會用 'encoding' 編碼 (如果能夠正確轉換的話)。

==============================================================================
9. 當前光標處的標籤和文件名				*window-tag*

							*:sta* *:stag*
:sta[g][!] [tagname]
		執行 ":tag[!] [tagname]" 並且分割窗口打開新的標籤。參見
		|:tag|。

CTRL-W ]					*CTRL-W_]* *CTRL-W_CTRL-]*
CTRL-W CTRL-]	把當前窗口一分為二，把光標所在的標識符當作標籤，並在上面的新窗
		口跳轉至標籤所指向的地方。新窗口的高度為 N。

							*CTRL-W_g]*
CTRL-W g ]	把當前窗口一分為二，把光標所在的標識符當作標籤，並在上面的新窗
		口裡執行 ":tselect"。新窗口的高度為 N。

							*CTRL-W_g_CTRL-]*
CTRL-W g CTRL-]	把當前窗口一分為二，把光標所在的標識符當作標籤，並在上面的新窗
		口裡執行 ":tjump"。新窗口的高度為 N。

CTRL-W f					*CTRL-W_f* *CTRL-W_CTRL-F*
CTRL-W CTRL-F	把當前窗口一分為二。編輯光標下的文件名。
		類似 ":split gf"，但是找不到文件或者文件不存在時，不會分割窗
		口。
		此操作在 'path' 變量所定義的目錄和當前文件所在的目錄裡尋找文
		件。
		如果是一個類似 "type://machine/path" 的超鏈接，那麼只使用
		"/path"。
		如果指定了計數 N，那麼編輯第 N 個匹配的文件。
		{僅在編譯時加入 |+file_in_path| 特性才有效}

CTRL-W F						*CTRL-W_F*
		把當前窗口一分為二。編輯光標下的文件名並跳轉到文件名之後的行號
		上。|gF| 詳細說明該行號如何獲取。
		{僅在編譯時加入 |+file_in_path| 特性才有效}

CTRL-W gf						*CTRL-W_gf*
		打開新標籤頁，並編輯光標下的文件名。類似於 "tab split" 和
		"gf"，但如果文件不存在，不建立新標籤頁。
		{僅在編譯時加入 |+file_in_path| 特性才有效}

CTRL-W gF						*CTRL-W_gF*
		打開新標籤頁，編輯光標下的文件名，並跳轉到文件名之後的行號上。
		類似於 "tab split" 然後 "gF"，但如果文件不存在，不建立新標籤
		頁。
		{僅在編譯時加入 |+file_in_path| 特性才有效}

另見 |CTRL-W_CTRL-I|：為包含當前光標下的關鍵字的頭文件打開窗口。

==============================================================================
10. 預覽窗口					*preview-window*

預覽窗口是顯示 (預覽) 其它文件的特殊窗口。它通常是一個用來查看包含文件或者函數
定義的小窗口。{僅當編譯時加入 |+quickfix| 特性才有效}

(每個標籤頁) 只能有一個預覽窗口，可以用如下命令之一創建。另外，'previewheight'
選項可以用來指定預覽窗口的高度；預覽窗口設定 'previewwindow' 選項以便區分。
'winfixheight' 選項也被設定用來保持該窗口的高度，不受其它窗口開關的影響。

						*:pta* *:ptag*
:pta[g][!] [tagname]
		執行 ":tag[!] [tagname]" 並且在預覽窗口裡顯示標籤所指向的內
		容，不改變當前緩衝區和光標的位置。如果預覽窗口已經打開，則會被
		重用 (類似於幫助窗口)。新預覽窗口的高度由 'previewheight' 決
		定。另見 |:tag|。
		參考下面的例子。|CursorHold-example|
		與 |:tag| 有細小的差別: 當 [tagname] 與當前顯示的標籤相同時，
		該命令不會重新設置標籤匹配表的當前位置。這使 |:ptnext| 執行完
		後，|CursorHold-example| 仍可以運行。

CTRL-W z				*CTRL-W_z*
CTRL-W CTRL-Z				*CTRL-W_CTRL-Z* *:pc* *:pclose*
:pc[lose][!]	關閉當前打開的預覽窗口。如果置位了 'hidden'，或者更改了緩衝區
		並且使用了 [!]，則緩衝區變為隱藏 (除非還有其它窗口正在編輯該
		緩衝區)。如果預覽窗口的緩衝區不能關閉，此命令失敗。也參見
		|:close|。

							*:pp* *:ppop*
:[count]pp[op][!]
		在預覽窗口執行 ":[count]pop[!]"。參見 |:pop| 和 |:ptag|。
		{Vi 無此功能}

CTRL-W }						*CTRL-W_}*
		使用當前光標所處位置的標識符作為標籤，執行 :ptag。生成預覽窗口
		(如果需要的話)，窗口的高度為 N，如果沒指定高度，就使用
		'previewheight' 的值。

CTRL-W g }						*CTRL-W_g}*
		使用當前光標所處位置的標識符作為標籤，執行 :ptjump。生成預覽窗
		口 (如果需要的話)，窗口的高度為 N，如果沒指定高度，就使用
		'previewheight' 的值。

							*:ped* *:pedit*
:ped[it][!] [++opt] [+cmd] {file}
		在預覽窗口裡編輯文件 {file}。預覽窗口打開的方式和 |:ptag| 類
		似。當前窗口和光標的位置都不改變。可用實例： >
			:pedit +/fputc /usr/include/stdio.h
<
							*:ps* *:psearch*
:[range]ps[earch][!] [count] [/]pattern[/]
		與 |:ijump| 命令很像，只是找到的匹配在預覽窗口顯示。預覽窗口用
		|:ptag| 打開。當前窗口和光標的位置都不改變。有用的例子： >
			:psearch popen
<		這很像 |:ptag| 命令，你可以用它自動顯示光標所在單詞的相關信
		息。這個命令雖然不如 |:ptag| 強大，但是你可以不使用標籤文件，
		而同樣可以找到系統的頭文件。例如： >
  :au! CursorHold *.[ch] nested exe "silent! psearch " . expand("<cword>")
<		警告：可能會很慢。

例子						*CursorHold-example*  >

  :au! CursorHold *.[ch] nested exe "silent! ptag " . expand("<cword>")

如果光標停留達到至少 'updatetime' 指定的時間，這條命令以當前光標位置處的關鍵字
為參數，執行 ":ptag" 命令。"nested" 使得其它自動命令得以執行，這樣可以在預覽窗
口裡啟用語法高亮。"silent!" 屏蔽了在找不到標籤時產生的錯誤信息。也參見
|CursorHold|。要禁用此功能： >

  :au! CursorHold

更好的改進是能高亮找到的標籤，光標處沒有單詞時不執行 ":ptag"，還能處理一些其它
細節，見下： >

  :au! CursorHold *.[ch] nested call PreviewWord()
  :func PreviewWord()
  :  if &previewwindow			" 不要在預覽窗口裡執行
  :    return
  :  endif
  :  let w = expand("<cword>")		" 在當前光標位置抓詞
  :  if w =~ '\a'			" 如果該單詞包括一個字母
  :
  :    " 在顯示下一個標籤之前，刪除所有現存的語法高亮
  :    silent! wincmd P			" 跳轉至預覽窗口
  :    if &previewwindow		" 如果確實轉到了預覽窗口……
  :      match none			" 刪除語法高亮
  :      wincmd p			" 回到原來的窗口
  :    endif
  :
  :    " 試著顯示當前光標處匹配的標籤
  :    try
  :       exe "ptag " . w
  :    catch
  :      return
  :    endtry
  :
  :    silent! wincmd P			" 跳轉至預覽窗口
  :    if &previewwindow		" 如果確實轉到了預覽窗口……
  :	 if has("folding")
  :	   silent! .foldopen		" 展開折疊的行
  :	 endif
  :	 call search("$", "b")		" 到前一行的行尾
  :	 let w = substitute(w, '\\', '\\\\', "")
  :	 call search('\<\V' . w . '\>')	" 定位光標在匹配的單詞上
  :	 " 給在此位置的單詞加上匹配高亮
  :      hi previewWord term=bold ctermbg=green guibg=green
  :	 exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
  :      wincmd p			" 返回原來的窗口
  :    endif
  :  endif
  :endfun

==============================================================================
11. 使用隱藏緩衝區					*buffer-hidden*

隱藏的緩衝區不會在窗口裡顯示，但仍然載入內存，這使得 Vim 可以在文件間切換，而
無需每次在一個窗口裡讀入另一個緩衝區時讀寫文件。
{僅當編譯時加入 |+listcmds| 特性才有效}

							*:buffer-!*
如果置位了 'hidden' ('hid') 選項，":edit"、":next"、":tag" 等編輯其它文件的命
令會保留被丟棄的緩衝區。有時雖然沒有置位 'hidden'，一些在緩衝區列表中穿梭的命
令還是會把當前窗口變為隱藏。這種情況發生在：你試圖用 '!' 從窗口裡強制刪除修改
過的緩衝區。但 'autowrite' 選項關閉或者緩衝區無法寫回，

你可以用任何啟動編輯的命令使隱藏的緩衝區不再隱藏。或者用 ":bdelete" 命令將其刪
除。

'hidden' 是全局選項，它作用於所有的緩衝區。'bufhidden' 選項可以作用於指定的緩
沖區，該選項可以是下面的值：

	<empty>		使用全局 'hidden' 的值。
	hide		隱藏該緩衝區，'hidden' 沒有置位也是如此。
	unload		不隱藏，而是卸載該緩衝區，'hidden' 置位也是如此。
	delete		刪除該緩衝區。

							*hidden-quit*
如果存在一個隱藏且修改過的緩衝區，退出 Vim 會得到一條錯誤信息，並且 Vim 會把該
緩衝區變為當前的緩衝區。你可以決定是保存 (":wq") 還是退出 ( ":q!")。注意：可
能不止一個這樣的緩衝區！

緩衝區也可能是列表外的 (unlisted)，這意味著此緩衝區存在，但是從緩衝區列表中看
不到。|unlisted-buffer|


:files[!]					*:files*
:buffers[!]					*:buffers* *:ls*
:ls[!]		顯示所有緩衝區。例如：

			1 #h  "/test/text"		line 1 ~
			2u    "asdf"			line 0 ~
			3 %a+ "version.c"		line 1 ~

		如果使用了 [!]，將顯示所有的緩衝區，包括列表外緩衝區
		(此時，"列表外" (unlisted) 這一術語多少有點兒彆扭……)。

		每一個緩衝區都有唯一的號碼與之對應。這個編號是不會改變的，所以
		你可以一直使用 ":buffer N" 或 "N CTRL-^" (N 是緩衝區編號) 來選
		擇特定的緩衝區。

		標識符號 (同一列上的符號不可能同時出現)：
		u	列表外緩衝區 (只有使用 [!] 才能看到) |unlisted-buffer|
		 %	當前窗口裡的緩衝區
		 #	用 ":e #" 或 CTRL-^ 可切換到的輪換緩衝區
		  a	激活緩衝區：已載入內存並且可見
		  h	隱藏緩衝區：已載入內存但是沒有窗口顯示它
			|hidden-buffer|
		   -	不可更改的緩衝區，選項 'modifiable' 被關閉。
		   =	只讀緩衝區
		    +	已經更改的緩衝區
		    x   有讀錯誤的緩衝區

						*:bad* *:badd*
:bad[d]	[+lnum] {fname}
		在緩衝區列表裡添加文件名 {fname}，但是不把該文件載入內存。
		如果指定了 "lnum"，那麼第一次進入緩衝區時，光標會停留在那一
		行。注意 其它 + 後面的命令將被忽略。

:[N]bd[elete][!]			*:bd* *:bdel* *:bdelete* *E516*
:bd[elete][!] [N]
		卸載緩衝區 [N] (默認：當前緩衝區) 並且從緩衝區列表裡刪除該緩衝
		區。如果緩衝區被改動過，那麼該命令將失敗，除非使用 [!]，但是這
		樣所有的改動都會丟失，文件不受影響。該緩衝區的所有窗口都會關
		閉。如果緩衝區 [N] 是當前的緩衝區，那麼 Vim 會顯示另一個緩衝區
		來代替。具體來說，Vim 會選擇跳轉表裡最新且已經載入的緩衝區。
		實際上，該緩衝區還沒有被完全刪除，但是緩衝區列表把它除名
		|unlisted-buffer|，而且該緩衝區中選項的值、變量、映射和縮寫被
		清空。

:bdelete[!] {bufname}						*E93* *E94*
		類似 ":bdelete[!] [N]"，但是使用名字指定緩衝區。
		注意 如果緩衝區名字是一個數字，不能使用名字來訪問；而應用其編
		號代替。如果名字裡含有空格，在空格前插入反斜槓。

:bdelete[!] N1 N2 ...
		對緩衝區 N1、N2、…… 執行 ":bdelete[!]"。參數可以是緩衝區名或號
		(但不能是本身為數字的緩衝區名)。如果名字裡含有空格，在空格前插
		入反斜槓。

:N,Mbdelete[!]	對 N 到 M 號 (包含 N 和 M |inclusive|) 緩衝區執行
		":bdelete[!]"。

:[N]bw[ipeout][!]			*:bw* *:bwipe* *:bwipeout* *E517*
:bw[ipeout][!] {bufname}
:N,Mbw[ipeout][!]
:bw[ipeout][!] N1 N2 ...
		類似 ":bdelete"，但真正刪除緩衝區。所有和緩衝區相關的信息都丟
		失了。所有位置標記失效，選項丟失，諸如此類。除非你確切地知道自
		己正在做什麼，否則不要使用這個命令。

:[N]bun[load][!]				*:bun* *:bunload* *E515*
:bun[load][!] [N]
		卸載緩衝區 [N] (默認：當前緩衝區)。原來佔用的內存將被釋放。該
		緩衝區還保留在緩衝區列表裡。
		如果緩衝區被改動過，那麼該命令將失敗，除非使用 [!]，但是這樣所
		有的改動都會丟失。
		該緩衝區的所有窗口都會關閉。如果緩衝區 [N] 是當前的緩衝區，那
		麼 Vim 會顯示另一個緩衝區來代替。具體來說，Vim 會選擇跳轉表裡
		最新且已經載入的緩衝區。

:bunload[!] {bufname}
		類似 ":bunload[!] [N]"，但是使用名字指定緩衝區。
		注意 如果緩衝區名字是一個數字，不能使用名字來訪問；而應用其編
		號代替。如果名字裡含有空格，在空格前插入反斜槓。

:N,Mbunload[!]	對 N 到 M 號 (包含 N 和 M |inclusive|) 緩衝區執行
		":bunload[!]" 。

:bunload[!] N1 N2 ...
		對緩衝區 N1、N2、…… 執行 ":bunload[!]"。參數可以是緩衝區名或號
		(但不能是本身為數字的緩衝區名)。如果名字裡含有空格，在空格前插
		入反斜槓。

:[N]b[uffer][!] [N]			*:b* *:bu* *:buf* *:buffer* *E86*
		編輯緩衝區列表中第 [N] 個緩衝區，如果沒指定 [N]，就編輯當前的
		緩衝區。關於 [!] 參見 |:buffer-!|。這個命令同樣可以編輯不在列
		表裡的緩衝區，'buflisted' 不會因而被置位。

:[N]b[uffer][!] {bufname}
		編輯緩衝區列表中 {bufname} 對應的緩衝區。關於 [!] 參見
		|:buffer-!|。這個命令同樣可以編輯不在列表裡的緩衝區，
		'buflisted' 不會因而被置位。

:[N]sb[uffer] [N]					*:sb* *:sbuffer*
		分割窗口並編輯緩衝區列表中第 [N] 個緩衝區，如果沒指定 [N]，就
		編輯當前的緩衝區。分割時，適用 'switchbuf' 的 "useopen" 設置。
		這個命令同樣可以編輯不在列表裡的緩衝區，'buflisted' 不會因而被
		置位。

:[N]sb[uffer] {bufname}
		分割窗口並編輯緩衝區列表中 {bufname} 對應的緩衝區。這個命令同
		樣可以編輯不在列表裡的緩衝區，'buflisted' 不會因而被置位。
		備註: 如果你想做的是分割緩衝區並在另一個名字下建立備份，可以這
		麼做: >
			:w foobar | sp #

:[N]bn[ext][!] [N]					*:bn* *:bnext* *E87*
		至緩衝區列表裡往後第 [N] 個緩衝區。[N] 默認是 1。如果到了緩衝
		區列表的末尾，則從頭循環。
		關於 [!] 參見 |:buffer-!|。
		如果你在幫助緩衝區裡，這條命令讓你跳到後面的幫助緩衝區 (如果有
		的話)。同樣，你在一個正常 (非幫助) 緩衝區裡，就會使你跳到後面
		的正常緩衝區。這樣是為了在打開幫助的時候不會影響到瀏覽正常的代
		碼或文本。下面三個命令都是如此。

							*:sbn* *:sbnext*
:[N]sbn[ext] [N]
		分割窗口並至緩衝區列表往後第 [N] 個緩衝區。如果到了緩衝區列表
		的末尾，則從頭循環。使用 'switchbuf'

:[N]bN[ext][!] [N]		*:bN* *:bNext* *:bp* *:bprevious* *E88*
:[N]bp[revious][!] [N]
		至緩衝區列表往前第 [N] 個緩衝區。[N] 默認是 1。如果到了緩衝區
		列表的頂端，則從末尾往前循環。
		關於 [!] 參見 |:buffer-!| 和 'switchbuf'。

:[N]sbN[ext] [N]		*:sbN* *:sbNext* *:sbp* *:sbprevious*
:[N]sbp[revious] [N]
		分割窗口並至緩衝區列表往前第 [N] 個緩衝區。如果到了緩衝區列表
		的頂端，則從末尾往前循環。使用 'switchbuf'

							*:br* *:brewind*
:br[ewind][!]
		至緩衝區列表中的第一個緩衝區。如果列表為空，則轉到第一個列表外
		緩衝區。
		對於 [!] 參見 |:buffer-!|

							*:bf* *:bfirst*
:bf[irst]	與 ":brewind" 相同。

							*:sbr* *:sbrewind*
:sbr[ewind]	分割窗口並至緩衝區列表中的第一個緩衝區。如果列表為空，則轉到第
		一個列表外緩衝區。
		還需考慮 'switchbuf' 選項。

							*:sbf* *:sbfirst*
:sbf[irst]	與 ":sbrewind" 相同。

							*:bl* *:blast*
:bl[ast][!]	至緩衝區列表中的最後一個緩衝區。如果列表為空，則轉到最後一個列
		表外緩衝區。
		對於 [!] 參見 |:buffer-!|

							*:sbl* *:sblast*
:sbl[ast]	分割窗口並至緩衝區列表中的最後一個緩衝區。如果列表為空，則轉到
		最後一個列表外緩衝區。
		還需考慮 'switchbuf' 選項。

:[N]bm[odified][!] [N]				*:bm* *:bmodified* *E84*
		至往後第 [N] 個修改過的緩衝區。備註: 這一命令同樣也能找到列表
		外緩衝區。如果沒有修改的緩衝區，此命令失敗。

:[N]sbm[odified] [N]					*:sbm* *:sbmodified*
		分割窗口並至往後第 [N] 個修改過的緩衝區。
		還需考慮 'switchbuf' 選項。
		備註: 這個命令也能找到不在列表裡的緩衝區。

:[N]unh[ide] [N]			*:unh* *:unhide* *:sun* *:sunhide*
:[N]sun[hide] [N]
		重新排列屏幕，給緩衝區列表中的每一個載入的緩衝區打開一個窗口。
		如果給出計數，則計數為打開窗口的最多數目。

:[N]ba[ll] [N]					*:ba* *:ball* *:sba* *:sball*
:[N]sba[ll] [N]	重新排列屏幕，給緩衝區列表中的每一個緩衝區打開一個窗口。如果給
		出計數，則計數為打開窗口的最多數目。''winheight' 也限制了打開
		窗口的數目 (當前綴 |:vertical| 時則為 'winwidth')。
		Buf/Win Enter/Leave 不會在新窗口執行，只有真正進入這些窗口時才
		會。
		如果使用 |:tab| 修飾符，新窗口在新標籤頁上打開，直到用完
		'tabpagemax' 個標籤頁為止。

備註: 上面所有開始編輯另一個緩衝區的命令維持 'readonly' 的原值。這和 ":edit"
命令不同，它每次讀入文件時都會設置 'readonly' 標誌位。

==============================================================================
12. 特殊類型緩衝區				*special-buffers*

除了用來存放文本，緩衝區也可以用於其它目的。一些選項可以改變緩衝區的行為：
	'bufhidden'	緩衝區不再在窗口裡顯示時的行為
	'buftype'	緩衝區的類型
	'swapfile'	緩衝區是否需要交換文件
	'buflisted'	緩衝區是否在緩衝區列表中出現

有用的緩衝區類型：

quickfix	用來存放錯誤列表和位置列表。參見 |:cwindow| 和 |:lwindow|。這
		些命令設置 'buftype' 的值為 "quickfix"。你不應該修改它！
		'swapfile' 為關。

help		包含幫助文件。只能用 |:help| 命令創建，緩衝區的幫助標誌是內置
		的，不能被更改。選項 'buflisted' 在幫助緩衝區裡被復位。

directory	顯示目錄內容。可用於文件探索器插件。該緩衝區由以下設置創建： >
			:setlocal buftype=nowrite
			:setlocal bufhidden=delete
			:setlocal noswapfile
<		緩衝區的名字就是目錄的名字，並且在使用 |:cd| 命令時會作出相應
		的調整。

scratch		該緩衝區包含的文本可以被隨時扔掉。在關閉窗口時，緩衝區被保存下
		來，要刪除緩衝區必須顯式進行。
		設置如下： >
			:setlocal buftype=nofile
			:setlocal bufhidden=hide
			:setlocal noswapfile
<		如果你能起個有意義的名字，緩衝區的名字可以用來標識該緩衝區。

						*unlisted-buffer*
unlisted	該緩衝區不在緩衝區列表裡。它不能用來編輯，但是可以顯示幫助文
		件、記住文件名或標記。":bdelete" 命令也會設置這個選項，這樣就
		不會完全地刪除該緩衝區。設置如下： >
			:setlocal nobuflisted
<

 vim:tw=78:ts=8:ft=help:norl:
