*usr_10.txt*	For Vim version 7.3 最近更新：2006年12月

		    Vim 用戶手冊 - by Bram Moolenaar
		譯者：Nek_in http://vimcdoc.sf.net

			      做大修改


第四章我們已經介紹過作小修改的方法了。本章開始介紹如何重複多次修改和如何改動大
量的文字。這將包括使用可視模式處理一些文本塊，還有使用一個外部程序去完成非常復
雜的功能。

|10.1|	記錄與回放命令
|10.2|	替換
|10.3|	命令範圍
|10.4|	global 命令
|10.5|	可視列塊模式
|10.6|	讀、寫部分文件內容
|10.7|	排版文本
|10.8|	改變大小寫
|10.9|	使用外部程序

     下一章：|usr_11.txt|  從崩潰中恢復
     前一章：|usr_09.txt|  使用 GUI 版本
       目錄：|usr_toc.txt|

==============================================================================
*10.1*	記錄與回放命令

"." 命令重複前一個修改操作。但如果你需要作一些更複雜的操作它就不行了。這時，記
錄命令就變得很有效。這需要三個步驟：

1. "q{register}" 命令啟動一次擊鍵記錄，結果保存到 {register} 指定的寄存器中。
   寄存器名可以用 a 到 z 中任一個字母表示。
2. 輸入你的命令。
3. 鍵入 q (後面不用跟任何字符) 命令結束記錄。

現在，你可以用 "@{register}" 命令執行這個宏。

現在看看你可以怎麼用這些命令。假設你有如下文件名列表：

	stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~

    而你想把它變成這樣：

	#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~

先移動到第一行，接著執行如下命令：

	qa			啟動記錄，並使用寄存器 a
	^			移到行首
	i#include "<Esc>	在行首輸入 #include "
	$			移到行末
	a"<Esc>			在行末加上雙引號 (")
	j			移到下一行
	q			結束記錄

現在，你已經完成一次複雜的修改了。你可以通過重複三次 "@a" 完成餘下的修改。

"@a" 命令可以通過計數前綴修飾，使操作重複指定的次數。在本例中，你可以輸入：
>
	3@a


移 動 並 執 行

你可能有多個地方需要修改。只要把光標移動到相應的位置並輸入 "@a" 命令即可。如果
你已經執行過一次，你可以用 "@@" 完成這個操作，這更容易輸入一些。例如，你上次使
用 "@b" 命令引用了寄存器 b，下一個 "@@" 命令將使用寄存器 b。
    如果你對回放命令和 "." 命令作一個比較，你會發現幾個區別。首先，"." 只能重
復一次改動。而在上例中，"@a" 可以重複多次改動，還能夠執行移動操作。第二， "." 
只能記住最後一次變更操作。而寄存器執行命令允許你記錄任何操作並使用象 "@a" 這樣
的命令回放這些被記錄的操作。最後，你可以使用 26 個寄存器，因此，你可以記錄多達
26 個命令序列。


使 用 寄 存 器

用來記錄操作的寄存器與你用來拷貝文本的寄存器是相同的。這允許你混合記錄操作和其
它命令來操作這些寄存器。
    假設你在寄存器 n 中記錄了一些命令。當你通過 "@n" 執行這些命令時，你發現這
些命令有些問題。這時你可以重新錄一次，但這樣你可能還會犯其它錯誤。其實，你可以
使用如下竅門：

	G			移到行尾
	o<Esc>			建立一個空行
	"np			拷貝 n 寄存器中的文本，你的命令將被拷到整個文
				件的結尾
	{edits}			象修改普通文本一樣修改這些命令
	0			回到行首
	"ny$			把正確的命令拷貝回 n 寄存器
	dd			刪除臨時行

現在你可以通過 "@n" 命令執行正確的命令序列了。(如果你記錄的命令包括換行符，請
調整上面例子中最後兩行的操作來包括所有的行。)

追 加 寄 存 器

到此為止，我們一直使用小寫的寄存器名。要附加命令到一個寄存器中，可以使用大寫的
寄存器名。
    假設你在寄存器 c 中已經記錄了一個修改一個單詞的命令。它可以正常工作，但現
在你需要附加一個搜索命令以便找到下一個單詞來修改。這可以通過如下命令來完成：
>
	qC/word<Enter>q

啟動 "qC" 命令可以對 c 寄存器追加記錄。由此可見，記錄到一個大寫寄存器表示附加
命令到對應的小寫寄存器。

這種方法在宏記錄，拷貝和刪除命令中都有效。例如，你需要把選擇一些行到一個寄存器
中，可以先這樣拷貝第一行：
>
	"aY

然後移到下一個要拷貝的地方，執行：
>
	"AY

如此類推。這樣在寄存器 a 中就會包括所有你要拷貝的所有行。

==============================================================================
*10.2*	替換						*find-replace*

":substitute" 命令使你可以在連續的行中執行字符串替換。下面是這個命令的一般形
式：
>
	:[range]substitute/from/to/[flags]

這個命令把 [range] 指定範圍中的字符串 "from" 修改為字符串 "to"。例如，你可以把
連續幾行中的 "Professor" 改為 "Teacher"，方法是：
>
	:%substitute/Professor/Teacher/
<
	備註:
	很少人會把整個 ":substitute" 命令完整敲下來。通常，使用命令的縮寫形式
	":s" 就行了。下文我們將使用這個縮寫形式。

命令前面的 "%" 表示命令作用於全部行。如果不指定行範圍，":s" 命令只作用在當前行
上。|10.3| 將對 "行範圍" 作深入的介紹。

默認情況下，":substitute" 命令只對某一行中的第一個匹配點起作用。例如，前面例子
中會把行：

	Professor Smith criticized Professor Johnson today. ~

修改成：

	Teacher Smith criticized Professor Johnson today. ~

要對行中所有匹配點起作用，你需要加一個 g (global，全局) 標記。下面命令：
>
	:%s/Professor/Teacher/g

對上面例子中的句子的作用效果如下：

	Teacher Smith criticized Teacher Johnson today. ~

":s" 命令還支持其它一些標誌位，包括 "p" (print，打印)，用於在命令執行的時候打
印出最後一個被修改的行。還有 "c" (confirm，確認) 標記會在每次替換前向你詢問是
否需要替換。執行如下命令：
>
	:%s/Professor/Teacher/c

Vim 找到第一個匹配點的時候會向你提示如下：
>
	replace with Teacher (y/n/a/q/l/^E/^Y)?

(中文翻譯如下：
>
	替換為 Teacher 麼 (y/n/a/q/l/^E/^Y)?
<
)

這種時候，你可以輸入如下回答中的一個：

	y		Yes，是；執行替換
	n		No，否；跳過
	a		All，全部；對剩下的匹配點全部執行替換，不需要再確認
	q		Quit，退出；不再執行任何替換
	l		Last，最後；替換完當前匹配點後退出
	CTRL-E		向上滾動一行
	CTRL-Y		向下滾動一行


":s" 命令中的 "from" 部分實際上是一個 "匹配模式" (還記得嗎？這是我們前面給
pattern 起的名字譯者)，這與查找命令一樣。例如， 要替換行首的 "the" 可以這樣
寫：
>
	:s/^the/these/

如果你要在 "from" 或者 "to" 中使用正斜槓，你需要在前面加上一個反斜槓。更簡單的
方法是用加號代替正斜槓。例如：
>
	:s+one/two+one or two+

==============================================================================
*10.3*	命令範圍

":substitute" 命令和很多其它的 ":" 命令一樣，可以作用於選中的一些行。這稱為一
個 "範圍"。
    最簡單的範圍表達形式是 "{number},{number}"。例如：
>
	:1,5s/this/that/g

這會在 1 到 5 行上執行替換命令。(包括第 5 行)。"範圍" 總是放在一個命令的前面。

如果只用一個數值，表示某個指定的行：
>
	:54s/President/Fool/

有些命令在不指定範圍的時候作用於整個文件。要讓它只作用於當前行可以用當前行範圍
標識 "."。":write" 命令就是這樣：不指定範圍的時候，它寫入整個文件，如果要僅寫
入當前行，可以這樣：
>
	:.write otherfile

文件的第一行行號總是 1，最後一行又是多少呢？"$" 字符用於解決這個問題。例如，要
修改當前行到文件末的全部內容，可以這樣：
>
	:.,$s/yes/no/

我們前面使用的 "%" 就是 "1,$" 的縮寫形式，表示從文件首到文件末。


在 范 圍 中 使 用 模 式

假設你正在編輯一本書中的一章，並且想把所有的 "grey" 修改成 "gray"。但你只想修
改這一章，不想影響其它的章節。另外，你知道每章的開頭的標誌是行首的單詞為
"Chapter"。下面的命令會對你有幫助：
>
	:?^Chapter?,/^Chapter/s=grey=gray=g

你可以看到這裡使用了兩個查找命令。第一個是 "?^Chapter?"，用於查找前一個行首的
"Chapter"，就是說 "?pattern?" 用於向前查找。同樣，"/^Chapter/" 用於向後查找下
一章。
    為了避免斜槓使用的混淆，在這種情況下，"=" 字符用於代替斜槓。使用斜槓或使用
其它字符其實也是可以的。


加 減 號

上面的方案其實還是有問題的：如果下一章的標題行中包括 "grey"，這個 "grey" 也會
被替換掉。如果你正好想這樣就最好，可是正好你不想呢？這個時候你需要指定一個偏
移。
    要查找一個模式，並且使用它的前一行，需要這樣：
>
	/Chapter/-1

你可以用任意數值代替命令中的 1。要定位匹配點下的第二行，要這樣：
>
	/Chapter/+2

偏移還可以用於其它範圍指定符。看一下下面這個例子：
>
	:.+3,$-5

這指定當前行下面第三行到文件末倒數第五行的範圍。


使 用 標 記

除了指定行號，(這需要記住並把它敲出來)，你還可以使用標記。
    在前面的例子中，你可以用標記指出第三章的位置。例如，用 "mt" 標記開頭，再用
"mb" 標記結尾。然後你就可以用標記表示一個範圍 (包括標記的那一行)：
>
	:'t,'b


可 視 模 式 和 范 圍

你可以在可視模式中選中一些行。如果你現在輸入 ":" 啟動冒號命令模式，你會看到：
>
	:'<,'>

現在，你可以輸入剩下的命令，這個命令的作用範圍就是可視模式中指定的範圍。

	備註:
	如果使用可視模式選中行的一部分，或者用 CTRL-V 選中一個文本列塊，然後執
	行冒號命令，命令仍作用於整行，而不只是選中的範圍。這可能會在以後的版本
	中修正。

'< 和 '> 實際上是標記，分別標識可視模式的開始和結尾。這個標記一直有效，直到選
中了其它的範圍為止。你還可以用標記跳轉命令 "'<" 跳轉到選中文本的開始處。你還可
以把這個標記和其它標記混合，例如：
>
	:'>,$

這表示從選中部分的結尾到文件末。


指 定 行 數

如果你知道要修改多少行，你可以先輸入一個數值再輸入冒號。例如，如果你輸入
"5:"，你會得到：
>
	:.,.+4

現在你可以繼續你的命令，這個命令將作用於當前行及其後 4 行。

==============================================================================
*10.4*	global 命令

":global" 命令是 Vim 中一個更強大的命令 (之一)。它允許你找到一個匹配點並且在那
裡執行一個命令。它的一般形式是：
>
	:[range]global/{pattern}/{command}

這有點像 ":substitute" 命令。只是它不替換文本，而是執行 {command} 指定的命令。

	備註:
	global 中執行的命令只能是冒號命令。普通模式命令不能在這裡使用。如果需
	要，可以使用 |:normal| 命令。

假設你要把 "foobar" 修改為 "barfoo"，但只需要修改 C++ 風格的註釋中的內容。這種
註釋以 "//" 開頭。所以可以使用如下命令：
>
	:g+//+s/foobar/barfoo/g

這個命令用 ":g" 開頭，這是 ":global" 的縮寫形式，就像 ":s" 是 ":substitute" 的
縮寫形式一樣。然後是一個匹配模式，由於模式中包括正斜槓，我們用加號作分隔符，後
面是一個把 "foobar" 替換成 "barfoo" 的替換命令。
    全局命令的默認範圍是整個文件，所以這個例子中沒有指定範圍。這一點與
":substitute" 是不同的。後者只作用於一行。
    這個命令並非完美。因為 "//" 可能出現在一行的中間，但替換命令會把前後的匹配
點都替換了。

像 ":substitute" 一樣，這裡也可以使用各種各樣的匹配模式。當你從後面的章節中學
會更多的關於模式的知識，它們都可以用在這裡。

==============================================================================
*10.5*	可視列塊模式

CTRL-V 命令可以選中一個矩形文本塊。有幾個命令是專門用來處理這個文本塊的。

在可視列塊模式中，"$" 命令有些特別。當最後一個移動命令是 "$" 時，整個可視列塊
將被擴展到每一行的行尾。這種狀態在你使用垂直移動命令的時候一直被保持，直到你使
用水平移動命令為止。就是說，用 "j" 命令會保持這種狀態，而 "h" 會退出。


插 入 文 本

"I{string}<Esc>" 命令把 {string} 插到可視列塊的每一行的左邊。你用 CTRL-V 進入
可視列塊模式，然後移動光標定義一個列塊。接著輸入 I 進入插入模式，並隨後輸入文
本。這時，你輸入的內容只出現在第一行。
    然後你輸入 <Esc> 結束輸入，剛才輸入的字符串將神奇地出現在每一行的可視區的
左邊。例如：

	include one ~
	include two ~
	include three ~
	include four ~

把光標移到第一行 "one" 的 "o"上，輸入 CTRL-V。然後用 "3j" 向下移動到 "four"。
現在你選中了四行的一個方塊。接著輸入：
>
	Imain.<Esc>

結果將是：

	include main.one ~
	include main.two ~
	include main.three ~
	include main.four ~

如果選中的塊經過一個短行，並且這行沒有任何內容包括在可視列塊中，則新的文本不會
被插入到該行中。例如，對於下面的例子，用可視列塊選中第一和第三行的 "long"，這
樣第二行的文本將不會被包括在可視列塊中：

	This is a long line ~
	short ~
	Any other long line ~

		  ^^^^ 用可視列塊選中的部分

現在輸入 "Ivery <esc>"。結果將是：

	This is a very long line ~
	short ~
	Any other very long line ~

可以注意到，第二行中沒有插入任何文本。

如果插入的文本中包括一個新行，則 "I" 命令的效果與普通插入語句一樣，只影響塊的
第一行。

"A" 命令的效果與 "I" 命令一樣，只是把文字插入可視列塊的右邊，而且在短行中會插
入文字。這樣，你有在短行中插入文字與否的不同選擇。
    "A" 在如下情況會有一些特別：選中一個可視列塊然後用 "$" 命令使可視列塊擴展
到行尾。然後用 "A" 命令插入文本，文件將被插入到 "每一行" 的行尾。
    還是用上面的例子，在選中可視列塊後輸入 "$A XXX<Esc>"，結果將是：

	This is a long line XXX ~
	short XXX ~
	Any other long line XXX ~

出現這個效果完全是 "$" 命令的作用，Vim 能記住這個命令，如果你用移動命令選中相
同的可視列塊，是不會有這樣的效果的。


修 改 文 本

可視列塊中的 "c" 命令會刪除整個可視列塊並轉入 "插入" 模式，使你可以開始文本，
這些文本會被插入可視列塊經過的每一行。
    在上面的例子中，如果仍選中包括所有 "long" 的一個可視列塊，然後輸入
"c_LONG_<Esc>"，結果會變成：

	This is a _LONG_ line ~
	short ~
	Any other _LONG_ line ~

與 "I" 命令一樣，短行不會發生變化。而且在插入的過程中，你不能斷行。

"C" 命令從塊的左邊界開始刪除所有行的後半段，然後狀態切換到 "插入" 模式讓你輸
入文本。新的文本被插入到每一行的末尾。
    在上面的例子中，如果命令改為 "Cnew text<Esc>"，你將獲得這樣的結果：

	This is a new text ~
	short ~
	Any other new text ~

可以注意到，儘管只有 "long" 被選中，它後面的內容也被刪除了。所以在這種情況下，
塊的左邊界才是有意義的。
    同樣，沒有包括在塊中的行不會受影響。

還有一些命令只影響被選中的字符：

	~       交換大小寫     (a -> A 而 A -> a)
	U       轉換成大寫     (a -> A 而 A -> A)
	u       轉換成小寫     (a -> a 而 A -> a)


以 一 個 字 符 填 充

要以某一個字符完全填充整個塊，可以使用 "r" 命令。再次選中上例中的文本，然後鍵
入 "rx":

	This is a xxxx line ~
	short ~
	Any other xxxx line ~


	備註:
	如果你要在可視列塊中包括行尾之後的字符，請參考 25 章的 'virtualedit' 
	特性。


平 移

">" 命令把選中的文檔向右移動一個 "平移單位"，中間用空白填充。平移的起始點是可
視列塊的左邊界。
    還是用上面的例子，">" 命令會導致如下結果：

	This is a	  long line ~
	short ~
	Any other	  long line ~

平移的距離由 'shiftwidth' 選項定義。例如，要每次平移 4 個空格，可以用這個命
令：
>
	:set shiftwidth=4

"<" 命令向左移動一個 "平移單位"，但能移動的距離是有限的，因為它左邊的不是空白
字符的字符會擋住它，這時它移到盡頭就不再移動。


連 接 若 干 行

"J" 命令連接被選中的行。其實就是刪除所有的換行符。其實不只是換行符，行前後的多
余空白字符會一起被刪除而全部用一個空格取代。如果行尾剛好是句尾，就插入兩個空格
(參見 'joinspaces' 選項)
    還是用那個我們已經非常熟悉的例子，這回的結果將是：

	This is a long line short Any other long line ~

"J" 命令其實不關心選中了哪些字符，只關心塊涉及到哪些行。所以可視列塊的效果與
"v" 和 "V" 的效果是完全一樣的。

如果你不想改變那些空白字符，可以使用 "gJ" 命令。

==============================================================================
*10.6*	讀、寫文件的一部分

當你在寫一封 e-mail，你可能想包括另一個文件。這可以通過 ":read {filename}" 命
令達到目的。這些文本將被插入到光標的下面。
    我們用下面的文本作試驗：

	Hi John, ~
	Here is the diff that fixes the bug: ~
	Bye, Pierre. ~

把光標移到第二行然後輸入：
>
	:read patch

名叫 "patch" 的文件將被插入，成為下面這個樣子：

	Hi John, ~
	Here is the diff that fixes the bug: ~
	2c2 ~
	<	for (i = 0; i <= length; ++i) ~
	--- ~
	>	for (i = 0; i < length; ++i) ~
	Bye, Pierre. ~

":read" 支持範圍前綴。文件將被插入到範圍指定的最後一行的下面。所以
":$r patch" 會把 "patch" 文件插入到當前文件的最後。
    如果要插入到文件的最前面怎麼辦？你可以把文本插入到第 0 行，這一行實際上是
不存在的。在普通的命令的範圍中如果你用這個行號會出錯，但在 "read" 命令中就可
以：
>
	:0read patch

這個命令把 "patch" 文件插入到全文的最前面。


保 存 部 分 行

要把一部分行寫入到文件，可以使用 ":write" 命令。在沒有指定範圍的時候它寫入全
文，而指定範圍的時候它只寫入範圍指定的行：
>
	:.,$write tempo

這個命令寫入當前位置到文件末的全部行到文件 "tempo" 中。如果這個文件已經存在，
你會被提示錯誤。Vim 不會讓你直接寫入到一個已存在的文件。如果你知道你在幹什麼而
且確實想這樣做，就加一個歎號：
>
	:.,$write! tempo

小 心："!" 必須緊跟著 ":write"，中間不能留有空格。否則這將變成一個過濾器命令，
這種命令我們在本章的後面會介紹。


添 加 內 容 到 文 件 中

本章開始的時候介紹了怎樣把文本添加到寄存器中。你可以對文件作同樣的操作。例如，
把當前行寫入文件：
>
	:.write collection

然後移到下一個位置，輸入：
>
	:.write >>collection

">>" 通知 Vim 把內容添加到文件 "collection" 的後面。你可以重複這個操作，直到獲
得全部你需要收集的文本。

==============================================================================
*10.7*	排版文本

在你輸入純文本時，自動換行自然會是比較吸引的功能。要實現這個功能，可以設置
'textwidth' 選項：
>
	:set textwidth=72

你可能還記得在示例 vimrc 文件中，這個命令被用於所有的文本文件。所以如果你使用
的是那個配置文件，實際上你已經設置這個選項了。檢查一下該選項的值：
>
	:set textwidth

現在每行達到 72 個字符就會自動換行。但如果你只是在行中間輸入或者刪除一些東西，
這個功能就無效了。Vim 不會自動排版這些文本。
    要讓 Vim 排版當前的段落：
>
	gqap

這個命令用 "gq" 開始，作為操作符，然後跟著 "ap"，作為文本對象，該對像表示 "一
段" (a paragraph)。"一段" 與下一段的分割符是一個空行。

	備註:
	只包括空白字符的空白行不能分割 "一段"。這很不容易分辨。

除了用 "ap"，你還可以使用其它 "動作" 或者 "文本對像"。如果你的段落分割正確，你
可以用下面命令排版整個文檔：
>
	gggqG

"gg" 跳轉到第一行，"gq" 是排版操作符，而 "G" 是跳轉到文尾的 "動作" 命令。

如果你沒有清楚地區分段落。你可以只排版你手動選中的行。先移到你要格式化的行，執
行 "gqj"。這會排版當前行和下面一行。如果當前行太短，下面一行會補上來，否則多餘
的部分會移到下面一行。現在你可以用 "." 命令重複這個操作，直到排版完所有的文
本。

==============================================================================
*10.8*	改變大小寫

你手頭有一個分節標題全部是小寫的。你想把全部 "section" 改成大寫的。這可以用
"gU" 操作符。先在第一列執行：
>
			     gUw
<	section header 	    ---->      SECTION header

"gu" 的作用正好相反：
>
			     guw
<	SECTION header	    ---->      section header

你還可以用 "g~" 來交換大小寫。所有這些命令都是操作符，所以它們可以用於 "動作"
命令，文本對像和可視模式。
    要讓一個操作符作用於當前行，可以執行這個操作符兩次。例如，"d" 是刪除操作
符，所以刪除一行就是 "dd"。相似地，"gugu" 使整一行變成小寫。這可以縮成 "guu"。
"gUgU" 可以縮成 "gUU" 而 "g~g~" 則是 "g~~"。例如：
>
				g~~ 
<	Some GIRLS have Fun    ---->   sOME girls HAVE fUN ~


==============================================================================
*10.9*	使用外部程序

Vim 有一套功能非常強大的命令，可以完成所有功能。但有些東西外部命令能夠完成得更
好或者更快。
    命令 "!{motion}{program}" 用一個外部程序對一個文本塊進行過濾。換句話說，它
用一個文本塊作為輸入，執行一個由 {program} 指定的外部命令，然後用該程序的輸出
替代選中的文本塊。
    如果你不熟悉 UNIX 的過濾程序，上面的描述可以說是比較糟糕的。我們這裡舉個例
子來說明一下。sort 命令能對一個文件排序。如果你執行下面的命令，未排序的文件
input.txt 會被排序並寫入 output.txt。(這在 UNIX 和 Microsoft Windows 上都有效)
>
	sort <input.txt >output.txt

現在在 Vim 中完成相同的功能。假設你要對 1 到 5 行排序。你可以先把光標定位在第
一行，然後你執行下面的命令：
>
	!5G

"!" 告訴 Vim 你正在執行一個過濾操作。然後 Vim 編輯器等待一個 "動作" 命令來告訴
它要過濾哪部分文本。"5G" 命令告訴 Vim 移到第 5 行。於是，Vim 知道要處理的是第
1 行 (當前行) 到第 5 行間的內容。
    由於在執行一個過濾命令，光標被 Vim 移到了屏幕的底部，並顯示一個 "!" 作提示
符。現在你可以輸入過濾程序的名字，在本例中就是 "sort" 了。因此，你整個命令將
是：
>
	!5Gsort<Enter>

這個命令的結果是 sort 程序用前 5 行作為輸入執行，程序的輸出替換了原來的 5 行。

	line 55			      line 11
	line 33			      line 22
	line 11		-->	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line

"!!" 命令用於對當前行執行過濾命令。在 Unix 上，"date" 命令能打印當前的時間和日
期，所以，"!!date<Enter>" 用 "date" 的輸出代替當前行。這在為文件加入時間戳的時
候非常有用。


如 果 命 令 不 執 行 怎 麼 辦

啟動一個 shell，發送一個命令並捕獲它的輸出，這需要 Vim 知道這個 shell 程序是怎
麼工作的。如果你要使用過濾程序，你最好需要檢查一下下面的選項：

	'shell'		指定 Vim 用於執行外部命令的 shell。
	'shellcmdflag'	傳給 shell 的參數
	'shellquote'	shell 程序使用的引號 (用於引用命令)
	'shellxquote'	用於命令和重定向文件名的引號
	'shelltype'	shell 程序的類型 (僅用於 Amiga)
	'shellslash'	在命令中使用正斜槓 (僅用於 MS-Windows 和相容系統)
	'shellredir'	用於把命令輸出寫入文件所使用的字符串

在 Unix 上，這幾乎不是問題。因為總共只有兩種 shell 程序："sh" 類的和 "csh" 類
的。Vim 會檢查選項 'shell'，並根據它的類型自動設置這些參數。
   但在 MS-Windows 上，有很多不同的 shell 程序，所以你必須修改這些 shell 程序
以便過濾功能正常執行。詳細情況請參考相應選項的幫助。


讀 入 一 個 命 令 的 輸 出

要把當前目錄的內容讀進文件，可以用如下命令：

Unix 上： >
	:read !ls
MS-Windows 上： >
	:read !dir

"ls" 或者 "dir" 的輸出會被捕獲並插入到光標下面。這好像讀入一個文件一樣，但是需
要加上一個 "!" 讓 Vim 知道後面是一個命令。
    這些命令還可以帶參數。而且前面還可以帶一個範圍用於告訴 Vim 把這行放在什麼
地方：
>
	:0read !date -u

這將用 UTC 格式把當前的時間插入到文件開頭。(當然了，你的 date 命令必須能夠接受
-u 選項。) 注意 這與 "!!date" 的區別："!!date" 替代一行，而 ":read !date" 插入
一行。


把 文 本 輸 出 到 一 個 命 令

Unix 命令 "wc" 用於統計單詞數目。要統計當前文件有多少個單詞，可以這樣：
>
	:write !wc

這和前面的寫入命令一樣，但文件名前面改為一個 "!" 用於告訴 Vim 後面是一個要被執
行的外部命令。被寫入的文本將作為指定命令的標準輸入。這個輸出將是：

       4      47     249 ~

"wc" 命令惜字如金。這表示你有 4 行，47 個單詞和 249 個字符。

注意不要錯寫成：
>
	:write! wc

這會強制把當前文件存到當前目錄的 "wc" 文件中。在這裡空格的位置是非常重要的！


重 畫 屏 幕

如果外部程序產生一個錯誤信息，屏幕顯示就會亂掉。Vim 頗重效率，所以它只刷新那些
需要刷新的地方。可是它不可能知道其它程序修改了哪些地方。要強制 Vim 重畫整個屏
幕：
>
	CTRL-L

==============================================================================

下一章：|usr_11.txt|  從崩潰中恢復

版權：參見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
