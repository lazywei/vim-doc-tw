*cmdline.txt*   For Vim version 7.3.  最近更新: 2010年7月


		  	VIM 參 考 手 冊    	by Bram Moolenaar

				翻譯: Dasn, tocer  http://vimcdoc.sf.net
					


				*Cmdline-mode* *Command-line-mode*
命令行模式		*Cmdline* *Command-line* *mode-cmdline* *:*

命令行模式可以用來輸入 Ex 命令 (":")，搜索符合模式的字符串 ("/" 和 "?")，和過
濾命令 ("!")。

一些基本的、與命令行編輯相關的內容在用戶手冊的第 20 章裡有所描述，見:
|usr_20.txt|。

1. 命令行編輯			|cmdline-editing|
2. 命令行補全			|cmdline-completion|
3. Ex 命令行			|cmdline-lines|
4. Ex 命令行的範圍		|cmdline-ranges|
5. Ex 命令行的標誌位		|ex-flags|
6. Ex 特殊字符			|cmdline-special|
7. 命令行窗口			|cmdline-window|

==============================================================================
1. 命令行編輯						*cmdline-editing*

通常，字符會在光標位置前插入。你可以用鍵盤上的左右鍵來移動光標的位置。還可以通
過 <Insert> 鍵，在 "插入" 和 "替換" 兩種模式之間切換。
{Vi: 只能改變每一行的最後一個字符}

注意，如果你的鍵盤上沒有可以移動光標的鍵或其它特殊鍵，你可以用 ":cnoremap" 定
義另外一個鍵來代替它們。例如，定義一組 tcsh 風格的鍵: 	*tcsh-style*  >
	:cnoremap <C-A> <Home>
	:cnoremap <C-F> <Right>
	:cnoremap <C-B> <Left>
	:cnoremap <Esc>b <S-Left>
	:cnoremap <Esc>f <S-Right>
(<> 記法，見 |<>|; 上面的例子要一字不落地輸入)

							*cmdline-too-long*
當命令行指令長度大於屏幕的寬度時，只有合適的部分被顯示出來。光標只能在命令的
可視部分移動，所以你不能編輯其他部分。

						*cmdline-history* *history*
在命令行裡輸入的命令會存儲在歷史記錄中，你可以使用上下箭頭鍵來翻閱它們。有五個
歷史表:
- 一個是為 ':' 命令準備的
- 一個是為搜索字符串準備的
- 一個是為表達式準備的
- 一個是為輸入行準備的，用來輸入 |input()| 函數。
- 一個是為調試模式下的命令準備的

這些記錄是完全分開的。每一種輸入模式只能訪問與之相關的一個記錄。
選項 'history' 用來設定保存歷史記錄的行數 (默認值: 20 ) 。

注意:
- 如果你輸入了一條命令與歷史記錄中已有的命令完全相同，那麼歷史記錄中的這條舊命
  令會被刪除 (這樣做是為了避免歷史列表被大量的重複指令佔據)。
- 只有鍵入的命令才會記錄下來。完全來自映射的命令不會。
- 所有的搜索操作都會放到與搜索相關的歷史記錄中，包括通過 "*" 和 "#" 進行的搜
  索。但是對於映射，只有最近一次的搜索會被記錄下來 (這樣是為了避免很長的映射把
  歷史記錄搞亂) 。
{Vi: 沒有歷史記錄}
{僅當編譯的時候加入 |+cmdline_hist| 特性才可用}

命令行的自動匹配功能；見 |cmdline-completion|。

							*c_CTRL-V*
CTRL-V		下一個字符如果是非數字字符，按本義插入。不然，不超過三個的數字
		字符用於輸入單個字節的十進制編碼。非數字和三個數字字符不會被映
		射。這與插入模式下的工作方式相同 (見 |i_CTRL-V|)。
		注意: 由於在 Windows 系統上，CTRL-V 被映射為 "粘貼文本"，這時
		我們要用 CTRL-Q 代替 CTRL-V。
							*c_CTRL-Q*
CTRL-Q		與 CTRL-V 相同。但是有些終端把它定義為控制字符，那樣就無法使用
		了。

							*c_<Left>*
<Left>		光標左移
							*c_<Right>*
<Right>		光標右移
							*c_<S-Left>*
<S-Left> 或 <C-Left>					*c_<C-Left>*
		光標左移一個字串 (WORD)
							*c_<S-Right>*
<S-Right> 或 <C-Right>					*c_<C-Right>*
		光標右移一個字串 (WORD)
CTRL-B 或 <Home>					*c_CTRL-B* *c_<Home>*
		光標移動至命令的起始
CTRL-E 或 <End>						*c_CTRL-E* *c_<End>*
		光標移動至命令的末尾

							*c_<LeftMouse>*
<LeftMouse>	將光標置於點擊鼠標的地方。

CTRL-H							*c_<BS>* *c_CTRL-H*
<BS>		刪除光標前面的字符 (如果你的 <BS> 鍵不能正常工作，請參閱
		|:fixdel| )。
							*c_<Del>*
<Del>		刪除光標下的字符 (如果光標處於行的末尾，則刪除光標前的字符)
		(如果你的 <Del> 鍵不能正常工作，請參閱 |:fixdel|)。
							*c_CTRL-W*
CTRL-W		刪除光標前的單詞 (|word|)。單詞範圍受 'iskeyword' 選項影響。
							*c_CTRL-U*
CTRL-U		刪除光標所在位置與行首之間的所有字符。先前一些版本的 vim 刪
		除整行的所有字符。如果你喜歡原先的這種方式，可以把下面的命令
		加入到你的 .vimrc :  >
			:cnoremap <C-U> <C-E><C-U>
<
							*c_<Insert>*
<Insert>	在插入和替換之間切換。{Vi 沒有該功能}

{char1} <BS> {char2}	或				*c_digraph*
CTRL-K {char1} {char2}					*c_CTRL-K*
		輸入二合字母 (見 |digraphs|)。如果 {char1} 是一個特殊鍵，插入
		該鍵 <> 形式的編碼。{Vi 沒有該功能}

CTRL-R {0-9a-z"%#:-=.}					*c_CTRL-R* *c_<C-R>*
		插入寄存器裡的內容。當按下 CTRL-R 時，屏幕會顯示一個 '"' 字
		符，提示你輸入一個寄存器的名字。
		插入的文字就像是你自己輸入的，但是映射和縮寫不會生效。同樣也不
		會觸發 'wildchar' 的補全功能。並且那些可以結束命令的字符會被按
		字面插入 (<Esc>，<CR>，<NL>，<C-C>)。但 <BS> 或 CTRL-W 仍舊可
		能結束命令行模式，並使剩餘的字符被接下來其他的模式解釋，這可能
		並非你的本意。
		特殊寄存器:

			'"'	無名寄存器，包含最近一次刪除或複製的內容
			'%'	當前文件名
			'#'	輪換文件名
			'*'	剪貼板的內容 (X11: 主選擇區)
			'+'	剪貼板的內容
			'/'	最近一次的查找模式
			':'	最近一次在命令行輸入的命令
			'-'	最近一次小的 (少於一行) 刪除
			'.'	最近插入的文本
							*c_CTRL-R_=*
			'='	表達式寄存器: 會提示你輸入一個表達式。
				(見 |expression|)
				(在表達式提示中無效；不允許改變緩衝區或者當前
				窗口這樣的操作，以避免副作用)
				如果結果為 |List| 列表，其中的每一項當作一行。
				當然其中內容也可包含換行符。
				如果結果為浮點數，自動轉換為字符串。
		與寄存器相關的內容請參見 |registers|。{Vi 無此功能}
		實現細節: 如果使用 |expression| 寄存器並且調用 setcmdpos()，那
		麼在插入返回的文本之前設置光標位置。使用 CTRL-R CTRL-R 在插入
		返回的文本之後設置光標位置。

CTRL-R CTRL-F				*c_CTRL-R_CTRL-F* *c_<C-R>_<C-F>*
CTRL-R CTRL-P				*c_CTRL-R_CTRL-P* *c_<C-R>_<C-P>*
CTRL-R CTRL-W				*c_CTRL-R_CTRL-W* *c_<C-R>_<C-W>*
CTRL-R CTRL-A				*c_CTRL-R_CTRL-A* *c_<C-R>_<C-A>*
		插入光標下的對象:
			CTRL-F	光標下的文件名
			CTRL-P	用 'path' 擴展的光標下的文件名。與 |gf|
				中的類似。
			CTRL-W	光標下的單詞
			CTRL-A	光標下的字串；參見: |WORD|

		如果置位 'incsearch'，使用當前顯示匹配文本的末尾作為光標位置。
		使用 CTRL-W 時，已經錄入的單詞部分不再重複插入。

		{Vi 無此功能}
		CTRL-F 和 CTRL-P: {僅當包含 |+file_in_path| 特性才可用}

					*c_CTRL-R_CTRL-R* *c_<C-R>_<C-R>*
					*c_CTRL-R_CTRL-O* *c_<C-R>_<C-O>*
CTRL-R CTRL-R {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
CTRL-R CTRL-O {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
		插入寄存器或光標下的對象。類似於 |c_CTRL-R|，但是該命令按字面
		插入文本。例如，如果寄存器 a 的內容為 "xy^Hz" (^H 是退格鍵)，
		那麼 "CTRL-R a" 會插入 "xz"，而 "CTRL-R CTRL-R a" 會插入
		"xy^Hz"。

CTRL-\ e {expr}						*c_CTRL-\_e*
		計算表達式 {expr} 並用結果替換整個命令行。程序會提示你輸入表達
		式，用 <Enter> 鍵提交表達式。這項功能在映射裡十分有用。參見
		|expression|。
		欲瞭解插入表達式結果的相關信息，請參閱 |c_CTRL-R_=|。
		|getcmdline()|、|getcmdline()| 和 |getcmdpos()| 函數在這裡很有
		用。
		缺省，光標的位置不會改變，除非光標正位於行末，那麼它還會停留在
		行末。
		不過，可以用 |setcmdpos()| 來自行設置光標的位置。
		使用沙盤 |sandbox| 計算表達式以避免討厭的副作用。
		例如:  >
			:cmap <F7> <C-\>eAppendSome()<CR>
			:func AppendSome()
			   :let cmd = getcmdline() . " Some()"
			   :" place the cursor on the )
			   :call setcmdpos(strlen(cmd))
			   :return cmd
			:endfunc
<		它無法遞歸操作，所以如果正在編輯一個表達式，它將無效。

							*c_CTRL-Y*
CTRL-Y		當存在無模式選擇時，複製該選擇區域的內容至剪貼板。
		參考 無模式選擇 |modeless-selection|。
		如果沒有選擇，那麼 CTRL-Y 會被當作字符直接插入。

CTRL-J						*c_CTRL-J* *c_<NL>* *c_<CR>*
<CR> 或 <NL>	執行輸入的命令
							*c_<Esc>*
<Esc>		如果 'cpoptions' 選項中不包括 'x'，那麼輸入該鍵會退出命令行模
		式，而不執行命令。若 'cpoptions' 裡包含 'x'，或者該鍵出現在宏
		命令裡，則執行輸入的命令。
		注意: 如果鍵盤上輸入 <Esc> 不方便，請訓練一下用 CTRL-[ 吧。
							*c_CTRL-C*
CTRL-C		不執行命令，退出命令行模式

							*c_<Up>*
<Up>		在歷史記錄中查找開始部分與當前輸入匹配的前一條命令。(見下面)
		{僅當編譯時加入 |+cmdline_hist| 特性才可用}
							*c_<Down>*
<Down>		在歷史記錄中查找開始部分與當前輸入匹配的下一條命令。(見下面)
		{僅當編譯時加入 |+cmdline_hist| 特性才可用}

						*c_<S-Up>* *c_<PageUp>*
<S-Up> 或 <PageUp>
		取回歷史記錄中的上一條命令
		{僅當編譯時加入 |+cmdline_hist| 特性才可用}
						*c_<S-Down>* *c_<PageDown>*
<S-Down> 或 <PageDown>
		取回歷史記錄中的下一條命令
		{僅當編譯時加入 |+cmdline_hist| 特性才可用}

CTRL-D		命令行補全 (見 |cmdline-completion|)
'wildchar' 選項
		命令行補全 (見 |cmdline-completion|)
CTRL-N		命令行補全 (見 |cmdline-completion|)
CTRL-P		命令行補全 (見 |cmdline-completion|)
CTRL-A		命令行補全 (見 |cmdline-completion|)
CTRL-L		命令行補全 (見 |cmdline-completion|)

							*c_CTRL-_*
CTRL-_		a - 在希伯來語和英語的鍵盤模式之間切換，這只是針對命令行模式，
		與 hkmap 無關。如果命令行、搜索、縮寫，等等需要輸入希伯來文的
		話，這一功能就很有用了。只有在 Vim 編譯時加入了 |+rightleft|，
		並且置位了 'allowrevins' 選項後，該功能才可用。
		參見 |rileft.txt|。

		b - 在波斯語和英語的鍵盤模式之間切換，這只是針對命令行模式，與
		fkmap 無關。在波斯語鍵盤模式下，字符的插入方式與平時相反 (即從
		右至左)。如果命令行、搜索、縮寫，等等需要輸入波斯語的話，這一
		功能就很有用了。只有在 Vim 編譯時加入了 |+farsi|，該功能才可
		用。
		參見 |farsi.txt|。

							*c_CTRL-^*
CTRL-^		語言映射 |:lmap| 和/或 輸入法的開關。
		如果輸入搜索模式且 'imsearch' 的值不是 -1 ，VAL 是 'imsearch'
		的值，否則，VAL 是 'iminsert' 的值。
		如果定義了語言映射:
		- 如果 VAL 為 1 (使用 langmap 映射)，那麼變為 0 (不使用
		langmap 映射)。
		- 如果 VAL 不是 1，那麼會變為 1，這樣 langmap 映射被啟用。
		如果沒有定義語言映射:
		- 如果 VAL 是 2 (使用輸入法)，那麼變為 0 (不使用輸入法)
		- 如果 VAL 是其它值，那麼變為 2，這樣輸入法被啟用。
		這些語言映射通常被用來輸入和鍵盤產生的不同的字符。可以用
		'keymap' 選項安裝一整套這樣的映射。
		命令行輸入時，langmap 映射關閉，因為假定你想輸入命令。即使你用
		CTRL-^ 打開了映射，新的狀態也不會被下一條命令或搜索模式再次使
		用。
		{Vi 無此功能}
		(譯者注: 此處的語言映射或 langmap 映射與 |'langmap'| 選項是不
		同的概念，後者只適用於普通模式。)

						*c_CTRL-]*
CTRL-]		激活縮寫，但不插入任何字符。{Vi 無次功能}

對於 Emacs 風格的命令行編輯請參閱 |emacs-keys|。

<Up> 和 <Down> 鍵使用當前的命令行作為搜索的字符串。前面或後面的命令的起始部分
與該字符串做比較。最先匹配的作為新的命令。若連續重複這兩個鍵，則使用同一字符串
進行再次匹配。例如，尋找前一個替換命令: 輸入 ":s" 然後 <Up>。同樣的效果也可以
用重複輸入一連串 <S-Up> 直至找到你需要的命令為止達成。(注意: Shift+箭頭鍵在某
些終端裡不可用)

							*:his* *:history*
:his[tory]	列出最近執行的命令。
		{Vi 無此功能}
		{僅當編譯時加入 |+cmdline_hist| 特性才可用}

:his[tory] [{name}] [{first}][, [{last}]]
		列出 {name} 歷史記錄的內容，{name} 可以是:
		c[md]	 或 :	命令行的歷史記錄
		s[earch] 或 /	查找字符串的歷史記錄
		e[xpr]	 或 =	表達式寄存器的歷史記錄
		i[nput]	 或 @	輸入行的歷史記錄
		d[ebug]	 或 >	調試命令的歷史記錄
		a[ll]		所有上述記錄
		{Vi 無此功能}

		如果給定了數字 {first} 和 {last}，那麼就會列出指定範圍內的歷史
		記錄條目。這些數字可以是下面的格式:
							*:history-indexing*
		正數表示歷史記錄的絕對索引，也就是 :history 命令列出的第一列數
		字。即使歷史記錄中的其它條目被刪除了，該數字也會保持不變。

		負數表示與某一記錄的相對位置。以最新的一條記錄 (索引號為 -1)
		為基準向後算起。

		例子:
		列出搜索歷史記錄中的第 6 到第 12 條記錄:  >
			:history / 6,12
<
		列出所有歷史記錄中最近的 5 條記錄:  >
			:history all -5,

==============================================================================
2. 命令行補全						*cmdline-completion*

在編輯命令行的時候，有一些命令可以用來補全光標前面的單詞。此功能可用於下述情
況:

- 命令名稱: 在命令行的起始處。
- 標籤: 只在 ":tag" 命令後。
- 文件名: 只在可以接受文件名的命令或可以接受文件名的選項之後。也被稱作文件名補
  全。
- shell 命令名: 在 ":!cmd"、":r !cmd" 和 ":w !cmd" 之後。使用 $PATH。
- 選項: 僅在 ":set" 命令之後。
- 映射: 僅在 ":map" 或與之類似的命令之後。
- 變量和函數名: 僅在 ":if"，":call" 或類似的命令之後。

如果在編譯 Vim 時沒有加入 |+cmdline_compl| 特性，則只有文件名、目錄、和幫助條
目可以補全。幫助條目的匹配數目有上限 (目前是 300 個)，以避免過多匹配造成的延遲
問題。

以下是可以使用的命令:

							*c_CTRL-D*
CTRL-D		列出與光標前面的模式所匹配的名字。
		在列文件名的時候，目錄名會被高亮 (見 'highlight' 選項)。擴展名
		與 'suffixes' 匹配的文件名放到列表的最後。
		要列出匹配標籤所在的文件，可以設置選項 'wildoptions' 為
		"tagfile"。

					*c_CTRL-I* *c_wildchar* *c_<Tab>*
'wildchar' 選項
		用光標前的模式完成匹配。匹配的項目 (如果有多項匹配，則選第一
		項) 會插入並取代模式。(注意: 該功能不能用於宏，因為在大多數情
		況下 <Tab> 或 <Esc> 被用做 'wildchar'，而這些鍵在某些宏裡面有
		特殊的意義。) 如果再次輸入，並且有多項匹配時，則插入下一項匹
		配。在最後一項匹配之後，會再次匹配第一項 (循環使用)。
		該行為可以通過設置 'wildmode' 選項來改變。
							*c_CTRL-N*
CTRL-N		在使用 'wildchar' 之後，如果得到了多項匹配，則選擇下一項匹配。
		否則選擇命令歷史列表中的下一條命令。
<S-Tab>							*c_CTRL-P* *c_<S-Tab>*
CTRL-P		在使用 'wildchar' 之後，如果得到了多項匹配，則選擇前一項匹配。
		否則選擇命令歷史列表中的上一條命令。<S-Tab> 只在 Amiga 的 GUI
		和 MS-DOS 上可以用。
							*c_CTRL-A*
CTRL-A		將所有與模式匹配的項全部插入到光標前面。
							*c_CTRL-L*
CTRL-L		用光標前的模式完成匹配。如果有匹配的項目，則插入並取代當前的模
		式。如果有多個項目匹配，那麼取這些項目中盡可能長的共同部分插
		入以取代模式。若結果比模式短，則匹配不成功。
		如果置位 'incsearch'，用 "/" 或 "?" 錄入搜索模式而顯示當前的匹
		配時，CTRL-L 會從當前匹配的末尾一次加一個字符。如果置位了
		'ignorecase' 和 'smartcase' 而命令行沒有大寫字符，加入的字符會
		轉換為小寫。

選項 'wildchar' 的默認值是 <Tab> (在 Vi 兼容模式裡用的是 CTRL-E; 在以前的版本
裡用的是 <Esc>)。 在匹配模式裡可以使用標準的通配符 '*' 和 '?'。'*' 匹配任意字
符串，'?' 匹配一個字符。

如果你喜歡 tcsh 的自動列表匹配，可以使用這個映射:  >
	:cnoremap X <C-L><C-D>
(X 是命令鍵，<C-L> 是 CTRL-L，<C-D> 是 CTRL-D) 這樣就可以找到最長的匹配並列出
所有匹配的文件。

如果你喜歡 tcsh 的自動列表匹配，你可以使用 'wildmode' 選項來模擬它。例如，這與
autolist=ambiguous 極其類似:  >
	:set wildmode=longest,list
這將在你輸入第一個 'wildchar' 之後，找到最長的匹配，接著列出所有匹配的文件。

							*suffixes*
對於文件名的匹配你可以用 'suffixes' 選項在相似的文件名之間設定優先級。如果有多
個文件匹配，並且 'suffixes' 選項中包含這些文件的擴展名，那麼這些文件會被忽略。
'suffixes' 的默認值是 ".bak,~,.o,.h,.info,.swp,.obj"。其含義是: 以
".bak"，"~"，".o"，".h"，".info"，".swp" 和 ".obj" 結尾的文件名有時被忽略。

空項目，即兩個連續的逗號，匹配不包含 "." 的文件名，因為它們沒有擴展名。可用來
忽略 "prog" 而選擇 "prog.c"。

例如:

   模式:	文件:				匹配:	~
   test*	test.c test.h test.o		test.c
   test*	test.h test.o			test.h and test.o
   test*	test.i test.h test.c		test.i and test.c

無法忽略包括兩個句號的後綴名。

如果有多個文件匹配 (在忽略了與 'suffixes' 匹配的擴展名之後)，則第一個匹配的文
件名被插入。當你按兩次 'wildchar' 時，你可以看到只有一個匹配並且完整的匹配保持
不變。你可以再輸入一次 'wildchar'，CTRL-N，或 CTRL-P 得到另一個匹配。包括所有
的文件，也包括擴展名與 'suffixes' 匹配的文件。

要完全忽略有某些擴展名的文件，請使用 'wildignore' 選項。

要只匹配以輸入文本結尾的文件，附加 "$" 即可。例如，要匹配 ".c" 結尾的文件: >
	:e *.c$
這樣就不會匹配 ".cpp" 結尾的文件。如果沒有 "$" 就會。

一個選項的舊值可以通過在 '=' 後面輸入 'wildchar' 來獲得。例如，在 ":set dir="
後輸入 'wildchar'，就會插入當前 'dir' 的值。對於選項值是文件名的選項，這一行為
優先於文件名匹配。

若你喜歡在 xterm 裡使用 <S-Tab> 代替 CTRL-P，把這條命令放到你的 .cshrc 裡:  >
	xmodmap -e "keysym Tab = Tab Find"
把這條命令放到你的 .vimrc 裡:  >
	:cmap <Esc>[1~ <C-P>

==============================================================================
3. Ex 命令行						*cmdline-lines*

Ex 命令有幾個特別的地方:

							*:quote* *:comment*
如果 '"' 出現在一行的開始，那麼該行被忽略。如果 '"' 出現在命令之後，則使得該行
的剩餘部分被忽略。這可以被用於添加註釋。例如:  >
	:set ai		"set 'autoindent' option
不能給 shell 命令 (":!cmd") 或 ":map" 和其它的一些的命令添加註釋，因為它們把
'"' 視為命令的一部分。解釋具體命令時會提到這一點。

							*:bar* *:\bar*
'|' 可以用來分割命令，所以你可以在一行裡輸入多個命令。如果你想在參數里使用
'|' ，應該在前面加上 '\'。

下面這些命令把 '|' 當作它們的參數，所以後面不能跟別的 Vim 命令:
    :argdo
    :autocmd
    :bufdo
    :command
    :cscope
    :debug
    :folddoopen
    :folddoclosed
    :function
    :global
    :help
    :helpfind
    :lcscope
    :make
    :normal
    :perl
    :perldo
    :promptfind
    :promptrepl
    :pyfile
    :python
    :registers
    :read !
    :scscope
    :sign
    :tcl
    :tcldo
    :tclfile
    :vglobal
    :windo
    :write !
    :[range]!
    沒有參數 "-bar" 的用戶自定義命令 |:command|

注意: 在 ":g" 中 '|' 包含在命令裡 (作為參數)，但 ":s" 卻不是。這的確有點亂
(繼承於 Vi)。

為確保總能執行另一個命令，請使用 ":execute" 命令。
例如 (讀入 "ls" 的輸出，並且跳到第一行): >
	:execute 'r !ls' | '[

有一個例外: 如果 'b' 出現在 'cpoptions' 選項中，那麼在 ":map" 和 ":abbr" 之類
的命令裡需要用 CTRL-V 代替 '\'。你也可以用 "<Bar>" 來代替。參見 |map_bar|。

例如: >
	:!ls | wc		查看兩個命令的輸出
	:r !ls | wc		將相同的輸出插入文本
	:%g/foo/p|>		將所有匹配的行移動一個 shiftwidth
	:%s/foo/bar/|>		將一行移動一個 shiftwidth
	:map q 10^V|		將 "q" 映射為 "10|"
	:map q 10\| map \ l	將 "q" 映射為 "10\" 和將 "\" 映射為 "l"
					(如果 'cpoptions' 選項中包含 'b')

用與 '|' 相同的方法，你也可以用 <NL> 分割多個命令。用 CTRL-V CTRL-J 插入一個
<NL>。Vim 會顯示一個 "^@"。應該說，使用 '|' 是一個更好的方法。但是對於外部命
令，就必須使用 <NL>，因為外部命令會包含 '|'。如果要避免 <NL> 的特殊含義，就必
須在它前面加反斜槓。例如:  >
	:r !date<NL>-join
將當前時間讀入文件，並且與上一行文本銜接。

注意: 如果 '|' 前面的命令產生了錯誤，那麼其後面的命令不會執行。


為了兼容 Vi，下面幾個奇怪的命令 Vim 也支持: >
	:|			打印當前行 (同 ":p")
	:3|			打印第 3 行 (同 ":3p")
	:3			前進至第 3 行

在範圍與命令之間允許有一個冒號。這個冒號被忽略 (與 Vi 兼容)。例如: >
	:1,$:s/pat/string

當字符 '%' 或 '#' 被用在一個需要文件名的地方時，會被擴展為當前的文件名或輪換文
件名 (參見 "編輯文件" 的章節 |:_%| |:_#|)。

在 Amiga 系統上，如果文件名要作為參數使用，那麼文件名裡是允許包含空格符的。通
常末尾的空格符會被忽略，除非使用轉義字符反斜槓或 CTRL-V 使它轉義。注意，
":next" 命令使用空格符分割文件名。所以要在該命令裡使用帶空格符的文件名，就需要
將空格符轉義。例如: >
	:next foo\ bar goes\ to school\
開始編輯 "foo bar"，"goes to" 和 "school " 三個文件。

當你想在命令裡使用特殊字符 '"' 或 '|'，或者想在文件名裡使用 '%' 或 '#'，就需要
在這些字符前加一個反斜槓。在範圍和 ":substitute" 命令裡不需要使用反斜槓。

							*:_!*
在 Ex 命令之後的 '!' (歎號) 使得命令以不同的方式執行。'!' 應該緊跟在命令之後，
中間沒有任何空白字符。如果插入了空白字符，'!' 則被視為該命令的參數，其含義是不
同的。例如: >
	:w! name	將當前緩衝區內容寫入文件 "name"。若該文件存在，則覆蓋
			之。
	:w !name	將當前緩衝區內容作為標準輸入發送給 "name" 命令。

==============================================================================
4. Ex 命令行的範圍		*cmdline-ranges* *[range]* *E16*

有些 Ex 命令前面可以接受一個範圍限定，這被稱作 [range] (範圍)。它由一個或多個
被 ',' 或 ';' 分割的行限定符組成。

一些基本的內容在用戶手冊的 |10.3| 裡解釋過。

						*:,* *:;*
當範圍被 ';' 分割時，在解釋下一個行限定符之前，光標的位置會被設置為前一個行限
定符確定的行值。這種情況不會發生在 ',' 上。例如: >
   4,/this line/
<	從第 4 行到匹配當前光標後的一個 "this line" 為止的範圍。 >
   5;/that line/
<	從第 5 行到匹配第 5 行之後的一個 "that line" 為止的範圍。

對大多數命令而言，默認的行限定符就是光標的位置，但是 ":write" 和 ":global" 命
令的默認值是整個文件 (1,$)。

若行限定符的個數多於命令需要的數量，則第一個 (或前幾個) 限定符被忽略。

行號可以用下列符號限定:				*:range* *E14* *{address}*
	{number}	行號
	.		當前行					  *:.*
	$		文件的最後一行				  *:$*
	%		相當於 1,$ (整個文件)			  *:%*
	't		標記 t 的位置 (小寫)			  *:'*
	'T		標記 T 的位置 (大寫); 如果標記存在於另一個文件中，則不
			能在範圍裡應用。
	/{pattern}[/]	下一個 匹配 {pattern} 的行		  *:/*
	?{pattern}[?]	前一個 匹配 {pattern} 的行		  *:?*
	\/		下一個 與前次搜索模式匹配的行
	\?		前一個 與前次搜索模式匹配的行
	\&		下一個 與前次替代模式匹配的行

這些符號後面可以跟 (一個或多個) '+' 或 '-' 和一個可選的數字。該數字會與前面的
行號相加或相減。若該數字省略，則認為是 1。

在 {pattern} 之後需要由 "/" 或 "?" 來分隔匹配模式與其之後的內容。

"/" 和 "?" 前面可能有另一個地址。查找就從那裡開始。和使用分號的方式不同之處
是: 光標不會被移動。例如: >
	/pat1//pat2/	從包含 "pat1" 的行開始，向後尋找直至找到包含 "pat2" 的
			行為止，不移動光標位置。
	7;/pat2/	從第 7 行開始，向後尋找直至找到包含 "pat2" 的行為止。
			光標留在第 7 行。

{number} 必須在 0 和文件的總行數之間。當使用 0 (零) 的時候，大多數命令會把它解
釋成 1 。把它用作計數器的命令會將它解釋為零 (|:tag|，|:pop| 等)。有些命令會把
零解釋為 "在第一行之前" (|:read|，搜索模式等)。

例如: >
	.+3		光標下面三行
	/that/+1	下一個包含 "that" 的行的下一行
	.,$		從當前行直至文件末尾
	0;/that		第一個包含 "that" 的行，也能匹配第一行
	1;/that		第一行之後 (從第二行開始) 包含 "that" 的那一行

有些命令後面可以跟一個數量。這個數量被用作從上一個行限定符 (默認值是當前光標所
在的行) 開始計算的行數。可以使用範圍但是不使用文件名作為參數的命令可以接受這種
數量參數 (因為文件名也可能是一個數字)。

例如: >
	:s/x/X/g 5	用 'X' 替換當前行和下面四行裡的 'x'。
	:23d 4		刪除 23，24，25 和 26 行。


折疊和範圍

如果激活了折疊功能，行號會被取整以包括整個折疊。見 |fold-behavior|。


反向範圍						*E493*

在範圍裡，小的數字應該出現在前面。如果不是這樣，Vim 會詢問你是否交換。
	Backwards range given, OK to swap ~
但全局命令 ":g" 裡不會這麼做。

在命令前用 ":silent" 可以避免此問題，這時範圍總是進行交換。


計數和範圍						*N:*

如果在進入 ":" 之前輸入了計數前綴，這種情況會被解釋成:
		:.,.+(count - 1)
簡單來說就是: 包括當前行，向後共計 'count' 行。例如，刪除三行: >
		3:d<CR>		被翻譯成: .,.+2d<CR>
<

可視模式和範圍						*v_:*

{Visual}:	將可視模式中選擇的區域用作命令行模式的範圍。":'<,'>" 被用來表
		示這種範圍。這樣就可以在不同的選擇區域上，從命令歷史列表裡選擇
		相似的命令來重複執行操作。

==============================================================================
5. Ex 命令行的標誌位					*ex-flags*

部分 Ex 命令支持以下標誌位。它們顯示光標在執行完命令之後所在的行:

	l	像 |:list| 那樣輸出
	#	加上行號
	p	像 |:print| 那樣輸出

可以聯合使用這些標誌位，這樣 "l#" 表示使用行號並且使用 |:list|風格輸出。

==============================================================================
6. Ex 裡的特殊字符					*cmdline-special*

注意: 這些是要執行的 Ex 命令行中的特殊字符。如果你想要在錄入時插入特殊的內容，
可以使用 CTRL-R 命令。例如，"%" 表示當前文件名，而 CTRL-R % 則立即插入當前文件
名。見 |c_CTRL-R|。

備註: 在 Vim 腳本中要避免特殊字符，可用 |fnameescape()|。


在 Ex 命令中，下列字符在可以使用文件名的地方有特殊的意義。它們同樣可以用到表達
式函數 expand() 中 |expand()|。
	%	被當前文件名取代。				*:_%* *c_%*
	#	被輪換文件名取代。				*:_#* *c_#*
	#n	(n 是一個數字) 被第 n 個緩衝區的文件名取代。    *:_#0* *:_#n*
		"#0" 與 "#" 相同。                                     *c_#n*
	##	被參數列表裡的所有文件名 (使用空格符分隔) 取代。 *:_##* *c_##*
		文件名中的空格符前面會加一個反斜槓。 
	#<n	(n 是一個正數) 被第 n 個舊文件名取代。		*:_#<* *c_#<*
		要得到這個數值，見 |:oldfiles| 或 |v:oldfiles|。	*E809*
		{僅當編譯時加入 |+eval| 和 |+viminfo| 特性才可用}

注意: 除了 "#<n" 以外，它們只給出輸入時使用的文件名。如果需要絕對路徑 (當從另
一個目錄使用文件名的時候)，你需要加 ":p"。見 |filename-modifiers|。

"#<n" 項返回絕對路徑，但在主目錄下的文件名會以 "~/" 開始。

注意: 空格符前面會插入反斜槓，以便 Vim 命令會正確地解釋文件名。但是 shell 命令
不會如此。為此，你可以使用引號 (但對包含引號和通配符的文件名會有問題): >
	:!ls "%"
	:r !spell "%"

要避免 '%' 和 '#' 的特殊含義，可以在它前面插入一個反斜槓。細節: 只要有反斜槓在
這些字符前面，它們就不具備特殊含義，不管有多少個反斜槓。
	你輸入:			結果	~
	   #			輪換文件名
	   \#			#
	   \\#			\#

			       *:<cword>* *:<cWORD>* *:<cfile>* *<cfile>*
			       *:<sfile>* *<sfile>* *:<afile>* *<afile>*
			       *:<abuf>* *<abuf>* *:<amatch>* *<amatch>*
			       *E495* *E496* *E497* *E498* *E499* *E500*
注意: 下面這些不是特殊鍵，需要逐個字符輸入！
	<cword>    被當前光標下的單詞代替 (類似於 |star|)
	<cWORD>    被當前光標下的字串代替 (見 |WORD|)
	<cfile>    被當前光標下的路徑名代替 (類似於 |gf| 用的方法)
	<afile>    在執行自動命令時，被用來讀或寫的文件的文件名取代。
	<abuf>     在執行自動命令時，被當前有效的緩衝區序號取代 (對於
		   ":r file" 和 ":so file" 來說是當前的緩衝區，因為被讀取/執行
		   的文件不在緩衝區裡)。
	<amatch>   在執行自動命令時，被激發自動命令的實際匹配代替。只有在文件
		   名不用於匹配 (對於 FileType、Syntax 和 SpellFileMissing 事
		   件) 時，才與 <afile> 不同。
	<sfile>    執行 ":source" 命令時，替換為正在被 "source" 執行的文件名；
		   執行函數時，替換為 "function {function-name}"；其中，函數嵌
		   套調用表示為:
		   "function {function-name1}..{function-name2}"。注意，如果
		   <sfile> 用在函數里，那麼文件名修飾符 (filename-modifiers)
		   就沒用了。

							 *filename-modifiers*
	 *:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs*
	        *%:8* *%:p* *%:.* *%:~* *%:h* *%:t* *%:r* *%:e* *%:s* *%:gs*
可以在 "%"，"#"，"#n"，"<cfile>"，"<sfile>"，"<afile>" 或 "<abuf>" 之後使用文
件名修飾符。這些修飾符也可以和 |fnamemodify()| 函數一起用。
如果 Vim 編譯的時候沒有加入 |+modify_fname| 特性，則不可用。

此類修飾符必須按如下順序給出:
	:p	給出文件名的全路徑。必須是第一個修飾符。也會將 "~/" (Unix 和
		VMS 系統裡的 "~user/") 變成指向用戶主目錄的路徑。若被修飾的名
		字是一個目錄，則在後面加一個路徑分隔符。如果文件名不存在，或
		其絕對路徑不存在，那麼結果不可預料。
	:8	將路徑轉換為 8.3 短格式 (目前僅適用於 win32)。轉換的結果盡可能
		與現存路徑一致。
	:~	如果可能，路徑名縮減為基於主目錄的相對路徑。若文件不在主目錄
		下，則文件名不會被改變。
	:.	如果可能，路徑名縮減為基於當前目錄的相對路徑。若文件不在當前目
		錄下，則文件名不會被改變。
		要想盡可能縮減，可使用 ":~:." 。
	:h	文件名的頭部 (除去文件名的最後一部分以及路徑分隔符)。
		不能與 :e，:r 或 :t 一起使用。
		可以被重複使用來刪除後面的多個部分。
		如果文件名以一個路徑分隔符結尾，僅刪除該分隔符。這樣一個目錄
		名的 ":p:h" 結果是目錄名本身 (沒有後面的斜槓)。
		如果文件名是一個絕對路徑 (Unix 上以 "/" 開始；MS-DOS，WIN32，
		OS/2 以 "x:\" 開始；Amiga 以 "drive:" 開始)，這些部分不會被刪
		除。如果沒有文件頭 (路徑是相對於當前目錄的)，則結果為空。
	:t	文件名的尾部 (文件名的最後一部分)。必須在 :r 或 :e 之前。
	:r	文件名的根部 (除去最後的擴展名)。如果只有擴展名 (文件名以 '.' 
		開始，例如，".vimrc")，則不會被刪除。可以重複使用，以刪除多個
		擴展名 (最後一個先被刪除)。
	:e	擴展名。只有單獨使用時才有意義。
		如果沒有擴展名，那結果為空。
		如果文件名只是一個擴展名 (以 '.' 開始的文件名)，則結果為空。
		可以重複使用來包含更多的擴展名。如果沒有足夠的擴展名 (但是至少
		有一個)，那麼就盡可能多的包含。
	:s?pat?sub?
		用 "sub" 代替第一次出現的 "pat"。這類似於 |:s| 命令。"pat" 是
		一個正則表達式。
		可以用其它字符代替 '?'，只要該字符不出現在 "pat" 或 "sub" 裡。
		在此之後，上述的修飾符可以再次使用。例如 ":p"，是替換之後的完
		整路徑。
	:gs?pat?sub?
		用 "sub" 替換所有的 "pat"。其餘和 ":s" 一樣。

例如，如果文件名是 "src/version.c"，當前目錄是 "/home/mool/vim": >
  :p			/home/mool/vim/src/version.c
  :p:.				       src/version.c
  :p:~				 ~/vim/src/version.c
  :h				       src
  :p:h			/home/mool/vim/src
  :p:h:h		/home/mool/vim
  :t					   version.c
  :p:t					   version.c
  :r				       src/version
  :p:r			/home/mool/vim/src/version
  :t:r					   version
  :e						   c
  :s?version?main?		       src/main.c
  :s?version?main?:p	/home/mool/vim/src/main.c
  :p:gs?/?\\?		\home\mool\vim\src\version.c

又例，如果文件名是 "src/version.c.gz": >
  :p			/home/mool/vim/src/version.c.gz
  :e						     gz
  :e:e						   c.gz
  :e:e:e					   c.gz
  :e:e:r					   c
  :r				       src/version.c
  :r:e						   c
  :r:r				       src/version
  :r:r:r			       src/version
<
					*extension-removal* *:_%<*
如果 "<" 跟在 "%"，"#"，"#n" 或 "CTRL-V p" 後面，那麼文件的擴展名 ('.' 之後的
內容，包括 '.') 會被刪除。包含這樣的功能是為了與 3.0 版本兼容，現在推薦使用
":r" 的形式。例如: >

	%		當前文件名
	%<		當前主文件名 (無擴展名)
	#		當前窗口的輪換文件名
	#<		同上，但無擴展名
	#31		序號為 31 的輪換文件名
	#31<		同上，但無擴展名
	<cword>		光標下的單詞 
	<cWORD>		光標下的字串 (見 |WORD|)
	<cfile>		光標下的路徑名
	<cfile><	同上，但無擴展名
<
注意: 在需要文件名的地方，就會完成文件名的通配符擴展。在 Unix 上，除非可以在內
部實現 (為了運行速度考慮)，此功能會通過 shell 來完成。
也可以使用反引號，比如在 >
	:n `echo *.c`
(在 |restricted-mode| 裡反引號擴展不可用)

但是擴展僅在 '%'，'#' 等字符擴展之前就出現通配符的時候發生。這可以避免對文件名
中的通配符字符進行擴展。如果你想擴展 <cfile> 的結果，可以給它加一個通配字符。
例如: (輪換文件名是 "?readme?")
	命令		擴展為  ~
	:e #		:e ?readme?
	:e `ls #`	:e {匹配 "?readme?" 的文件}
	:e #.*		:e {匹配 "?readme?.*" 的文件}
	:cd <cfile>	:cd {光標下的文件}
	:cd <cfile>*	:cd {光標下的文件名加上 "*" 然後進行擴展}

當被擴展的參數包含一個 "!" 並且在 shell 命令裡 (":!cmd"，":r !cmd" 或
":w !cmd") 使用時，"!" 被反斜槓轉義，以免擴展為前次使用的命令。如果 'shell' 選
項包含 "sh"，會執行兩次轉義，以避免 shell 擴展 "!"。

							*filename-backslash*
對於文件系統使用反斜槓作為目錄分隔符的操作系統 (MS-DOS，Windows，OS/2) 來說，
確認反斜槓是否為轉義字符就有點兒困難了。一般來說: 如果反斜槓後面跟一個普通的
字符，那麼就沒有特殊意義。因此 "\file\foo" 是合法文件名，沒有必要輸入兩次反斜
槓。

一個例外是 '$' 符號。在文件名裡它是一個合法的字符。但是為了避免像 "$home" 這
樣的文件名被當作環境變量解釋，則需要在前面加一個反斜槓。因此你需要用 "/\$home"
表示根目錄下的 "$home" 文件。幾個例子:

	文件名		被解釋為	~
	$home		擴展為環境變量 $home 的值
	\$home		當前目錄裡的 "$home" 文件
	/\$home		根目錄下的 "$home" 文件
	\\$home		名為 "\\" 加上擴展後的 $home 的文件

==============================================================================
7. 命令行窗口					*cmdline-window* *cmdwin*
							*command-line-window*
在命令行窗口裡，可以像編輯文本一樣來編輯命令。這是一類特殊的窗口，你不能把它當
作普通窗口使用。
{僅當編譯時加入 |+cmdline_hist| 和 |+vertsplit| 特性才可用}


開 啟						*c_CTRL-F* *q:* *q/* *q?*

有兩種方法可以打開命令行窗口:
1. 在命令行模式裡，用 'cedit' 選項所指定的鍵。
   在沒有置位 'compatible' 的情況下，默認值是 CTRL-F 。
2. 在普通模式裡，用 "q:"，"q/" 或 "q?" 命令。
   它們分別開始編輯 Ex 命令 ("q:") 或搜索字符串 ("q/" 或 "q?")。 注意，處於記
   錄狀態時不能使用 ("q" 會結束記錄)。

窗口裡的內容是命令行的歷史記錄。最後一行是最近輸入的命令。左面一列字符表示命令
行的類型。見: |cmdwin-char|。

如果沒有置位 'insertmode' 選項，Vim 在打開之後會進入普通模式。

窗口的高度可以通過 'cmdwinheight' 選項設定 (如果沒有足夠的空間，窗口會縮小一
點)。窗口永遠都是以最大寬度出現，並且被放在命令行的上面 (緊靠命令行)。


編 輯

現在你可以在窗口裡移動或者編輯裡面的文本了。可以在普通模式和插入模式中進行這些
操作。

可以用 ":"，"/" 和其他命令使用命令行，但卻不能再打開另一個命令行窗口。這裡不允
許嵌套。
							*E11*
命令行窗口不是普通的窗口。你不能移動到別的窗口或編輯別的緩衝區。在命令行窗口
裡，所有此類操作都被禁止。當然你_可以_執行在命令行窗口裡輸入的任何命令。關閉窗
口時，其它的文本編輯都被捨棄。


關 閉							*E199*

有很多方法可以退出命令行窗口:

<CR>		執行光標下的命令。插入和普通模式裡都可以。
CTRL-C		繼續回到命令行模式。光標下的命令被用做命令行的命令。插入和普通
		模式裡都可以。也可以使用 ":close" 命令。不會重畫窗口，這樣命令
		行窗口仍然可見。
:quit		放棄命令行，回到普通模式。也可以使用 ":exit"，":xit" 和
		CTRL-\ CTRL-N 命令。
:qall		除非改動了某些緩衝區，否則退出 Vim。
:qall!		退出 Vim，放棄所做的改動。

一旦命令行窗口關閉，舊的窗口就會立刻恢復原先的大小。待執行的命令會作用於調用該
命令行窗口或緩衝區，就好像沒有沒有用過命令行窗口一樣 (除了會有一次額外的屏幕刷
新以外)。命令行窗口用過的緩衝區會被刪除。對其中的命令所做的改動 (如果沒有用
<CR> 執行過) 會全部丟失。

如果你想執行光標所在的命令後再次打開命令行窗口，可用以下映射: >

	:autocmd CmdwinEnter * map <buffer> <F5> <CR>q:


其 它

命令行窗口不能用在:
- 已經存在一個命令行窗口的時候 (不能嵌套)
- 輸入密鑰或使用 inputsecret() 函數的時候
- Vim 編譯時沒有加入 |+vertsplit| 特性的時候

打開命令行窗口的時候，會自動設置下面的選項:
'filetype'	當編輯 Ex 命令時，會設置為 "vim"; 如果打開高亮的話，這樣就會啟
		用對 Vim 腳本的語法高亮。
'rightleft'	關
'modifiable'	開
'buftype'	"nofile"
'swapfile'	關

將命令窗口緩衝區的內容寫到文件是允許的。這也是一個保存命令歷史記錄以便日後取回
的好辦法。

如果 'wildchar' 選項設置為 <Tab>，並且命令行窗口用於 Ex 命令，那麼會在命令行窗
口裡加入兩個映射用於命令補全，如下: >
	:imap <buffer> <Tab> <C-X><C-V>
	:nmap <buffer> <Tab> a<C-X><C-V>
注意，在普通模式裡敲 <Tab> 鍵會在下一個字符上補全。這樣的話，就可以在行尾進行
補全了。
如果你不想要這些映射，可用下面的命令將它們禁用: >
	au CmdwinEnter [:>] iunmap <Tab>
	au CmdwinEnter [:>] nunmap <Tab>
你可以把這幾行命令放到你的 vimrc 文件中。

在命令行窗口裡，你不能用鼠標把光標放到另一個窗口裡，或者拽動其它窗口的狀態欄。
你可以拽動命令行窗口自己的狀態欄以及命令行窗口之上的狀態欄來改變命令行窗口的大
小，但對其它窗口無效。


自 動 命 令

使用兩種自動命令事件: |CmdwinEnter| 和 |CmdwinLeave|。因為此窗口的類型特殊，
WinEnter，WinLeave，BufEnter 和 BufLeave 事件不會被觸發。你可以使用這些 Cmdwin
事件對命令行窗口進行特殊的設置。小心不要引起副作用！
例如: >
	:au CmdwinEnter :  let b:cpt_save = &cpt | set cpt=.
	:au CmdwinLeave :  let &cpt = b:cpt_save
設置 'complete' 選項，以便在當前窗口用 |i_CTRL-N| 進行匹配。
另一個例子: >
	:au CmdwinEnter [/?]  startinsert
將使 Vim 在打開命令行窗口時切換到插入模式。

						*cmdwin-char*
模式使用的下列字符用於指示命令行的種類:
	:	普通的 Ex 命令
	>	調試模式的命令 |debug-mode|
	/	正向查找字符串
	?	反向查找字符串
	=	"= 表達式 |expr-register|
	@	|input()| 字符串
	-	|:insert| 或 |:append| 的文本

 vim:tw=78:ts=8:ft=help:norl:
