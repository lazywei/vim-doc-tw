*fold.txt*      For Vim version 7.3.  最後修改: 2010年5月


		  VIM REFERENCE MANUAL    by Bram Moolenaar
		      譯者: Zimin<cranecai@users.sf.net>，tocer


折疊						*Folding* *folding* *folds*

你可以在用戶手冊的第 28 章找到有關折疊的序論。|usr_28.txt|

1. 折疊方法		|fold-methods|
2. 折疊命令		|fold-commands|
3. 折疊選項		|fold-options|
4. 折疊行為		|fold-behavior|

{Vi 沒有折疊}
{僅當編譯時加入 |+folding| 特性才有效}

==============================================================================
1. 折疊方法					*fold-methods*

可用選項 'foldmethod' 來設定折疊方法。

設置選項 'foldmethod' 為非 "manual" 的其它值時，所有的折疊都會被刪除並且創建新
的。如果設置成 "manual"，將不去除已有的折疊。可以利用這一點來先自動定義折疊，
然後手工調整。

有 6 種方法來選定折疊：
	manual		手工定義折疊
	indent		更多的縮進表示更高級別的折疊
	expr		用表達式來定義折疊
	syntax		用語法高亮來定義折疊
	diff		對沒有更改的文本進行折疊
	marker		對文中的標誌折疊


手 工						*fold-manual*

使用命令來手工定義要折疊的範圍。分析文本並發現折疊的腳本也可用這種方法。

折疊的級別僅由嵌套次數來定義。要對一定行數的折疊增加級別，可以對相同的行反覆定
義折疊。

當你退出文件編輯時，手工折疊會被遺棄。要保存折疊，使用 |:mkview| 命令。之後要
恢復可以使用 |:loadview|。


縮 進						*fold-indent*

由縮進行自動定義折疊。

折疊級別由行的縮進除以 'shiftwidth' (向下取整) 計算而得。連續的，有同樣或更高
的折疊級別的行，形成一個折疊。在其中，有更高折疊級別的行形成嵌套的折疊。

嵌套的級別數受 'foldnestmax' 選項限制。

某些行會被忽略並得到上一行或下一行的折疊級別 (取較小值)。符合條件的這樣的行要
麼是空行，要麼以 'foldignore' 選項裡包含的字符開始。在查找 'foldignore' 裡包含
的字符時，空白字符會被忽略。對於 C，該選項使用 "#" 來略過要預處理的那些行。

當你想用另一種方式來略過行時，使用 'expr' 方法。在 'foldexpr' 中 |indent()| 函
數被用來取得一行的縮進。


表 達 式						*fold-expr*

就像用 "indent" 方式一樣，表達式方式的折疊也是由折疊級別自動定義的。對每行，通
過計算選項 'foldexpr' 的值來並得到它的折疊級別。如：
對所有以製表符開始的連續的幾行，創建折疊： >
	:set foldexpr=getline(v:lnum)[0]==\"\\t\"
調用一函數來計算折疊級別：  >
	:set foldexpr=MyFoldLevel(v:lnum)
用空白行分開的段落構成折疊：  >
	:set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
同上：  >
	:set foldexpr=getline(v:lnum-1)=~'^\\s*$'&&getline(v:lnum)=~'\\S'?'>1':1
備註: ":set" 要特殊處理的字符必須用反斜槓轉義。(空格，反斜槓，雙引號等等，參考
|option-backslash|)

這些是表達式的計算條件：
- 當前緩衝區和窗口值依所在行而定
- 變量 "v:lnum" 被定為該行行號
- 計算結果將用以下方式解釋：
  值			代表 ~
  0			這行不折疊
  1, 2, ..		這行的折疊級別 1，2 等
  -1			折疊級別沒有定義，使用這行之前或之後一行的級別值，取其
  			中較小的一個。
  "="			使用上一行的折疊級別。
  "a1", "a2", ..	上一行的折疊級別加 1，2，..
  "s1", "s2", ..	上一行的折疊級別減 1，2，..
  "<1", "<2", ..	此折疊級別在本行結束
  ">1", ">2", ..	此折疊級別在本行開始

不需要用 ">1" ("<1") 標誌折疊的開始 (結束)。當這行折疊級別高於 (低於) 上一行的
級別時，折疊將開始 (結束)。

表達式必須沒有副作用。在緩衝區裡的文字，光標位置，查找模式，選項等等，不能被改
動。如果你非常小心，改動並恢復這些設置還是可以的。

表達式中有錯誤或者計算結果不能識別時，Vim 不會產生錯誤消息，而是將折疊級別設為
0。所以當需要調試時，可將 'debug' 選項設為 "msg"，錯誤消息就可以被見到了。

備註: 由於每一行關於表達式的值都要被計算，這一折疊方式可能會很慢！

最好避免使用 "=" ， "a" 和 "s" 作為返回值，因為 Vim 不得不經常向後回溯以得到折
疊級別。這會降低執行速度。

|foldlevel()| 計算相對於上一折疊級別的折疊級別。但要注意，如果該級別未知，
foidlevel() 返回 -1。它返回的級別對應於該行開始的位置，儘管折疊本身可能在該行
結束。

折疊可能會沒有及時更新。用 |zx| 或者 |zX| 可以強制折疊更新。


語 法						*fold-syntax*

由帶有 "fold" 參數的語法項來定義折疊。|:syn-fold|

折疊級別由嵌套的折疊層數來定義。嵌套數由 'foldnestmax' 限定。

要小心指定合適的語法同步方式。如果這裡有問題，折疊和顯示高亮可能會不一致。尤其
在使用可能跨越多行的模式時更要小心。如果有疑問，不妨嘗試如下的強制同步:  >
	:syn sync fromstart
<

比 較						*fold-diff*

對沒有改動的文本或靠近改動的文本自動定義折疊。

這個方法僅適用於當前窗口設定 'diff' 選項來顯示不同之處時才有效。不然，整個緩衝
區就是一個大的折疊。

選項 'diffopt' 可以指定上下文。即折疊和不被折疊包括的改變之間相距的行數。比
如，設定上下文為 8： >
	:set diffopt=filler,context:8
默認值是 6。

當設定了 'scrollbind' 選項時，Vim 會試圖在其它比較窗口中打開相同的折疊，這樣這
些窗口就會顯示同一處文本。


標 志						*fold-marker*

在文本中可以加入標誌來指明折疊開始和結束的地方。這可以讓你精確的定義折疊。這也
讓你可以放心地刪除和複製折疊而不用擔心錯誤包括了某些行。選項 'foldtext' 通常設
置為使折疊行顯示折疊標誌之前的文本。這樣做可以為折疊命名。

標誌可以包含級別數，也可以使用匹配對。包含級別數較簡單，你無須添加結束標誌，並
可以避免標誌不配對的問題。如： >
	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}

折疊開始於 "{{{" 標誌。接下去的數字決定了折疊級別。產生的效果依當前折疊級別和
該折疊標誌給定的級別的大小關係而定：
1. 如果遇到級別相同的標誌，上一個折疊結束，另一個有同樣級別的折疊開始。
2. 如果遇到級別更高的標誌，開始一個嵌套的折疊。
3. 如果遇到級別更低的標誌，所有大於或等於當前級別的折疊結束，且指定級別的折疊
   開始。

數字指定了折疊級別。不能使用 0 (忽略級別為 0 的標誌)。你可以使用 "}}}" 帶上一
個數字來表示這個級別的折疊結束。此行以下的折疊級別將比當前級別小一。備註: Vim
不會回溯匹配的標誌 (這將耗費太多的時間)。如： >

	{{{1
	fold level here is 1
	{{{3
	fold level here is 3
	}}}3
	fold level here is 2

你也可以用一對匹配標誌 "{{{" 和 "}}}" 來定義折疊。每個 "{{{" 使折疊級別加 1，
"}}}" 使折疊級別減 1。注意一定要使標誌匹配！如： >

	{{{
	fold level here is 1
	{{{
	fold level here is 2
	}}}
	fold level here is 1

帶數字的標誌和沒有帶數字的標誌可以混合使用。對於一個大折疊我們可以使用帶數字的
標誌，在函數的內部我們可以使用不帶數字的。如對文件中的 "結構定義"，"局部變量"
和 "函數原型" 各個部分，使用級別 1 的折疊。對定義和函數體使用級別 2 的標誌。而
在函數內部可以使用不帶數字的標誌。當你在一函數中作更改以分割折疊時，你無須記著
標誌在哪裡。

選項 'foldmarker' 可設定所用的標誌。建議保留默認值 "{{{,}}}"。這樣在 Vim 用戶
間交換文件時就不會出問題。有時為了要編輯的文件必須改變該選項 (如，文件包含了來
自另一個編輯器的折疊標誌，或對於當前文件的語法而言，折疊標誌會產生歧義等)。

							*fold-create-marker*
"zf" 可通過標誌來創建一個折疊。 Vim 將為你插入開始和結束標誌。這些標誌由
'foldmarker' 指定。標誌會被添加在行末。如果 'commentstring' 不為空，使用之。
以下情況下可能無法正常工作：
- 此行已有一個帶級別的標誌了。Vim 無法判斷該如何做。
- 在附近的折疊裡使用了帶級別的標誌，使添加無法進行。
- 這行包含在一註釋中，且 'commentstring' 不為空，且嵌套的註釋是非法的。如，在
  C 的註釋中加入 /* {{{ */ ，這將使現有的註釋中斷。你可以在註釋之前或之後添加
  標誌，或手工添加。
總的來說，當你已有帶級別的標誌時，再讓 Vim 為你創建標誌不是個好主意。

							*fold-delete-marker*
"zd" 可用來刪除一個用標誌定義的折疊。 Vim 將為你刪除標誌。Vim 將在折疊的開始和
結束處根據 'foldmarker' 查找開始和結束標誌。如果標誌周圍文字和 'commentstring'
匹配，這些文字也會被刪除。
但在以下情況下無法正確執行：
- 當一行包含有多於一個的標誌且其中一個指定了級別。Vim 不考慮結果是不是真能刪除
  折疊，而僅刪除第一個標誌。
- 當這個標誌帶有級別且同時被用來開始或結束幾個折疊時。

==============================================================================
2. 折疊命令					*fold-commands* *E490*

所有的折疊命令用 "z" 開頭。提示：如果你從側面看 "z" 像一張疊起來的紙。


創 建 和 刪 除 折 疊 ~
							*zf* *E350*
zf{motion}  或
{Visual}zf	創建折疊操作符。
		僅當 'foldmethod' 設為 "manual" 或 "marker" 時有效。
		用 "manual" 方式，新建的折疊會被關閉。同時 'foldenable' 會被設
		定。
		參考 |fold-create-marker|。

							*zF*
zF		對 [count] 行創建折疊。其餘同 "zf" 。

:{range}fo[ld]						*:fold* *:fo*
		對 {range} 內的行創建折疊。其餘同 "zf" 。

							*zd* *E351*
zd		刪除 (delete) 在光標下的折疊。當光標在被折疊的行上，該折疊被刪
		除。嵌套的折疊上移一級。在可視模式下所選區域 (部分) 涵蓋的折疊
		都被刪除。注意：這種一次刪除多個折疊的簡單方法不可撤銷。
		僅當 'foldmethod' 設為 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。

							*zD*
zD		循環刪除 (Delete) 光標下的折疊。在可視模式下所選區域 (部分) 涵
		蓋的折疊和嵌套的折疊都被刪除。
		僅當 'foldmethod' 設為 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。

							*zE* *E352*
zE		除去 (Eliminate) 窗口裡所有的折疊。
		僅當 'foldmethod' 設為 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。


打 開 和 關 閉 折 疊 ~

一個小於 'foldminlines' 的折疊的顯示就像它被打開時一樣。所以，以下的命令對於小
折疊所起的作用與描述不同。

							*zo*
zo		打開 (open) 在光標下的折疊。當給定計數時，相應深度的折疊被打
		開。在可視模式下，所選區域的所有行的折疊被打開一級。

							*zO*
zO		循環打開 (Open) 光標下的折疊。不在光標下的折疊不改變。
		在可視模式下，打開所有的在選中區域裡的折疊，包括被部分選中的。

							*zc*
zc		關閉 (close) 在光標下的折疊。當給定計數時，相應深度的折疊被關
		閉。在可視模式下，所選區域裡的所有行的折疊被關閉一級。
		'foldenable' 被設定。

							*zC*
zC		循環關閉 (Close) 在光標下的所有折疊。不在光標下的折疊不改變。
		在可視模式下，關閉所有的在選中區域裡的折疊，包括被部分選中的。
		'foldenable' 被設定。

							*za*
za		當光標位於一關閉的折疊上時，打開之。當折疊嵌套時，你可能需要用
		"za" 數次。當給定計數時，打開相應數量的被關閉的折疊。
		當光標位於一打開的折疊上時，關閉之且設定 'foldenable' 。這僅關
		閉一級折疊，因為再次使用 "za" 將再次打開折疊。當給定計數時，關
		閉相應數量的折疊 (這不同於重複 "za" 許多次)。

							*zA*
zA		當處在一關閉的折疊上時，循環地打開折疊。
		當處在一打開的折疊上時，循環地關閉折疊且設定 'foldenable'。

							*zv*
zv		查看 (view) 光標所在的行：僅打開足夠的折疊使光標所在的行不被折
		疊。

							*zx*
zx		更新折疊：撤消被手工打開和關閉的折疊：再次應用 'foldlevel'。
		然後使用 "zv" ：查看光標所在行。
		同時強制重新計算折疊。使用 "foldexpr" 並且緩衝區發生改變但折疊
		不能正確地更新時，這會有用。

							*zX*
zX		手工恢復被打開和關閉的折疊：再次應用 'foldlevel'。
		也同時強制重新計算折疊，同 |zx|。

							*zm*
zm		折起更多 (more)：'foldlevel' 減 1。如果 'foldlevel' 已經為 0，
		則不會被減小。
		'foldenable' 被設定。

							*zM*
zM		關閉所有折疊：'foldlevel' 設為 0。
		'foldenable' 被設定。

							*zr*
zr		減少 (reduce) 折疊：'foldlevel' 加 1。

							*zR*
zR		打開所有的折疊。'foldlevel' 設為最高級別。

							*:foldo* *:foldopen*
:{range}foldo[pen][!]
		在 {range} 內打開折疊。當加上 [!] 時，所有的折疊都被打開。對查
		看在 {range} 內的所有文本很有用。沒有 [!] 時，打開一級折疊。

							*:foldc* *:foldclose*
:{range}foldc[lose][!]
		在 {range} 內關閉折疊。當加上 [!] 時，所有的折疊都被關閉。對隱
		藏在 {range} 內的所有文本很有用。沒有 [!] 時，關閉一級折疊。

							*zn*
zn		不折疊 (none)：復位 'foldenable'。所有的折疊被打開。

							*zN*
zN		正常折疊 (normal)：設定 'foldenable'。所有的折疊都展現它們之前
		的樣子。

							*zi*
zi		翻轉 'foldenable' 的值。


在 折 疊 間 移 動 ~
							*[z*
[z		到當前打開的折疊的開始。如果已在開始處，移到包含這個折疊的折疊
		開始處。如果沒有包含它的折疊，命令執行失敗。
		當給定計數，重複此命令 [count] 次。

							*]z*
]z		到當前打開的折疊的結束。如果已在結束處，移到包含這個折疊的折疊
		結束處。如果沒有包含它的折疊，命令執行失敗。
		當給定計數，重複此命令 [count] 次。

							*zj*
zj		向下移動。到達下一個折疊的開始處。關閉的折疊也被計入。
		當給定計數，重複此命令 [count] 次。
		此命令可在 |operator| 後使用。

							*zk*
zk		向上移動到前一折疊的結束處。關閉的折疊也被計入。
		當給定計數，重複此命令 [count] 次。
		此命令可在 |operator| 後使用。


對 折 疊 執 行 命 令 ~

:[range]foldd[oopen] {cmd}			*:foldd* *:folddoopen*
		對所有不在關閉的折疊中的行執行 {cmd}。
		給定 [range] 時，僅對範圍內那些行起作用。
		每次命令被執行時，光標會被定位在要被操作的行上。
		就如 ":global" 命令：首先標記出所有不在關閉的折疊中的行。然後
		對所有標記過的行，執行 {cmd}。所以當 {cmd} 改變了文本的折疊
		時，對命令執行的位置沒有影響 (當然，刪除行例外)。
		如： >
			:folddoopen s/end/loop_end/ge
<		使用標誌位 "e" 避免了當 "end" 不匹配時得到錯誤消息。

:[range]folddoc[losed] {cmd}			*:folddoc* *:folddoclosed*
		對所有在關閉的折疊裡的行，執行 {cmd}。
		其它同 ":folddoopen" 命令。

==============================================================================
3. 折疊選項					*fold-options*

顏 色							*fold-colors*

對關閉的折疊的顏色的設定由 Folded 高亮組 |hl-Folded| 決定。對折疊欄的顏色的設
定由 FolderColumn 高亮組 |hl-FoldColumn| 決定。
下面是設定顏色的例子： >

	:highlight Folded guibg=grey guifg=blue
	:highlight FoldColumn guibg=darkgrey guifg=white
<

折 疊 級 別						*fold-foldlevel*

'foldlevel' 是個數值選項：數字越大則打開的折疊更多。
當 'foldlevel' 為 0 時，所有的折疊關閉。
當 'foldlevel' 為正數時，一些折疊關閉。
當 'foldlevel' 很大時，所有的折疊打開。
'foldlevel' 的改變後立即生效。之後，折疊可以被手動地打開和關閉。
當其值增大，在新級別 (譯者注: 舊級別？) 之上的折疊被打開。手工打開的折疊不會被
關閉。
當其值減小，在新級別之上的折疊被關閉。手工關閉的折疊不會被打開。


折 疊 文 本						*fold-foldtext*

'folftext' 是個字符串選項，定義了一個表達式。這個表達式被用來求得關閉折疊所顯
示的文字。如： >

    :set foldtext=v:folddashes.substitute(getline(v:foldstart),'/\\*\\\|\\*/\\\|{{{\\d\\=','','g')

顯示了折疊的第一行，除去其中的 "/*"、"*/" 和 "{{{" 。
備註: 使用反斜槓是為了避免一些字符被 ":set" 命令解釋。使用一個函數更簡單： >

    :set foldtext=MyFoldText()
    :function MyFoldText()
    :  let line = getline(v:foldstart)
    :  let sub = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')
    :  return v:folddashes . sub
    :endfunction

'foldtext' 的計算是在沙盤 |sandbox| 裡完成的。其中的當前窗口設為要顯示該行的窗
口。錯誤被忽略。

默認值是 |foldtext()|。對於大多數類型的折疊它可以返回適合的文字。如果你不喜歡
它，你可以自己指定 'foldtext' 表達式。可以使用以下這些 Vim 變量：
	v:foldstart	折疊首行的行號
	v:foldend	折疊末行的行號
	v:folddashes	一個含有連字符的字符串，用來表示折疊級別
	v:foldlevel	折疊級別

在結果中，製表符被替換為空格，而不可顯示的字符被替換為可顯示的字符。

結果行被截短以適合窗口的寬度，永遠不會迴繞。
當在文字後有空餘時，用 'fillchars' 來填充。

備註: 對那些 ":set" 命令作特殊處理的字符在其前面須加上反斜槓。如：空格，反斜槓
和雙引號。 |option-backslash|


折 疊 欄						*fold-foldcolumn*

'foldcolumn' 是個數字，它設定了在窗口的邊上表示折疊的欄的寬度。當為 0 時，沒有
折疊欄。一個普通值是 4 或 5。最小可用的值是 2，不過 1 仍然可以提供一些信息。最
大是 12。

一個打開的折疊由一欄來表示，頂端是 '-'，其下方是 '|'。這欄在折疊結束的地方結
束。當折疊嵌套時，嵌套的折疊出現在被包含的折疊右方一個字符位置。

一個關閉的折疊由 '+' 表示。

當折疊欄太窄而不能顯示所有折疊時，顯示一數字來表示嵌套的級別。

在折疊欄點擊鼠標，可以打開和關閉折疊：
- 點擊 '+' 打開在這行的關閉折疊
- 在任何其他非空字符上點擊，關閉這行上的打開折疊


其 他 選 項

'foldenable'  'fen':	復位時打開所有折疊。
'foldexpr'    'fde':	用於 "expr" 折疊的表達式。
'foldignore'  'fdi':	用於 "indent" 折疊的字符。
'foldmarker'  'fmr':	用於 "marker" 折疊的標誌。
'foldmethod'  'fdm':	當前折疊方法。
'foldminlines' 'fml':	關閉折疊的最小顯示行數。
'foldnestmax' 'fdn':	用於 "indent" 和 "syntax" 折疊的最大嵌套層數。
'foldopen'    'fdo':	哪一種命令可以打開關閉的折疊。
'foldclose'   'fcl':	當光標不在折疊上時關閉折疊。

==============================================================================
4. 折疊行為						*fold-behavior*

當上下移動和滾動時，光標將移至連續折疊的行的第一行。當光標已在被折疊的行上時，
它移動到下一個沒有被折疊的行上，或下一個關閉的折疊。

當光標在被折疊的行上時，光標總是顯示在第一列。標尺顯示確切的光標位置。光標本應
也在實際位置顯示的，但因為被折疊而無法做到。

許多移動命令處理連續被折疊的行就像處理空行一樣。如，"w" 命令只在首列停一次。

在插入模式下，光標所在的行不會被折疊。這讓你看得見你鍵入的內容。

當使用操作符時，一個關閉的行被作為整體處理。所以 "dl" 在光標下刪除了整個關閉的
折疊。

對 Ex 命令的執行範圍被調整，使得它總是從關閉折疊的第一行開始，在關閉折疊的最後
一行結束。所以，命令： >
	:s/foo/bar/g
當光標在關閉的折疊上時，它將在整個折疊裡用 "bar" 替換 "foo"。
不過 |:folddoopen| 和 |:folddoclosed| 的操作並非如此。

編輯一個已經被編輯過的緩衝區時，上次被使用的折疊設置會被再次使用。對手工定義折
疊方式，已經被定義的折疊會被恢復。對所有的折疊方式，手工打開和關閉的折疊會被恢
復。如果這個緩衝區曾經在這個窗口裡被編輯，過去用的值被恢復。否則，來自該緩衝區
最近一次編輯的窗口值被使用。

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
