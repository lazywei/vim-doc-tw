*motion.txt*    For Vim version 7.3.  最近修改: 2010年8月


		  VIM 參考手冊    by Bram Moolenaar
				譯者: Willis
				http://vimcdoc.sf.net


光標移動					*cursor-motions* *navigation*

這些命令用於移動光標。如果新的位置離開了當前顯示範圍，屏幕將滾動到合適的位置，
使得光標可見 (參見 'scrolljump' 和 'scrolloff' 選項)。

1. 動作和操作符			|operator|
2. 左右動作			|left-right-motions|
3. 上下動作			|up-down-motions|
4. 單詞動作			|word-motions|
5. 文本對像動作			|object-motions|
6. 文本對像選擇			|object-select|
7. 位置標記			|mark-motions|
8. 跳轉				|jump-motions|
9. 其他動作			|various-motions|

概論:

如果你想知道在當前文件所在的位置，可以用 "CTRL-G" 命令 |CTRL-G| 或者
"g CTRL-G" 命令 |g_CTRL-G|。如果你置位了 'ruler' 選項，光標位置會在狀態行上保
持更新 (Vim 會因此稍慢一些)。

有經驗的用戶更喜歡 hjkl 鍵，因為它們就在自己的手指下面。初學者則傾向於光標移動
鍵，因為他們不知道 hjkl 鍵做什麼。看看鍵盤的佈局就很容易記住 hjkl 的意義。把 j
想像成一個向下的箭頭就可以了。

置位 'virtualedit' 選項使得光標可以移動到還沒有字符或者半個字符的位置。

==============================================================================
1. 動作和操作符						*operator*

動作命令出現在操作符之後，從而使操作符作用於被該動作所跨越的文本之上。也就
是，在動作之前和之後的光標位置之間的文本。一般的，操作符用來刪除或者改變文本。
下面列出所有的操作符:

	|c|	c	修改 (change)
	|d|	d	刪除 (delete)
	|y|	y	抽出 (yank) 到寄存器 (不改變文本)
	|~|	~	變換大小寫 (只有當 'tildeop' 置位時有效)
	|g~|	g~	變換大小寫
	|gu|	gu	變為小寫
	|gU|	gU	變為大寫
	|!|	!	通過外部程序過濾
	|=|	=	通過 'equalprg' (若為空，C-indenting) 過濾
	|gq|	gq	文本排版
	|g?|	g?	ROT13 編碼
	|>|	>	右移
	|<|	<	左移
	|zf|	zf	定義折疊
	|g@|    g@      調用 'operatorfunc' 選項定義的函數

如果動作包括一個次數而操作符之前也有一個的話，兩者相乘。因此，"2d3w" 刪除六個
單詞。

大多數情況下，光標在應用操作符後停在被操作的文本的起始處。例如，"yfe" 不移動光
標，而 "yFe" 則向左移動光標到抽出的文本的起始的那個 "e" 上。

						*linewise* *characterwise*
操作符或者影響開始和結束位置之間的整行或者字符區間。一般說來，在行間移動的動作
影響整行 (或者說面向行的)，而在行內移動的動作影響字符區間 (或者說面向字符的)。
但是有例外。

						*exclusive* *inclusive*
面向字符的動作或者是閉的，或者是開的。閉動作的開始和結束位置包含在操作範圍裡。
開動作中，靠近緩衝區尾端的最後一個字符不被包含在內。行的動作總包含開始和結尾的
位置。

下面的命令裡總會提到動作是行的、開的、或是閉的。不過，有兩個一般的特例:
1. 如果一個開動作的結尾應在第一列，那麼，它會前移到上一行的結尾處，並成為一個
   閉動作。例如，"}" 移動到一個段落之後的第一行。但 "d}" 不會包含那一行。
						*exclusive-linewise*
2. 如果一個開動作的結尾應在第一列，而它的開始在一行的第一個非空白字符之前或之
   上，那麼它會轉換成一個行動作。例如，如果一個段落以若干空白開始，而你在第一
   個非空白字符上執行 "d}"，那麼該段落的所有行都被刪除，包括之前的空白。如果你
   再放置 (put)，那麼刪除的行將插在光標之下。

請 注意 如果操作符處於等待狀態 (鍵入了操作符命令但還沒有鍵入動作)，將應用一組
特別的映射命令。參見 |:omap|。

除了先給出操作符再給出動作的方式以外，你還可以用可視模式: 先用 "v" 標記文本的
開始處，移動光標到文本的末尾，然後再輸入操作符。開始和當前光標位置之間的文本以
高亮顯示，從而你可以直觀地看到要操作的文本。這種方式提供了更多的自由，但代價是
更多的鍵擊而且重做不易。參見可視模式的章節 |Visual-mode|。

你可以用 ":" 命令定義一個動作。例如，"d:call FindEnd()"。
不過如果命令多於一行，該操作不能用 "." 重複。例如，可以重複: >
	d:call search("f")<CR>
但不能重複: >
	d:if 1<CR>
	   call search("f")<CR>
	endif<CR>


強 制 一 個 動 作 面 向 行、面 向 字 符 或 者 面 向 可 視 列 塊

如果一個動作不是你希望使用的類型，你可以在操作符後用 "v"、"V" 或者 CTRL-V 來
強制轉換類型。
示例: >
	dj
刪除兩行 >
	dvj
刪除當前光標位置到光標下方字符之間字符 >
	d<C-V>j
刪除光標所在和光標下方的字符。

把面向行的動作強制為面向字符或者列塊時要注意，列不一定總有定義。

							*o_v*
v		在操作符後和動作命令之前應用: 即使該動作是面向行的，也強制該操
		作面向字符。如果它應是面向行的，則變成開動作。如果已經是面向字
		符的，則在開/閉間切換。這可以使一個開動作成為閉的，或者使一個
		閉動作成為開的。

							*o_V*
V		在操作符後和動作命令之前應用: 即使該動作是面向字符的，也強制該
		操作面向行。

							*o_CTRL-V*
CTRL-V		在操作符後和動作命令之前應用: 強制該動作面向列塊。這類似於可視
		列塊模式的選擇，由動作之前和之後的光標位置定義兩個角落。

==============================================================================
2. 左右動作						*left-right-motions*

這些命令移動光標到當前行的指定列。除了 "$" 之外 (有可能跨越多行)，它們最多停在
該行的第一列或者行尾。'whichwrap' 選項可以使其中的一些命令跨越行的邊界。

h		或					*h*
<Left>		或					*<Left>*
CTRL-H		或					*CTRL-H* *<BS>*
<BS>			向左 [count] 個字符。|exclusive| 開動作。
			注意: 如果你希望 <BS> 刪除字符，使用如下映射:
				:map CTRL-V<BS>		X
			(要輸入 "CTRL-V<BS>" 先敲 CTRL-V 鍵，緊跟一個 <BS> 鍵)
			如果 <BS> 和希望的操作不符，查閱 |:fixdel|。

l		或					*l*
<Right>		或					*<Right>* *<Space>*
<Space>			向右 [count] 個字符。|exclusive| 開動作。

							*0*
0			到行的第一個字符。|exclusive| 開動作。

							*<Home>* *<kHome>*
<Home>			到行的第一個字符。|exclusive| 開動作。上下移動時，停在
			相同的文本列 (如果可能的話)，與之對照，多數其它命令則
			保持在相同的_屏幕_列上。和 "1|" 類似。如果一行以 <Tab>
			開頭，則和 "0" 有區別。{Vi 無此功能}。

							*^*
^			到行的第一個非空白字符。|exclusive| 開動作。

							*$* *<End>* *<kEnd>*
$ 或 <End>		到行尾。如果給出 [count]，則先往下走 [count-1] 行。
			|inclusive| 閉動作。可視模式下，光標移到緊貼該行最後一
			個字符之後的位置。
			如果置位了 'virtualedit'，"$" 可從行尾之後的空白後退到
			行尾。

							*g_*
g_			往下 [count-1] 行並到該行的最後一個非空白字符。
			|inclusive| 閉動作。{Vi 無此功能}

							*g0* *g<Home>*
g0 或 g<Home>		如果設置了行迴繞 ('wrap' 打開): 到屏幕行的第一個字符。
			|exclusive| 開動作。如果一文本行不能在屏幕上完全顯示，
			它和 "0" 就會有不同。
			如果沒有設置 ('wrap' 關閉): 到該行屏幕顯示範圍的最左
			面的字符。如果該行第一個字符不在屏幕上，則它和 "0" 就
			有不同。{Vi 無此功能}

							*g^*
g^			如果設置了行迴繞 ('wrap' 打開): 到屏幕行的第一個非空白
			字符。|exclusive| 開動作。如果一文本行不能在屏幕上完全
			顯示，它和 "^" 就會有區別。
			如果沒有設置 ('wrap' 關閉): 到該行屏幕顯示範圍的最左面
			的非空白字符。如果該行第一個字符不在屏幕上，則它和 "^"
			就有區別。{Vi 無此功能}

							*gm*
gm			和 "g0" 類似，但 (盡可能) 向右移到屏幕顯示寬度的中間位
			置。{Vi 無此功能}

							*g$* *g<End>*
g$  或  g<End>		如果設置了行迴繞 ('wrap' 打開): 往下 [count-1] 屏幕行
			並到該屏幕行的行尾。|inclusive| 閉動作。如果一文本行不
			能在屏幕上完全顯示，它和 "$" 就會有不同。
			如果沒有設置 ('wrap' 關閉): 到該行屏幕顯示範圍的最右面
			的字符。如果該行的行尾字符不可見，則它和 "$" 就有不
			同。另外，垂直移動保持所在的列，而不是移到行尾。
			{Vi 無此功能}

							*bar*
|			到當前行的 [count] 屏幕列。|exclusive| 開動作。
			Ceci n'est pas une pipe (譯者注: 法語 這不是一隻煙斗，
			這是名句，pipe 也做管道講，有雙關義)。

							*f*
f{char}			到右側第 [count] 次出現的字符 {char}。光標放在 {char}
			上。|inclusive| 閉動作。
			{char} 可以輸入二合字母 |digraph-arg|。
			如果 'encoding' 設為 Unicode，則可以輸入合成用字符，參
			見 |utf-8-char-arg|。
			{char} 要進行 |:lmap| 映射。插入模式下的 CTRL-^ 命令可
			以用來切換這一點 |i_CTRL-^|。

							*F*
F{char}			到左側第 [count] 次出現的字符 {char}。
			光標放在 {char} 上。|exclusive| 開動作。
			{char} 可以和 |f| 命令相同的方式輸入。

							*t*
t{char}			直到右側第 [count] 次出現的字符 {char} 之前。光標放在
			{char} 左邊的位置。|inclusive| 閉動作。
			{char} 可以和 |f| 命令相同的方式輸入。

							*T*
T{char}			直到左側第 [count] 次出現的字符 {char} 之後。光標放在
			{char} 右側的位置。|exclusive| 開動作。
			{char} 可以和 |f| 命令相同的方式輸入。

							*;*
;			重複上次的 f、t、F 或者 T 命令 [count] 次。

							*,*
,			反方向重複上次的 f、t、F 或者 T 命令 [count] 次。

==============================================================================
3. 上下動作						*up-down-motions*

k		或					*k*
<Up>		或					*<Up>* *CTRL-P*
CTRL-P			向上 [count] 行。|linewise| 行動作。

j		或					*j*
<Down>		或					*<Down>*
CTRL-J		或					*CTRL-J*
<NL>		或					*<NL>* *CTRL-N*
CTRL-N			向下 [count] 行。|linewise| 行動作。

gk		或					*gk* *g<Up>*
g<Up>			向上 [count] 顯示行。|exclusive| 開動作。
			在行迴繞和操作符之後與 'k' 不同，因為後者不是面向行
			的。{Vi 無此功能}

gj		或					*gj* *g<Down>*
g<Down>			向下 [count] 顯示行。|exclusive| 開動作。
			在行迴繞和操作符之後與 'j' 不同，因為後者不是面向行
			的。{Vi 無此功能}

							*-*
-  <minus>		向上 [count] 行，停在第一個非空白字符上。|linewise|
			行動作。

+		或					*+*
CTRL-M		或					*CTRL-M* *<CR>*
<CR>			向下 [count] 行，停在第一個非空白字符上。|linewise|
			行動作。

							*_*
_  <underscore>		向下 [count] - 1 行，停在第一個非空白字符上。
			|linewise| 行動作。

							*G*
G			到第 [count] 行，缺省是最後一行， |linewise| 行動作。
			如果 'startofline' 沒有置位，保持在相同的列上，不然，
			停在第一個非空白字符上。
			G 是 |jump-motions| 之一.

							*<C-End>*
<C-End>			到第 [count] 行，缺省是最後一行；並停在最後一個字符
			上。|inclusive| 閉動作。{Vi 無此功能}

<C-Home>	或					*gg* *<C-Home>*
gg			到第 [count] 行，缺省是第一行， |linewise| 行動作。
			如果 'startofline' 沒有置位，保持在相同的列上，不然，
			停在第一個非空白字符上。

:[range]		把光標移到 [range] 的最後一行。[range] 也可以是單獨一
			個行號，如 ":1" 或 ":'m"。
			和 |G| 不同，此命令不修改 |jumplist|。
							*N%*
{count}%		到文件的 {count} 百分比處，|linewise| 行動作。
			新的行號計算方法如下:
			    ({count} * 總行數 + 99) / 100
			如果 'startofline' 沒有置位，保持在相同的列上，不然，
			停在第一個非空白字符上。{Vi 無此功能}

:[range]go[to] [count]					*:go* *:goto* *go*
[count]go		到緩衝區的第 {count} 個字節。缺省的 [count] 是 1，即文
			件開始處。如果給定 [range]，則最後的一個數字用作字節的
			序號。'fileformat' 的當前設置決定如何計算換行符的個數。
			{Vi 無此功能}
			{僅當編譯時加入 |+byte_offset| 特性才有效}

這些命令移動到特定的行上，最多，它們移動到第一行或者最後一行。開始兩個命令的光
標將停留在最後一個改變列號命令所指定的列上 (如果可能的話)。"$" 命令除外，這
時，光標總會停在一行的行尾。

如果 "k"、"-" 或 CTRL-P 使用時給出 [count]，而光標上方的行數小於 [count] 且
'cpo' 選項包含了 "-" 標誌位，報錯 |cpo--|。

==============================================================================
4. 單詞動作						*word-motions*

<S-Right>	或					*<S-Right>* *w*
w			正向 [count] 個單詞。|exclusive| 開動作。

<C-Right>	或					*<C-Right>* *W*
W			正向 [count] 個字串。|exclusive| 開動作。

							*e*
e			正向到第 [count] 個單詞的尾部。|inclusive| 閉動作。
			不停留在空行上。

							*E*
E			正向到第 [count] 個字串的尾部。|inclusive| 閉動作。
			不停留在空行上。

<S-Left>	或					*<S-Left>* *b*
b			反向 [count] 個單詞。|exclusive| 開動作。

<C-Left>	或					*<C-Left>* *B*
B			反向 [count] 個字串。|exclusive| 開動作。

							*ge*
ge			反向到第 [count] 個單詞的尾部。|inclusive| 閉動作。

							*gE*
gE			反向到第 [count] 個字串的尾部。|inclusive| 閉動作。

這些命令在單詞或字串間移動。
							*word*
一個單詞由字符、數字和下劃線序列或者其他的非空白字符的序列組成。單詞間可以空白
字符 (空格、製表、換行) 分隔。這一規則可以用 'iskeyword' 選項改變。空行也被認
作單詞。
							*WORD*
一個字串由非空白字符序列組成。字串以空白分隔。空行也被認作字串。

已折疊的行序列被認作由單個字符組成的單詞。"w" 和 "W"、"e" 和 "E" 移動到折疊行
之後的第一個單詞或字串的開始/結尾處。"b" 和 "B" 移動到折疊之前的第一個單詞的開
始處。

特例: 如果光標在非空白字符上，"cw" 和 "cW" 等價於 "ce" 和 "cE"。這是因為 "cw"
被詮釋為 修改-單詞 (change-word)，而單詞並不包括後續的空格。{Vi: 在多個空白的
某一個空白之上做 "cw" 只會改動單個空白字符；這可能不太對，因為 "dw" 是刪除所有
後面的空白的}

另外一個特例: 如果 "w" 動作帶操作符並且該動作的最後一個單詞在行尾，則該操作范
圍結束於行尾而非下一行的第一個單詞。

原始 Vi 的 "e" 實現有問題。例如，如果前一行為空而光標停在後一行的第一個字符的
話，"e" 就會卡在那裡，但是你用 "2e" 就很正常。Vim 裡就不是，"ee" 和 "2e" 有相
同的行為，這更合乎邏輯。不過，這造成了 Vi 和 Vim 小小的不兼容。

==============================================================================
5. 文本對像動作					*object-motions*

							*(*
(			反向 [count] 個句子。|exclusive| 開動作。

							*)*
)			正向 [count] 個句子。|exclusive| 開動作。

							*{*
{			反向 [count] 個段落。|exclusive| 開動作。

							*}*
}			正向 [count] 個段落。|exclusive| 開動作。

							*]]*
]]			正向 [count] 個小節或到出現在首列的 '{'。如果帶操作符，
			則同時停留在首列的 '}' 的下方。|exclusive| 開動作。
			注意 |exclusive-linewise| 常常適用。

							*][*
][			正向 [count] 個小節或到出現在首列的 '}'。|exclusive|
			開動作。
			注意 |exclusive-linewise| 常常適用。

							*[[*
[[			反向 [count] 個小節或到出現在首列的 '{'。|exclusive|
			開動作。
			注意 |exclusive-linewise| 常常適用。
							*[]*
[]			反向 [count] 個小節或到出現在首列的 '}'。|exclusive|
			開動作。
			注意 |exclusive-linewise| 常常適用。

這些命令在三類文本對像上移動，見下。

							*sentence*
一個句子以 '.'、'!' 或者 '?' 結尾並緊隨著一個換行符、空格或者製表符。標點和空
白字符之間可以出現任何數量的閉括號和引號: ')'、']'、'"' 和 '''。另，段落和小節
的邊界也視為句子的邊界。
如果 'cpoptions' 包含 'J' 標誌位，那麼標點之後的空格至少要出現兩個，而且製表符
不被視為空白字符。

							*paragraph*
一個段落從空行或某一個段落宏命令開始，段落宏由 'paragraphs' 選項裡成對出現的字
符所定義。它的缺省值為 "IPLPPPQPP TPHPLIPpLpItpplpipbp"，也就是宏 ".IP"、".LP"
等 (這些是 nroff 宏，所以句號一定要出現在第一列)。小節邊界也被視為段落邊界。
注意 空白行 (只包含空白) _不是_ 段落邊界。
也要 注意: 這不包括首列出現的 '{' 或 '}'。如果 'cpoptions' 裡包含 '{' 標誌位，
那麼首列的 '{' 用作段落邊界 |posix|。

							*section*
一個小節從首列出現的換頁符 (<C-L>) 或某一個小節宏命令開始。小節宏由 'sections'
選項裡成對出現的字符所定義。它的缺省值是 "SHNHH HUnhsh"，也就是說小節可以從如
下的 nroff 宏開始: ".SH"、".NH"、".H"、".HU"、".nh" 和 ".sh"。

"]" 和 "[" 命令也停在首列出現的 '{' 或 '}' 上。這有助於在 C 程序裡找到函數的開
始和結束位置。 注意: 命令的第一個字符決定搜索的方向，第二個字符決定要找到的括
號。

如果你的 '{' 或 '}' 不在第一列但是你還是希望用 "[[" 和 "]]" 來找它們，試試這些
映射: >
   :map [[ ?{<CR>w99[{
   :map ][ /}<CR>b99]}
   :map ]] j0[[%/{<CR>
   :map [] k$][%?}<CR>
[照文本直接輸入，參見 |<>|]

==============================================================================
6. 文本對像選擇					*object-select* *text-objects*
						*v_a* *v_i*

這裡是一系列只能在可視模式或操作符後使用的命令。這些命令或以 "a" 打頭，代表選
擇一個 ("a"n) 包含空白的對象；或以 "i" 帶頭，代表選擇內含 ("i"nner) 對像: 它們
不包含空白。另外，空白本身也是內含對象。這樣，"內含" 對像總比 "一個" 對像選擇
較少的文本。

這些命令都是 {Vi 無此功能}。
這些命令只有在編譯時加入 |+textobjects| 特性後才有效。
							*v_aw* *aw*
aw			"一個單詞"，選擇 [count] 個單詞 (見 |word|)。
			包括開頭或拖尾的空白，但不單獨計算。在可視面向行的模式
			下，"aw" 切換到可視面向字符的模式。

							*v_iw* *iw*
iw			"內含單詞"，選擇 [count] 個單詞 (見 |word|)。
			單詞之間的空白也被算為一個單詞。在可視面向行的模式下，
			"iw" 切換到可視面向字符的模式。

							*v_aW* *aW*
aW			"一個字串"，選擇 [count] 個字串 (見 |WORD|)。
			包括開頭或拖尾的空白，但不單獨計算。在可視面向行的模式
			下，"aW" 切換到可視面向字符的模式。

							*v_iW* *iW*
iW			"內含字串"，選擇 [count] 個字串 (見 |WORD|)。
			字串之間的空白也被算為一個字串。在可視面向行的模式下，
			"iW" 切換到可視面向字符的模式。

							*v_as* *as*
as			"一個句子"，選擇 [count] 個句子 (見 |sentence|)。
			可視模式下它切換為面向字符的模式。

							*v_is* *is*
is			"內含句子"，選擇 [count] 個句子 (見 |sentence|)。
			可視模式下它切換為面向字符的模式。

							*v_ap* *ap*
ap			"一個段落"，選擇 [count] 個段落 (見 |paragraph|)。
			特例: 空白行 (只包含空白的行) 也被視為段落邊界。
			可視模式下它切換為面向行的模式。

							*v_ip* *ip*
ip			"內含段落"，選擇 [count] 個段落 (見 |paragraph|)。
			特例: 空白行 (只包含空白的行) 也被視為段落邊界。
			可視模式下它切換為面向行的模式。

a]						*v_a]* *v_a[* *a]* *a[*
a[			"一個 [] 塊"，選擇 [count] 層 '[' ']' 塊。為此，先反向
			查找第 [count] 個未匹配的 '['，然後查找其相應的 ']'。
			兩者之間的文本，包括 '[' 和 ']'，都被選擇。
			可視模式下它切換為面向字符的模式。

i]						*v_i]* *v_i[* *i]* *i[*
i[			"內含 [] 塊"，選擇 [count] 層 '[' ']' 塊。為此，先反向
			查找第 [count] 個未匹配的 '['，然後查找其相應的 ']'。
			兩者之間的文本，但不包括 '[' 和 ']'，被選擇。
			可視模式下它切換為面向字符的模式。

a)							*v_a)* *a)* *a(*
a(							*v_ab* *v_a(* *ab*
ab			"一個塊"，選擇 [count] 層塊，從 "[count] [(" 到其相應
			的 ')'，包括 '(' 和 ')' (見 |[(|)。它並不包括括號之
			外的空白。
			可視模式下它切換為面向字符的模式。

i)							*v_i)* *i)* *i(*
i(							*v_ib* *v_i(* *ib*
ib			"內含塊"，選擇 [count] 層塊，從 "[count] [(" 到其相應
			的 ')'，但不包括 '(' 和 ')' (見 |[(|)。
			可視模式下它切換為面向字符的模式。

a>						*v_a>* *v_a<* *a>* *a<*
a<			"一個 <> 塊"，選擇 [count] 層 <> 塊，從反向第 [count]
			個未匹配的 '<' 到其匹配的 '>'，包括 '<' 和 '>'。
			可視模式下它切換為面向字符的模式。

i>						*v_i>* *v_i<* *i>* *i<*
i<			"內含 <> 塊"，選擇 [count] 層 <> 塊，從反向第 [count]
			個未匹配的 '<' 到其匹配的 '>'，但不包括 '<' 和 '>'。
			可視模式下它切換為面向字符的模式。

						*v_at* *at*
at			"一個標籤塊"，選擇 [count] 層標籤塊。從反向第 [count]
			個未匹配的 "<aaa>" 到其匹配的 "</aaa>"，包括 "<aaa>"
			和 "</aaa>"。
			詳情見 |tag-blocks|。
			可視模式下它切換為面向字符的模式。

						*v_it* *it*
it			"內部標籤塊"，選擇 [count] 層標籤塊。從反向第 [count]
			個未匹配的 "<aaa>" 到其匹配的 "</aaa>"，但不包括
			"<aaa>" 和 "</aaa>"。
			詳情見 |tag-blocks|。
			可視模式下它切換為面向字符的模式。

a}							*v_a}* *a}* *a{*
a{							*v_aB* *v_a{* *aB*
aB			"一個大塊"，選擇 [count] 層大塊，從 "[count] [{" 到其
			相應的 '}'，包括 '{' 和 '}' (見 |[{|)。
			可視模式下它切換為面向字符的模式。

i}							*v_i}* *i}* *i{*
i{							*v_iB* *v_i{* *iB*
iB			"內含大塊"，選擇 [count] 層大塊，從 "[count] [{" 到其
			相應的 '}'，但不包括 '{' 和 '}' (見 |[{|)。
			可視模式下它切換為面向字符的模式。

a"							*v_aquote* *aquote*
a'							*v_a'* *a'*
a`							*v_a`* *a`*
			"一個引號字符串"。選擇上一個引號開始到下一個引號結束的
			文本。'quoteescape' 選項用於跳過轉義的引號。
			只在同一行內有效。
			如果開始時光標在引號上，Vim 會從該行行首開始搜索，以決
			定哪個引號對構成字符串。
			包含任何拖尾的空白，如果沒有拖尾的，也包含開頭的空白。
			可視模式下它切換為面向字符的模式。
			在可視模式下重複此對像會包含另一個字符串。目前不使用計
			數。

i"							*v_iquote* *iquote*
i'							*v_i'* *i'*
i`							*v_i`* *i`*
			類似於 a"、a' 和 a`，但不包括引號，而重複也不會擴展可
			視選擇區。
			特例: 計數為 2 時包含引號，但不包括 a"/a'/a` 包含的額
			外的空白。

在操作符之後:
非塊對像:
	對於 "一個" 命令: 操作符作用於對象與其後的空白。如果其後沒有空白或者光
	標位於對像之前的空白上的話，那麼也包括對像之前的空白。
	對於 "內含" 命令: 如果光標在對像之上，那麼操作符作用於該對象。如果光標
	在空白上，那麼操作符作用於空白。
塊對像:
	操作符作用於光標所在位置所在 (包括光標在括號上的特殊情況) 的塊。對於
	"內含" 命令，不包含包圍的括號。而對於 "一個" 命令，則包含之。

在可視模式下:
如果可視區域的起始和結束點在相同位置 (剛輸入 "v"):
	選擇一個區域，就和使用操作符一樣。
如果可視區域的起始和結束點不同:
	若不是塊對象，該區域被對像或者下一個對像之前空白所擴展，對於 "一個" 命
	令，則兩者都包含。擴展的方向決定於可視區域和光標的相對位置。
	若是塊對象，該塊向外擴展一層。

讓我們用一系列刪除命令來說明，刪除的範圍從小到大。請 注意 對於單個字符和整行的
操作我們用了已有的 Vi 移動命令。
	"dl"	刪除字符 (縮寫: "x")			|dl|
	"diw"	刪除內含單詞				*diw*
	"daw"	刪除一個單詞				*daw*
	"diW"	刪除內含字串 (見 |WORD|)		*diW*
	"daW"	刪除一個字串 (見 |WORD|)		*daW*
	"dd"	刪除一行				|dd|
	"dis"	刪除內含句子				*dis*
	"das"	刪除一個句子				*das*
	"dib"	刪除內含 '(' ')' 塊			*dib*
	"dab"	刪除一個 '(' ')' 塊			*dab*
	"dip"	刪除內含段落				*dip*
	"dap"	刪除一個段落				*dap*
	"diB"	刪除內含 '{' '}' 大塊			*diB*
	"daB"	刪除一個 '{' '}' 大塊			*daB*

請 注意 移動命令和文本對象的區別。移動命令作用於這裡 (光標當前位置) 到移動後的
位置。而對象的使用則會作用於整個對象，而和光標在對象的何處無關。例如，我們可以
比較 "dw" 和 "daw": "dw" 刪除光標位置到下一個單詞的起始處，"daw" 刪除光標所在
的整個單詞和其後或其前的空白。


標籤塊							*tag-blocks*

"it" 和 "at" 文本對像嘗試選擇 HTML 和 XML 的匹配標籤之間的塊。但因為它們並不完
全兼容，有一些限制。

通常的方法是選擇 <tag> 直到匹配的 </tag> 為止的內容。"at" 包含標籤，"it" 不包
含。不過重複 "it" 時標籤仍然會包含 (不然不會有任何改變)。此外，在沒有內容的標
簽塊上使用 "it" 會單獨選擇引導標籤。

跳過 "<aaa/>" 項目。忽略大小寫，即使對大小寫應該敏感的 XML 也是如此。

HTML 裡可以有 <br> 或 <meta ...> 這樣沒有匹配結束標籤的標籤。它們被忽略。

這些文本對像能夠容忍錯誤。單獨出現的結束標籤被忽略。

==============================================================================
7. 位置標記					*mark-motions* *E20* *E78*

跳轉到一個位置標記有兩種方法:
1. 用 ` (反引號):	光標放在指定的位置，|exclusive| 開動作。
2. 用 ' (單引號):	光標放在指定位置所在行的第一個非空字符上，|linewise|
			行動作。

						*m* *mark* *Mark*
m{a-zA-Z}		把位置標記 {a-zA-Z} 設在當前光標位置 (不移動光標，這
			不是動作命令)。

						*m'* *m`*
m'  或  m`		設置前次上下文標記。以後可以用 "''" 或者 "``" 跳轉到
			這個位置 (不移動光標，這不是動作命令)。

						*m[* *m]*
m[  或  m]		設置 |'[| 或者 |']| 標記。可以用在執行多個命令的操作符
			的定義中。 (不移動光標，這不是動作命令)。

						*:ma* *:mark* *E191*
:[range]ma[rk] {a-zA-Z'}
			把位置標記 {a-zA-Z'} 設在 [range] 的最後一行，第 0
			列。缺省的 [range] 是當前行。

						*:k*
:[range]k{a-zA-Z'}	和 :mark 相同， 但是標記名之前的空格可以省略。

						*'* *'a* *`* *`a*
'{a-z}  `{a-z}		跳轉到當前緩衝區的位置標記 {a-z}。

						*'A* *'0* *`A* *`0*
'{A-Z0-9}  `{A-Z0-9}	跳轉到設置位置標記 {A-Z0-9} 的文件所在的標記位置 (如果
			切換到另外一個文件，這就不是動作命令)   {Vi 無此功能}

						*g'* *g'a* *g`* *g`a*
g'{mark}  g`{mark}
			跳轉到指定的位置標記 {mark}，但在當前緩衝區內跳轉時，不
			改變跳轉表。示例: >
				g`"
<			跳轉到當前文件最近的位置。參看
			$VIMRUNTIME/vimrc_example.vim。另見 |:keepjumps|。
			{Vi 無此功能}

						*:marks*
:marks			列出所有的位置標記 (這不是動作命令)，
			但不包括 |'(|，|')|，|'{| 和 |'}| 標記。
			第一列的編號為零。
			{Vi 無此功能}
						*E283*
:marks {arg}		列出所有 {arg} 包含的位置標記 (這不是動作命令)。例
			如， >
				:marks aB
<			列出位置標記 'a' 和 'B'。  {Vi 無此功能}

							*:delm* *:delmarks*
:delm[arks] {marks}	刪除指定的位置標記。可以刪除的位置標記也包括 A-Z 或
			0-9。不能刪除 ' 位置標記。
			指定的方式包括給出位置標記名的列表和使用連字符分隔的范
			圍。忽略空格。例如: >
			   :delmarks a	      刪除位置標記 a
			   :delmarks a b 1    刪除位置標記 a，b 和 1
			   :delmarks Aa       刪除位置標記 A 和 a
			   :delmarks p-z      刪除位置標記 p 到 z
			   :delmarks ^.[]     刪除位置標記 ^ . [ ]
			   :delmarks \"	      刪除位置標記 "
<			{Vi 無此功能}

:delm[arks]!		刪除當前緩衝區所有的位置標記，不包括 A-Z 或 0-9 位置標
			記。
			{Vi 無此功能}

位置標記在任何情況下都是不可見的。它只是文件中一個被記住的位置。不要和命名的寄
存器混淆，兩者毫不相干。

'a - 'z		小寫位置標記，在每個文件內有效。
'A - 'Z		大寫位置標記，也叫做文件標記，在文件間都有效。
'0 - '9		數字位置標記，在 .viminfo 文件裡設置。

只要文件還在緩衝區列表裡，小寫位置標記 'a 到 'z 就被記住。換而言之，如果在緩衝
區列表裡刪除一個文件，它的位置標記就消失了。如果刪除包含某個位置標記的文本行，
這個位置標記也就隨之消失。

小寫位置標記可以和操作符合併使用。例如，"d't" 刪除從光標位置到包含 't 標記的文
本行。提示: 用 't' 標記代表頂部 (Top)，'b' 標記代表底部 (Bottom)，等等。小寫位
置標記在撤銷/重做時會被復原。

大寫位置標記 'A 到 'Z 包含了所在的文件名。  {Vi: 沒有大寫位置標記} 可以用這些
標記在文件間跳轉。要和操作符合併使用的大寫位置標記必須在當前文件裡。即使插入/
刪除一些行或者同時編輯別的文件，這種標記的行號總是正確的。如果 'viminfo' 選項
不為空，大寫位置標記由 .viminfo 文件保存。 參閱 |viminfo-file-marks|。

數字位置標記 '0 到 '9 很不一樣。它們不是直接設置，而只能從 viminfo 文件
|viminfo-file| 中獲取。簡單的說，'0 是你上次離開 Vim 時的光標位置。'1 是再上一
次，等等。'viminfo' 的 'r' 標誌可以指定不記錄數字位置標記的文件。參見
|viminfo-file-marks|。


							*'[* *`[*
'[  `[			到上次改變或者抽出的文本的第一個字符。  {Vi 無此功能}

							*']* *`]*
']  `]			到上次改變或者抽出文本的最後一個字符。  {Vi 無此功能}

執行完一個操作符後，光標放在操作文本的開始。執行完一個放置命令 ("p" 或者
"P")，光標有時放在第一個被插入的位置，有時放在最後一個。上述四個命令可以把光標
放在兩端的任何一端。例如，在抽出 10 行後，你想要到跳轉到最後一行: "10Y']"。在
用 "p" 插入數行後你想跳到最底下的那行: "p']"。這對插入的文本也可以。

請 注意: 在刪除文本後，除非是面向列塊的可視模式，開始和結束的位置是重合的。而
如果沒有任何改變，這四個命令不會有任何作用。

							*'<* *`<*
'<  `<			到上次當前緩衝區選擇的可視區域首行或第一個字符。對於列
			塊模式而言，可能也是第一行的最後一個字符 (為了能定義列
			塊)。 {Vi 無此功能}

							*'>* *`>*
'>  `>			到上次當前緩衝區選擇的可視區域末行或最後一個字符。對於
			列塊模式而言，可能也是末行的第一個字符 (為了能定義列
			塊)。注意 這裡適用 'selection'，該位置可能是剛剛在可視
			區域之後的位置。 {Vi 無此功能}

							*''* *``*
''  ``			到上次跳轉的位置，或者上次 "m'" 或者 "m`" 命令給出的位
			置。如果使用了 |:keepjumps| 命令修飾符，這個前次上下
			文標記不會被改變。也可參考 |restore-position|。

							*'quote* *`quote*
'"  `"			到上次離開本緩衝區時的光標位置。缺省是第一行的第一個字
			符。 參見 |last-position-jump| 以瞭解如何對所有剛打開
			的文件使用這個標記。每個緩衝區，而不是每個窗口，只有一
			個記住的位置。只要這個緩衝區在某一個窗口可見，這個標記
			是不會改變的。  {Vi 無此功能}

							*'^* *`^*
'^  `^			到上次插入模式關閉的光標位置。|gi| 命令用到這個標記。
			如果使用了 |:keepjumps| 命令修飾符，這個標記不會改變。
			{Vi 無此功能}

							*'.* *`.*
'.  `.			到上次改變的位置。這個位置位於或者接近於改變開始的地
			方。有些命令引起幾個改變，那麼這個位置應該是接近於
			這個命令最後改變的地方。例如，插入一個單詞的時候，這個
			位置是在最後一個的字符上。
			{Vi 無此功能}

							*'(* *`(*
'(  `(			到當前句子的開始處，就像 |(| 命令。  {Vi 無此功能}

							*')* *`)*
')  `)			到當前句子的結尾處，就像 |)| 命令。  {Vi 無此功能}

							*'{* *`{*
'{  `{			到當前段落的開始處，就像 |{| 命令。  {Vi 無此功能}

							*'}* *`}*
'}  `}			到當前段落的結尾處，就像 |}| 命令。  {Vi 無此功能}


這些命令不是標記本身，而是實現對某個標記的跳轉:

							*]'*
]'			[count] 次到當前行之後下一個包含小寫位置標記的行的第一
			個非空白字符。  {Vi 無此功能}

							*]`*
]`			[count] 次下一個小寫位置標記。  {Vi 無此功能}

							*['*
['			[count] 次到當前行之前上一個包含小寫位置標記的行的第一
			個非空白字符。  {Vi 無此功能}

							*[`*
[`			[count] 次上一個小寫位置標記。  {Vi 無此功能}


:loc[kmarks] {command}					*:loc* *:lockmarks*
			執行命令 {command}，並且不調整位置標記。這可以用於不影
			響行的數目的文本改變。如果行數發生變化，那麼改變之後的
			標記將仍然保持它們的行號，從而實際上移到了別的行上。

			以下各項對於插入/刪除行不會被調整:
			- 小寫位置標記 'a - 'z
			- 大寫位置標記 'A - 'Z
			- 數字位置標記 '0 - '9
			- 上次插入位置 |'^|
			- 上次改變位置 |'.|
			- 可視選擇區域 |'<| 和 |'>|
			- 已設定的標號 |sign| 的行號
			- |quickfix| 位置的行號
			- 跳轉表 |jumplist| 裡的位置
			- 標籤堆棧 |tagstack| 裡的位置
			以下各項則總會被調整:
			- 前次上下文標記 |''|
			- 光標位置
			- 窗口或者緩衝區的視圖
			- 折疊 |folding|
			- 差異視圖 |diff|

:kee[pmarks] {command}					*:kee* *:keepmarks*
			目前，這只對過濾命令 |:range!| 有效:
			- 如果過濾後的行數不少於過濾之前，那麼所有的過濾行中的
			  標記保持行號不變。
			- 如果行數減少，那麼消失了的行中的標記就被刪除掉。
			在任何情況下，過濾文本之後的標記需要調整行號，以保持和
			文本同步。
			如果 'cpoptions' 中沒有 'R' 標誌，那麼直接執行過濾命令
			和使用 ":keepmarks" 的效果一樣。

							*:keepj* *:keepjumps*
:keepj[umps] {command}
			在 {command} 的移動不改變 |''|，|'.| 和 |'^| 標記，跳
			轉表 |jumplist| 或是改變表 |changelist|。這對於自動改
			變或者插入文本而不需要用戶跳轉到那個位置有用。例如，當
			更新 "最近改變" 的時間標籤: >

				:let lnum = line(".")
				:keepjumps normal gg
				:call SetLastChange()
				:keepjumps exe "normal " . lnum . "G"
<
			注意 ":keepjumps" 必須在每個命令裡使用。如果在命令裡調
			用了函數，則該函數里的命令仍然可能改變跳轉表。另外，
			":keepjumps exe 'command '" 裡的 "command" 不會保護跳
			轉表。應該用: ":exe 'keepjumps command'"

==============================================================================
8. 跳轉						*jump-motions*

"跳轉" 包括如下的命令: "'"、"`"、"G"、"/"、"?"、"n"、"N"、"%"、"("、")"、
"[["、"]]"、"{"、"}"、":s"、":tag"、"L"、"M"、"H" 和開始編輯新文件的命令。如果
用這些命令使光標 "跳轉"，那麼跳轉之前的光標位置會被記住。除非包含該位置的行被
改變或者刪除，你可以用 "''" 和 "``" 命令返回這個位置。

							*CTRL-O*
CTRL-O			轉到跳轉表裡第 [count] 個較舊的光標位置
			(不是動作命令).  {Vi 無此功能}
			{僅當編譯時加入 |+jumplist| 特性才有效}

<Tab>		或					*CTRL-I* *<Tab>*
CTRL-I			轉到跳轉表裡第 [count] 個較新的光標位置
			(不是動作命令)。
			在一個 |quickfix-window| 窗口裡，該命令帶你到光標所在
			的錯誤所指的位置。
			{Vi 無此功能}
			{僅當編譯時加入 |+jumplist| 特性才有效}

							*:ju* *:jumps*
:ju[mps]		打出跳轉表 (不是動作命令)。 {Vi 無此功能}
			{僅當編譯時加入 |+jumplist| 特性才有效}

							*jumplist*
跳轉表用來記住跳轉的位置。用 CTRL-O 和 CTRL-I 命令，你可以跳回到較早前的跳轉位
置，然後在跳回來。這樣，你就可以在這個列表上下移動。每個窗口有獨立的跳轉表，每
個表最多能存儲 100 項。
{僅當編譯時加入 |+jumplist| 特性才有效}

例如，在三個跳轉命令之後你有如下的跳轉表:

  jump line  col file/line ~
    3	  1    0 some text ~
    2	 70    0 another line ~
    1  1154   23 end. ~
 >~

"file/line" 列顯示文件名，如果是當前文件，則顯示跳轉所在的文本 (為了能在窗口裡
顯示，去掉開頭的縮排空白並截斷過長的行)。

你現在位於第 1167 行。如果你用 CTRL-O 命令，光標會到第 1154 行。結果如下:

  jump line  col file/line ~
    2	  1    0 some text ~
    1	 70    0 another line ~
 >  0  1154   23 end. ~
    1  1167    0 foo bar ~

指針會指向上一次跳轉的位置。下一個 CTRL-O 命令會使用更上面的那項。而下一個
CTRL-I 命令則會使用下面的那項。如果指針在最後一項之下，那說明你還沒用過 CTRL-I
或 CTRL-O 命令。此時，CTRL-O 命令會把光標位置加到跳轉表裡，這樣你以後就可以回
到用 CTRL-O 之前的位置。在本例中，這是第 1167 行。

更多的 CTRL-O 命令會使你分別到第 70 和第 1 行。如果你用 CTRL-I，你又可以回到第
1154 和第 1167 行。 注意: "jump" 列的數字指示你用 CTRL-O 或 CTRL-I 到該位置
所需的次數。

如果你用跳轉命令，當前的行號被插到跳轉表的最後。如果相同的行已經在跳轉表裡，那
會被刪除。結果是，CTRL-O 就會直接回到該行之前的位置。

如果用了 |:keepjumps| 命令修飾符，跳轉就不會被保存在跳轉表裡。一些其它場合也不
保存跳轉，例如在 |:global| 命令的裡面。你可以設置 ' 位置標記來顯式加入跳轉。

在 CTRL-O 命令之後，你到了第 1154 行。如果你給出另外一個跳轉命令 (比如，"G")，
那麼跳轉表就會成為:

  jump line  col file/line ~
    4	  1    0 一些文字 ~
    3	 70    0 另外一行 ~
    2  1167    0 foo bar ~
    1  1154   23 end. ~
 > ~

刪除和插入行以後，行號會得到調整。不過，如果你不保存文件而放棄編輯，例如
":n!"，該調整會失敗。

如果你分割一個窗口，跳轉表會複製到新的窗口裡。

如果在 'viminfo' 選項裡有 ' 項，跳轉表會保存在 viminfo 文件裡。這樣，重新啟動
Vim 就會恢復跳轉表。


改 變 表 跳 轉				*changelist* *change-list-jumps* *E664*

在改變文本以後，光標的位置被記住。每個改變都會記住一個位置，從而可以使該操作能
被撤銷。除非，這個位置和上一個改變很接近。可以用兩個命令跳轉到改變所在的位置，
包括那些已被撤銷的:

							*g;* *E662*
g;			轉到改變表裡第 [count] 個較舊的位置。
			如果 [count] 比所有的較舊的改變位置都多，回到最老的那
			個。
			如果沒有較舊的改變，給出一個錯誤消息。
			(不是動作命令)
			{Vi 無此功能}
			{僅當編譯時加入 |+jumplist| 特性才有效}

							*g,* *E663*
g,			轉到改變表裡第 [count] 個較新的位置。
			和 |g;| 類似，但朝向相反的方向。
			(不是動作命令)
			{Vi 無此功能}
			{僅當編譯時加入 |+jumplist| 特性才有效}

使用次數的時候你向後或向前跳轉到盡可能接近該次數的位置。這樣，你可以用 "999g;"
跳到還能記住的最初的改變所在的位置。改變的最大項目數和跳轉表 |jumplist| 一致。

當兩個可以撤銷的改變在同一行，並且所在的列差小於 'textwidth'，只有後一個會被記
住。這可以避免同一行裡一系列很小的改變，例如 "xxxxx"，在改變表裡佔據很多位置。
如果 'textwidth' 為 0，則使用 'wrapmargin'。如果它也沒有設置，就用固定的數目
79。細節: 考慮到速度的影響，計算用的是字節數而不是字符數 (這只對多字節編碼有意
義)。

請 注意 如果後來有插入和刪除文本，尤其刪除整行的時候，光標位置和當時改變的位置
可能稍有不同。

如果用到 |:keepjumps| 命令修飾符，改變的位置不會被記住。

							*:changes*
:changes		打出改變表。 ">" 字符指示當前的位置。在一個改變之後，
			它在最新的一項之後，這意味著 "g;" 會帶你到最新一項的位
			置。第一列則指示要到該位置需要的次數。例如:

				change line  col text ~
				    3     9    8 bla bla bla
				    2    11   57 foo is a bar
				    1    14   54 最新改變的行
				>

			"3g;" 命令會帶你到第 9 行。這時，":changes" 的結果是:

				change line  col text ~
				>   0     9    8 bla bla bla
				    1    11   57 foo is a bar
				    2    14   54 最新改變的行

			現在你可以用 "g," 到第 11 行，"2g," 到第 14 行。

==============================================================================
9. 其他動作					*various-motions*

							*%*
%			找到本行的光標所在或其後的下一個項目，並跳轉到它的匹
			配。
			|inclusive| 閉動作。
			項目可以是:
			([{}])		小括號或者 (花/方) 括號。
					(這可以用 'matchpairs' 選項改變)
			/* */		C-風格的註釋的開始或結尾
			#if、#ifdef、#else、#elif、#endif
					C 預處理條件宏 (光標在 # 上，或者其後
					沒有 ([{ 的時候)
			要匹配其它的項目可以用 matchit 插件，參見
			|matchit-install|。此插件也可用於跳過註釋中的匹配。

			在 'cpoptions' 包含 "M" 時，|cpo-M| 括號之前的反斜槓被
			忽略。若不然，那麼括號之前的反斜槓的數目很重要。帶偶數
			數目的不能匹配帶奇數數目的。這樣，在 "( \) )" 和 "\( (
			\)" 裡，第一個和最後一個小括號互相匹配。

			如果 'cpoptions' 裡沒有 '%' 字符 |cpo-%|，那麼雙引號裡
			的括號被忽略，除非一行裡的括號數目不對稱，而且該行和前
			一行不以反斜槓結尾。'('、'{'、'['、']'、'}' 和 ')' 也
			被忽略 (單引號裡的括號)。 注意 這對 C 適用，但對 Perl
			就不行。Perl 裡單引號用來括起字符串。

			對註釋中的匹配並無特殊處理。可以用 matchit 插件
			|matchit-install| 或者用引號括起匹配。

			這裡不能用計數，{count}% 跳轉到文件裡百分之 {count} 的
			那行 |N%|。
			在 #if/#else/#endif 上用 % 使該動作面向行。

						*[(*
[(			反向第 [count] 個的未匹配的 '('。
			|exclusive| 開動作。{Vi 無此功能}。

						*[{*
[{			反向第 [count] 個的未匹配的 '{'。
			|exclusive| 開動作。{Vi 無此功能}。

						*])*
])			正向第 [count] 個的未匹配的 ')'。
			|exclusive| 開動作。{Vi 無此功能}。

						*]}*
]}			正向第 [count] 個的未匹配的 '}'。
			|exclusive| 開動作。{Vi 無此功能}。

以上四個命令用於轉到當前代碼塊的開始或者結尾位置。這和在 '('、')'、'{' 或 '}'
上用 "%" 類似，但你可以在代碼塊的任何位置這麼做，這對 C 程序很有用。例如: 在
"case x:" 上用 "[{" 會把你帶回到 switch 語句上。

						*]m*
]m			正向第 [count] 個方法 (method) 的開始處 (適用於 Java
			或類似結構的語言)。如果不在某個方法開始處之前，則跳轉
			到類的開始或結束處。如果光標之後已無 '{'，會有一個錯
			誤。
			|exclusive| 開動作。{Vi 無此功能}。
						*]M*
]M			正向第 [count] 個方法的結束處 (適用於 Java 或類似結構
			的語言)。如果不在某個方法開始處之前，則跳轉到類的開始
			或結束處。如果光標之後已無 '}'，會有一個錯誤。
			|exclusive| 開動作。{Vi 無此功能}。
						*[m*
[m			反向第 [count] 個方法的開始處 (適用於 Java 或類似結構
			的語言)。如果不在某個方法開始處之前，則跳轉到類的開始
			或結束處。如果光標之前已無 '{'，會有一個錯誤。
			|exclusive| 開動作。{Vi 無此功能}。
						*[M*
[M			反向第 [count] 個方法的結束處 (適用於 Java 或類似結構
			的語言)。如果不在某個方法開始處之前，則跳轉到類的開始
			或結束處。如果光標之前已無 '}'，會有一個錯誤。
			|exclusive| 開動作。{Vi 無此功能}。

以上這些命令假設文件包含一個有方法的類定義。類定義用 '{' 和 '}' 包圍，而方法定
義亦然。Java 語言便是如此。源文件看起來應像這樣: >

	// 註釋
	class foo {
		int method_one() {
			body_one();
		}
		int method_two() {
			body_two();
		}
	}
開始，光標在 "body_two()" 上，用 "[m" 會跳轉到 "method_two()" 開始的那個 '{'
(顯然，如果方法定義很長，這就更有用！)。用 "2[m" 會跳轉到 "method_one()" 的開
始處。用 "3[m" 會跳轉到類的開始處。

						*[#*
[#			反向第 [count] 個未匹配的 "#if" 或 "#else"。
			|exclusive| 開動作。{Vi 無此功能}。

						*]#*
]#			正向第 [count] 個未匹配的 "#else" 或 "#endif"。
			|exclusive| 開動作。{Vi 無此功能}。

這兩個命令對有 #if/#else/#endif 結構的 C 程序很有用。它們把你帶到當前行所在的
#if/#else/#endif 的開始或結束處。然後，你可以用 "%" 找到相匹配的行。

						*[star* *[/*
[*  或  [/		反向第 [count] 個 C 註釋的開始 "/*"。
			|exclusive| 開動作。{Vi 無此功能}。

						*]star* *]/*
]*  或  ]/		正向第 [count] 個 C 註釋的結束 "*/"。
			|exclusive| 開動作。{Vi 無此功能}。


						*H*
H			到窗口從頂部 (Home) 算第 [count] 行 (缺省: 窗口的第一
			行) 並停在第一個非空白字符上。|linewise| 行動作。參見
			'startofline' 選項。光標還要根據 'scrolloff' 調整。

						*M*
M			到窗口的中間 (Middle) 一行並停在第一個非空白字符。
			|linewise| 行動作。參見 'startofline' 選項。

						*L*
L			到窗口從底部 (Last) 算第 [count] 行 (缺省: 窗口的最後
			一行) 並停在第一個非空白字符上。|linewise| 行動作。參
			見 'startofline' 選項。光標還要根據 'scrolloff' 調整。

<LeftMouse>		到屏幕上鼠標點擊的位置。|exclusive| 開動作。參見
			|<LeftMouse>|。如果鼠標在狀態行上，則所屬的窗口被激活
			但光標位置不改變。{Vi 無此功能}

 vim:tw=78:ts=8:ft=help:norl:
