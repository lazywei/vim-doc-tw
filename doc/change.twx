*change.txt*    For Vim version 7.3.  最近更新: 2010年8月


		  VIM 參考手冊    by Bram Moolenaar
				譯者: Willis
				http://vimcdoc.sf.net


本文檔描述刪除和修改文本的命令。在本文中，修改文本意味著用單個命令刪除部分文本
並將其替換成其他文本。所有本文描述的命令都可以被撤銷。其中非命令行 (Ex) 的命令
可以用 "." 命令重複。

1. 刪除文本			|deleting|
2. 刪除並插入			|delete-insert|
3. 簡單修改			|simple-change|		*changing*
4. 複雜修改			|complex-change|
   4.1 過濾命令			   |filter|
   4.2 替代			   |:substitute|
   4.3 搜索與替代		   |search-replace|
   4.4 調整製表			   |change-tabs|
5. 複製並移動文本		|copy-move|
6. 文本排版			|formatting|
7. 文本排序			|sorting|

關於插入文本部分，參閱 |insert.txt|。

==============================================================================
1. 刪除文本						*deleting* *E470*

["x]<Del>	或					*<Del>* *x* *dl*
["x]x			刪除 [count] 個光標之下和之後的字符 [到寄存器 x 裡]
			(非 |linewise| 行動作)。和 "dl" 相同。
			<Del> 鍵不使用 [count] 計數。相反，如果有計數，它刪
			除該計數的最後一位。
			如果 <Del> 鍵的操作與你預期的不符，參見 |:fixdel|。關
			於如何刪除換行符 (連接行)，參見 |'whichwrap'|。
			{Vi 不支持 <Del>}

							*X* *dh*
["x]X			刪除 [count] 個光標之前的字符 [到寄存器 x 裡] (非
			|linewise| 行動作)。和 "dh" 相同。另見 |'whichwrap'|。

							*d*
["x]d{motion}		刪除 {motion} 動作跨越的文本 [到寄存器 x 裡]。例外見
			下。

							*dd*
["x]dd			刪除 [count] 行 [到寄存器 x 裡]，|linewise| 行動作。

							*D*
["x]D			刪除光標所在的字符到行尾及其後的 [count]-1 行 [到寄
			存器 x 裡] (非 |linewise| 行動作)。和 "d$" 同義。
			如果 'cpoptions' 裡有 '#' 標誌位，忽略計數。

{Visual}["x]x	或					*v_x* *v_d* *v_<Del>*
{Visual}["x]d   或
{Visual}["x]<Del>	刪除高亮文本 [到寄存器 x 裡] (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

{Visual}["x]CTRL-H   或					*v_CTRL-H* *v_<BS>*
{Visual}["x]<BS>	在選擇模式時，刪除高亮文本 [到寄存器 x 裡]。

{Visual}["x]X	或					*v_X* *v_D* *v_b_D*
{Visual}["x]D		刪除高亮行 [到寄存器 x 裡] (關於 {Visual} 見
			|Visual-mode|)。在可視列塊模式裡，"D" 刪除高亮的文本直
			到行尾。{Vi 無此功能}

						*:d* *:de* *:del* *:delete*
:[range]d[elete] [x]	刪除 [range] 範圍的行 (缺省: 當前行) [到寄存器 x 裡]。

:[range]d[elete] [x] {count}
			從 [range] 指定的範圍開始，刪除 {count} 行 (缺省: 當前
			行 |cmdline-ranges|) [到寄存器 x 裡]。

這些命令刪除文本。你可以用 "." 命令重複它們 (除了 ":d")，也可以撤銷它們。用可
視模式可以刪除文本列塊。關於寄存器的解釋，參見 |registers|。

d{motion} 命令的一個特例: 如果動作不面向行，動作的開始和結束處不在同一行，並且
開始位置之前和結束位置之後只有空白的話，該刪除會轉為行動作。這意味著刪除命令可
能刪除你還想保留的空白行。

如果 'cpoptions' 包括 'E' 標誌位，刪除文本裡的空區域 (例如，在首列上 "d0") 會
報錯。

							*J*
J			連接 [count] 行，但至少包含兩行。刪除縮進，插入不多於
			兩個的空格 (見下)。

							*v_J*
{Visual}J		連接高亮行，但至少包含兩行。刪除縮進，插入不多於兩個的
			空格 (見下)。{Vi 無此功能}。

							*gJ*
gJ			連接 [count] 行，但至少包含兩行。不插入或刪除任何空
			格。{Vi 無此功能}。

							*v_gJ*
{Visual}gJ		連接高亮行，但至少包含兩行。不插入或刪除任何空格。
			{Vi 無此功能}。

							*:j* *:join*
[range]j[oin][!] [flags]
			連接 [range] 範圍的行。和 "J" 相同，但如有 [!] 時，連
			接不插入或刪除任何空格。如果 [range] 包括相同的開始和
			結束行，該命令不做任何事。缺省行為是連接當前行與下一
			行。{Vi: 沒有 !}
			[flags] 部分可參見 |ex-flags|。

:[range]j[oin][!] {count} [flags]
			連接 [range] 開始的 {count} 行 (缺省: 當前行
			|cmdline-ranges|)。和 "J" 相同，但如有 [!] 時，連接不
			插入或刪除任何空格。{Vi: 沒有 !}
			[flags] 部分可參見 |ex-flags|。

這些命令刪除行間的 <EOL>，即換行符，從而實際上使多行連接成一行。除了 ":j" 之
外，你可以重複這些命令或者撤銷之。

這些命令，除了 "gJ" 以外，插入一個空格以代替 <EOL>，除非當前行的結尾已經有空白
或者下一行以 ')' 開始。這些命令，除了 "gJ" 之外，也刪除下一行所有開頭的空白。
如果 'joinspaces' 選項打開，這些命令在 '.'、'!' 或者 '?' 之後插入兩個空格 (但
如果 'cpoptions' 包括 'j' 標誌位，只有在 '.' 之後插入兩個空格)。
'formatoptions' 裡的 'B' 和 'M' 標誌位改變在多字節字符之前或者之後插入空格的行
為 |fo-table|。


==============================================================================
2. 刪除並插入					*delete-insert* *replacing*

							*R*
R			進入替換模式: 每個輸入的字符替代一個現有的字符，從光標
			所在的位置開始。重複輸入的文本 [count] - 1 次。參見
			|Replace-mode| 以瞭解相關詳情。

							*gR*
gR			進入虛擬替換模式: 每個輸入的字符替代屏幕位置一個現有的
			字符。因而，一個 <Tab> 可以一次替換若干個字符。重複輸
			入的文本 [count]-1 次。參見 |Virtual-Replace-mode| 以
			瞭解相關詳情。{僅當編譯時加入 |+vreplace| 特性有效}

							*c*
["x]c{motion}		將 {motion} 跨過的文本刪除 [到寄存器 x 裡] 並開始插
			入。如果 'cpoptions' 包括 'E' 標誌位並且沒有任何文本實
			際需要刪除時 (例如，"cTx" 而光標剛在 'x' 之後的時候)，
			報錯並拒絕開始插入模式 (這與 Vi 兼容)。如果
			'cpoptions' 沒有 'E'，"c" 命令總是啟動插入模式，即使沒
			有文本要刪除也是如此。

							*cc*
["x]cc			刪除 [count] 行 [到寄存器 x 裡] 並開始插入。
			|linewise| 行動作。如果置位 'autoindent'，保留首行的縮
			進。

							*C*
["x]C			從當前光標位置刪除到行尾，再刪除 [count]-1 行 [到寄存
			器 x 裡]，並開始插入。和 c$ 等價 (非 |linewise| 行動
			作)。

							*s*
["x]s			刪除 [count] 個字符 [到寄存器 x 裡]，並開始插入。(s 代
			表替代 (Substitute))。和 "cl" 等價 (非 |linewise| 行動
			作)。

							*S*
["x]S			刪除 [count] 行 [到寄存器 x 裡] 並開始插入。和 "cc" 等
			價 |linewise| 行動作。

{Visual}["x]c	or					*v_c* *v_s*
{Visual}["x]s		刪除高亮文本 [到寄存器 x 裡]，並開始插入 (關於
			{Visual} 參見 |Visual-mode|)。{Vi 無此功能}。

							*v_r*
{Visual}["x]r{char}	把所有高亮的字符替換成 {char}。

							*v_C*
{Visual}["x]C		刪除高亮行 [到寄存器 x 裡] 並開始插入。在可視列塊模式
			下有所不同 |v_b_C|。{Vi 無此功能}。
							*v_S*
{Visual}["x]S		刪除高亮行 [到寄存器 x 裡] 並開始插入 (關於 {Visual}
			參見 |Visual-mode|)。{Vi 無此功能}。
							*v_R*
{Visual}["x]R		現在和 {Visual}["x]S 相同。以後的版本可能會有所改變
			{Vi 無此功能}。

注意:
- 你可以用 <Esc> 退出插入和替換模式。
- 參見 "插入和替換模式" 一節 |mode-ins-repl| 以瞭解其他這些模式下的特殊字符。
- [count] 的效果只有在 Vim 退出插入或替換模式時才會體現。
- 當 'cpoptions' 選項包含 '$' 並且所做的修改在一行之內，Vim 繼續顯示被刪除的文
  本，並在最後一個被刪除的字符之後加上一個 '$'。

關於寄存器的解釋，參見 |registers|。

替換模式和插入模式類似，除了每輸入一個字符同時刪除一個字符以外。如果到達行尾，
Vim 把其後的字符插入在行尾 (和插入模式相同)。在替換模式下，退格鍵恢復原來的文
本 (如果有的話)。(參見 "插入和替換模式" 一節 |mode-ins-repl|)。

						*cw* *cW*
特殊情況: 如果光標在單詞內部，"cw" 和 "cW" 不包含單詞後的空白而只修改到詞尾。
這是因為 Vim 把 "cw" 解釋為 修改-單詞，而單詞並不包括其後的空白。{Vi: 在其後還
有空白的空白字符上 "cw" 只修改第一個空白；這也許是一個漏洞，因為 "dw" 刪除所有
空白；用 'cpoptions' 裡的 'w' 標誌位來設置類似於 Vi 的工作方式}

如果你希望 "cw" 包括單詞之後的空格，使用如下的映射: >
	:map cw dwi
或者，用 "caw" (見 |aw|)。

							*:c* *:ch* *:change*
:{range}c[hange][!]	用另外的文本替換若干文本行。輸入只包含 "." 的行結束替
			換。如果沒有 {range}，該命令只置換當前行。
			加上 [!] 後，在本命令的執行期間切換 'autoindent'。

==============================================================================
3. 簡單修改						*simple-change*

							*r*
r{char}			把光標下的字符換成 {char}。如果 {char} 是 <CR> 或者
			<NL>，則把該字符變成換行符。要換成一個真正的 <CR>，使
			用 CTRL-V <CR>。CTRL-V <NL> 則換成 <Nul>。

			{Vi: CTRL-V <CR> 還是換成換行符。沒有辦法換成 <CR>}。
			如果你給出 [count]，Vim 替換 [count] 個字符為 [count]
			個 {char}。不過如果 {char} 為 <CR> 或者 <NL>，Vim 只插
			入一個換行符: "5r<CR>" 替換五個字符為一個換行符。
			
			當 {char} 為 <CR> 或者 <NL>，Vim 會自動縮進。這和先執
			行刪除要替換的字符在執行 "i<CR><Esc>" 類似。

			{char} 可以輸入二合字母 |digraph-arg|。

			|:lmap| 映射會應用在 {char} 上。插入模式下的 CTRL-^ 命
			令可以切換這一功能 |i_CTRL-^|。

			參見 |utf-8-char-arg| 以瞭解在 'encoding' 為 Unicode
			編碼時如果使用合成用字符。

							*gr*
gr{char}		替換光標下的虛擬字符。替換發生在屏幕位置而不是文件位置
			上。參見 |gR| 和 |Virtual-Replace-mode| 以瞭解相關詳
			情。和 |r| 一樣，可以使用計數。{char} 輸入的方式也相同
			{僅當編譯時加入 |+vreplace| 特性有效}。

						*digraph-arg*
普通模式下的命令，像 |r| 和 |t|，需要一個單字符的參數。如果 'cpo' 不包含 'D'
標誌位，該字符可以用 |digraphs| 那樣的方式輸入: 先鍵入 CTRL-K 然後輸入二合字母
的兩個字符 {僅當編譯時加入 |+digraphs| 特性有效}。

						*case*
下面的命令根據當前的 |locale| 改變字母的大小寫。參見 |:language|。這裡會用到
LC_CTYPE 的值。

							*~*
~			'notildeop' 選項: 切換光標下字符的大小寫，並把光標向右
			移。如果給出 [count]，應用在那麼多數目的字符上。
			{Vi: 沒有 count}

~{motion}		'tildeop' 選項: 切換 {motion} 跨越的文本的大小寫。{Vi:
			~ 不能用作操作符}

							*g~*
g~{motion}		切換 {motion} 跨越的文本的大小寫。{Vi 無此功能}

g~g~							*g~g~* *g~~*
g~~			切換當前行的大小寫。{Vi 無此功能}

							*v_~*
{Visual}~		切換高亮文本的大小寫 (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

							*v_U*
{Visual}U		使高亮文本成為大寫 (關於 {Visual} 見 |Visual-mode|)。
			{Vi 無此功能}

							*gU* *uppercase*
gU{motion}		使 {motion} 跨越的文本成為大寫。{Vi 無此功能}
			例如: >
				:map! <C-F> <Esc>gUiw`]a
<			可以用在插入模式下: 按 CTRL-F 使光標之前的單詞成為大
			寫。這使得輸入大寫單詞很方便，只要輸入小寫單詞再一次轉
			換就行了。


gUgU							*gUgU* *gUU*
gUU			使得當前行成為大寫。{Vi 無此功能}

							*v_u*
{Visual}u		使高亮文本成為小寫 (關於 {Visual} 見 |Visual-mode|)。
			{Vi 無此功能}

							*gu* *lowercase*
gu{motion}		使 {motion} 跨越的文本成為小寫。{Vi 無此功能}

gugu							*gugu* *guu*
guu			使得當前行成為小寫。{Vi 無此功能}

							*g?* *rot13*
g?{motion}		用 Rot13 對 {motion} 跨越的文本進行編碼。{Vi 無此功能}

							*v_g?*
{Visual}g?		用 Rot13 對高亮文本進行編碼 (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

g?g?							*g?g?* *g??*
g??			用 Rot13 對當前行進行編碼。{Vi 無此功能}

要以標題大寫 (title cap) 方式改寫一行，亦即使每個單詞的首字母大寫: >
	:s/\v<(.)(\w*)/\u\1\L\2/g


遞 增 與 遞 減 ~
							*CTRL-A*
CTRL-A			把當前光標之上或之後的數值或者字母加上 [count]。
			{Vi 無此功能}

							*CTRL-X*
CTRL-X			把當前光標之上或之後的數值或者字母減去 [count]。
			{Vi 無此功能}

CTRL-A 和 CTRL-X 命令可用於 (帶符號) 十進制數，無符號八進制和十六進制數以及字
母。這取決於 'nrformats' 選項。
- 當 'nrformats' 包括 "octal" 時，Vim 假設 '0' 開始的數值為八進制，除非該數值
  裡包含 '8' 或 '9'。其他的數值為十進制，並可以在開始帶一個可選的負號。
  如果光標已經在數值上，命令應用於該數值；否則，應用於光標右側的數值。
- 當 'nrformats' 包括 "alpha" 時，Vim 會改變光標之上或之後的字母。這可用於構造
  字母編號的列表。
- 當 'nrformats' 包括 "hex" 時，Vim 假設 '0x' 或者 '0X' 開始的數值為十六進制。
  這個數值最右端的字母決定所產生十六進制數值的大小寫。如果當前數值沒有字母，
  Vim 使用上一次檢測到的大小寫。

對零開頭的數值 (包括八進制和十六進制的)，Vim 盡可能保留相同數量的字符。CTRL-A
在 "0077" 上產生 "0100"，CTRL-X 在 "0x100" 上產生 "0x0ff"。
有一個例外: 在發現某數值以零開始但不是八進制 (包含 '8' 或 '9')，而 'noformats'
卻包含 "octal" 的時候，引導的零會被刪除，以免結果被誤認為八進制。

注意 如果 'nrformats' 包括 "octal"，開頭有零的十進制數會產生錯誤，因為會和八進
制數產生混淆。

CTRL-A 命令在宏命令裡很有用。例如: 使用以下的步驟構造一個數字編號的列表。

1. 建立第一個列表項。確保它以數字開始。
2. qa	     - 用寄存器 'a' 開始記錄
3. Y	     - 抽出這個列表項
4. p	     - 把該項的一個副本放置在下一行上
5. CTRL-A    - 增加計數
6. q	     - 停止記錄
7. <count>@a - 重複抽出、放置和增加計數操作 <count> 次


將 文 本 左 移 或 右 移					*shift-left-right*

							*<*
<{motion}		將 {motion} 跨越的行左移 'shiftwidth' 列。

							*<<*
<<			將 [count] 行左移 'shiftwidth' 列。

							*v_<*
{Visual}[count]<	將高亮行左移 [count] 個 'shiftwidth' 列 (關於 {Visual}
			見 |Visual-mode|)。{Vi 無此功能}

							*>*
 >{motion}		將 {motion} 跨越的行右移 'shiftwidth' 列。

							*>>*
 >>			將 [count] 行右移 'shiftwidth' 列。

							*v_>*
{Visual}[count]>	將高亮行右移 [count] 個 'shiftwidth' 列 (關於 {Visual}
			見 |Visual-mode|)。{Vi 無此功能}

							*:<*
:[range]<		將 [range] 指定的行左移 'shiftwidth' 列。多個 '<' 左移
			多個 'shiftwidth' 列。

:[range]< {count}	左移 [range] 開始的 {count} 行 'shiftwidth' 列 (缺省從
			當前行 |cmdline-ranges|)。多個 '<' 左移多個
			'shiftwidth' 列。

:[range]le[ft] [indent]	左對齊 [range] 指定的行。設置縮進距離為 [indent] (缺省
			為 0)。{Vi 無此功能}

							*:>*
:[range]> [flags]	將 [range] 指定的行右移 'shiftwidth' 列。多個 '>' 右移
			多個 'shiftwidth' 列。
			[flags] 部分可參見 |ex-flags|。

:[range]> {count} [flags]
			右移 [range] 開始的 {count} 行 'shiftwidth' 列 (缺省從
			當前行 |cmdline-ranges| 開始)。多個 '>' 右移多個
			'shiftwidth' 列。
			[flags] 部分可參見 |ex-flags|。

">" 和 "<" 命令可以用來方便地調整程序的縮進。使用 'shiftwidth' 選項設置這些命
令增加或者減少的空白的數量。通常，'shiftwidth' 選項是 8，但你也可以設置為，比
如說，3，使得縮進更小些。如果已經沒有縮進，左移命令會停止。另一方面，右移命令
則不會影響空白行。

如果 'shiftround' 選項打開，縮進距離被取整到 'shiftwidth' 的倍數。

如果 'smartindent' 選項打開，或者 'cindent' 打開並且 'cinkeys' 包含 '#'，右移
不影響 '#' 開始的行 (這些應該是 C 預處理行，它們應該保持在第一列)。

如果 'expandtab' 選項關閉 (這是缺省值)， Vim 盡可能使用 <Tab> 來構成縮進。你可
以用 ">><<" 來把縮進盡可能從空格替換成同樣縮進距離的 <Tab> (如有需要，還有少量
的空格)。如果 'expandtab' 選項打開，Vim 只使用空格。這樣你可以使用 ">><<" 把
<Tab> 替換成空格 (或者可以用 ":retab!")。

要移動一行多個 'shiftwidth' 列，使用可視模式或者 ":" 命令。例如: >
	Vjj4>		右移三行四個縮進位
	:<<<		左移當前行三個縮進位
	:>> 5		右移五行兩個縮進位
	:5>>		右移第五行兩個縮進位

==============================================================================
4. 複雜修改						*complex-change*

4.1 過濾命令						*filter*

過濾程序是一個接受文本作為標準輸入，作某些修改，並把結果放到標準輸出的程序。你
可以用下面的命令把若干文本發送給過濾程序，然後用過濾的輸出結果替換。一個過濾程
序的例子是 "sort"，按字母順序給行排序；還有 "indent"，排版 C 程序文件 (你需要
一個能以過濾程序方式工作的版本，並非所有的版本都可以)。'shell' 選項指定 Vim 使
用的外殼程序，用以執行過濾程序 (另見 'shelltype' 選項)。你可以用 "." 重複過濾
命令。Vim 不會識別 ":!" 命令之後的註釋 (用 '"' 開始)。

							*!*
!{motion}{filter}	將 {motion} 跨越的行用外部程序 {filter} 過濾。

							*!!*
!!{filter}		將 [count] 行用外部程序 {filter} 過濾。

							*v_!*
{Visual}!{filter}	將高亮行用外部程序 {filter} 過濾。(關於 {Visual}
			見 |Visual-mode|)。{Vi 無此功能}

:{range}![!]{filter} [!][arg]				*:range!*
			將 {range} 指定的行用外部程序 {filter} 過濾。Vim 把可
			選的感歎號替換成最後一次使用的命令，並附加上可選的參數
			[arg]。Vim 把過濾命令的輸出保存到臨時文件，並把文
			件內容讀到一個緩衝區裡 |tempfile|。Vim 使用
			'shellredir' 選項把過濾程序的結果重定向到臨時文件。
			不過，如果關閉了 'shelltemp' 選項且可以的話，使用管道
			機制 (Unix 上)。
			如果 'cpoptions' 包含 'R' 標誌位，過濾行裡的位置標記被
			刪除，除非使用了 |:keepmarks| 命令。例如: >
				:keepmarks '<,'>!sort
<			如果過濾後的行數變少，刪去的行裡的位置標記無論如何不會
			保存。

							*=*
={motion}		把 {motion} 跨越的行用 'equalprg' 選項指定的外部程序過
			濾。如果 'equalprg' 選項為空 (缺省)，使用內部的排版機
			制 |C-indenting|。但如果 'indentexpr' 非空，則使用之。
			|indent-expression|。如果 Vim 編譯時不包含內部排版機
			制，作為最後的手段，使用外部的 "indent" 程序。

							*==*
==			和 ={motion} 類似，過濾 [count] 行。

							*v_=*
{Visual}=		和 ={motion} 類似，過濾高亮行。{Vi 無此功能}


						*tempfile* *setuid*
Vim 使用臨時文件來處理過濾、執行比較和用於 tempname()。Unix 上，該文件會放在一
個私人的目錄裡 (只能被當前用戶訪問)，以防堵安全上的漏洞 (例如，符號鏈接攻擊或
文件被其他用戶讀取等)。Vim 退出時，自動刪除該目錄及之下的所有文件。如果 Vim 本
身設置了 setuid 位，這樣或許會有問題。臨時文件由 setuid 用戶擁有，但過濾程序以
原來用戶的權限執行。
MS-DOS 和 OS/2 上，使用以下目錄中首個可用者: $TMP、$TEMP、c:\TMP、c:\TEMP。
Unix 上，使用的目錄依次為: $TMPDIR、/tmp、當前目錄、$HOME。
MS-Windows 上，使用 GetTempFileName() 系統函數。
其它系統上使用 tmpnam() 庫函數。


4.2 替代						*:substitute*
							*:s* *:su*
:[range]s[ubstitute]/{pattern}/{string}/[flags] [count]
			對 [range] 指定的行把 {pattern} 的匹配替代成
			{string}。
			關於 {pattern}，參見 |pattern|。
			{string} 可以是按字面意義的，也可以包含特殊字符。
			參見 |sub-replace-special|。
			如果不指定 [range] 和 [count]，僅在當前行進行替代。
			如果指定 [count]，在 [range] 最後一行開始的 [count]
			行進行替代。如果不指定 [range] ，則從當前行開始。
			另見 |cmdline-ranges|。
			關於 [flags]，參見 |:s_flags|。

:[range]s[ubstitute] [flags] [count]
:[range]&[&][flags] [count]					*:&*
			使用最後一次 :substitute 相同的模式和替代字符串，但不
			包括相同的標誌位。你可以另加 [flags] (見 |:s_flags|)。
			注意 在 ":substitute" 之後，不能使用 '&' 標誌位。它被
			認為是一個模式分隔符。
			":substitute" 和 'c'、'g' 和 'r' 標誌位之間的空格不是
			必需的，但在腳本裡為了避免混淆起見，最好保留它。

:[range]~[&][flags] [count]					*:~*
			使用最後一次 :substitute 相同的替代字符串，但使用最近
			使用的搜索模式作為匹配模式。這類似於 ":&r"。
			關於 [flags]，參見 |:s_flags|。

								*&*
&			等價於 ":s" (重複上次的 substitute)。注意 這裡不記住標
			志位，所以實際工作方式可能不盡相同。你可以用 ":&&" 來
			保持相同的標誌位。

								*g&*
g&			等價於 ":%s//~/&" (在所有行上重複上次的 substitute，並
			使用相同的標誌位)。
			助記: 全局 (global) 替代 (substitute)。{Vi 無此功能}

						*:snomagic* *:sno*
:[range]sno[magic] ...	和 ":substitute" 相同，但總使用 'nomagic'。
			{Vi 無此功能}

						*:smagic* *:sm*
:[range]sm[agic] ...	和 ":substitute" 相同，但總使用 'magic'。
			{Vi 無此功能}

							*:s_flags*
你可以在 substitute 命令裡使用以下標誌位:

[&]	必須是首個使用的標誌位: 保留和上次 substitute 相同的標誌位。例如: >
		:&&
		:s/this/that/&
<	注意 ":s" 和 ":&" 不保留標誌位。
	{Vi 無此功能}

[c]	確認每個替代。Vim 高亮匹配的字符串 (如果使用了 |hl-IncSearch|)。你可以
	輸入:						*:s_c*
	    'y'	    來替代這次匹配
	    'l'	    來替代這次匹配並退出 (助記: "last"，最後)
	    'n'	    來跳過這次匹配
	    <Esc>   來退出替代過程
	    'a'	    來替代這次和以後所有的匹配
	    'q'	    來退出替代過程 {Vi 無此功能}
	    CTRL-E  來上卷屏幕 {Vi 無此功能，僅當編譯時加入 |+insert_expand| 特
			性才有此功能}
	    CTRL-Y  來下卷屏幕 {Vi 無此功能，僅當編譯時加入 |+insert_expand| 特
			性才有此功能}
	如果 'edcompatible' 選項打開，Vim 記住 [c] 標誌位並在每次使用它時切換
	是否確認，但在給出一個新的匹配模式時復位。
	{Vi 沒有高亮匹配部分和除了 'y' 和 'n' 之外的選擇}

[e]     如果模式搜索不成功，不給出錯誤信息。因為沒產生錯誤，映射的過程得以繼
	續。這主要用來防止在映射執行過程的無匹配 ("No match") 錯誤中斷映射。
	不過，Vim 不會抑制以下的錯誤信息:
		Regular expressions can't be delimited by letters (正規表達式
			不能以字母分隔)
		\ should be followed by /, ? or & (\ 必須後面跟 /、? 或者 &)
		No previous substitute regular expression (沒有上次的替代正規
			表達式)
		Trailing characters (結尾有多餘的字符)
		Interrupted (中斷)
	{Vi 無此功能}

[g]	對行內所有的匹配進行替代。如果沒有這個參數，替代只對每行的第一個匹配進
	行。如果 'edcompatible' 選項打開，Vim 記住這個標誌並在你每次使用該標誌
	時切換，但在給出一個新的匹配模式時復位。如果 'gdefault' 選項打開，這個
	標誌缺省打開，而 [g] 參數關閉之。

[i]	忽略模式的大小寫。不使用 'ignorecase' 和 'smartcase' 選項。
	{Vi 無此功能}

[I]	不忽略模式的大小寫。不使用 'ignorecase' 和 'smartcase' 選項。
	{Vi 無此功能}

[n]	報告匹配的次數，並不實際進行替代。忽略 [c] 標誌位。匹配報告的發生就像
	'report' 總是為零那樣。可用於 |count-items|。

[p]	顯示包含最後一次替代的行。

[#]	類似 [p]，且在前面加上行號。

[l]	類似 [p]，但顯示的方式類似於 |:list|。

[r]	僅對於不帶參數的 ":&" 和 ":s" 有用。":&r" 和 ":~" 工作的方式相同: 如果
	匹配模式為空，使用上一次使用的搜索模式，而不是上一次的 substitute 或者
	":global" 所使用的模式。如果最近一次使用搜索的命令就是 substitute 或者
	":global"，那就沒有區別了。如果最近的命令的是 "/" 那樣的搜索命令，使用
	那個命令的搜索模式。
	帶參數的 ":s"，則不論如何，總是如此: >
		:s/blue/red/
		/green
		:s//red/   或  :~   或  :&r
<	最後的命令把 "green" 替代成 "red"。 >
		:s/blue/red/
		/green
		:&
<	最後的命令把 "blue" 替代成 "red"。
	{Vi 無此功能}

注意這裡沒有標誌位可以改變模式的 "魔術性" (magicness)。你可以用別的命令或 |\v|
之類。原因是標誌位只能在跳過模式之後才能找到，而要跳過模式，必須先知道模式的
"魔術性"。第二十二條軍規！

如果 substitute 命令所用的 {pattern} 為空，該命令使用上次的 substitute 或者
":global" 命令用過的模式。如果有 [r] 標誌位，該命令使用上次 substitute、
":global" 或者搜索命令使用的模式。

如果 {string} 省略，替代命令假定它為空。這樣就把匹配文本刪除了。這時，
{pattern} 之後的分隔符也可省略。例如: >
	:%s/TESTING
刪除所有行上的 "TESTING"，但每行只刪一個。

為了和 Vi 的兼容性，有兩個例外:
"\/{string}/" 和 "\?{string}?" 等同於 "//{string}/r"。
"\&{string}&" 等同於 "//{string}/"。
							*E146*
除了用 '/' 來包圍模式和替代字符串之外，你可以使用任何其他的單字節字符，除了
字母、數字、'\'、'"' 或 '|' 之外。這可以用於 '/' 是搜索模式或替代字符串一部
分的場合。例如: >
	:s+/+//+

關於模式的定義，參見 |pattern|。在可視列塊模式下，如果模式中使用了 |/\%V|，那
麼替代只在列塊內進行，否則它作用於整行。

					*sub-replace-special* *:s\=*
{string} 以 "\=" 開始時，它被作為表達式來執行，參見 |sub-replace-expression|。
你可以在這裡使用任何特殊字符。否則，{string} 字符串裡的字符有如下的特殊含義:
								*:s%*
如果 {string} 等於 "%"，且 'cpoptions' 選項包含 '/'，重複使用上次替代命令的
{string}。|cpo-/|

magic	nomagic	  動作    ~
  &	  \&	  替代為完整的匹配				     *s/\&*
 \&	   &	  替代為 &
      \0	  替代為完整的匹配			 	   *\0* *s/\0*
      \1	  替代為匹配的第一個 () 裡面的內容		     *s/\1*
      \2	  替代為匹配的第二個 () 裡面的內容		     *s/\2*
      ..	  ..						     *s/\3*
      \9	  替代為匹配的第九個 () 裡面的內容		     *s/\9*
  ~	  \~	  替代為前一個 substitute 的替代字符串		     *s~*
 \~	   ~	  替代為 ~					     *s/\~*
      \u	  下一個字符成為大寫				     *s/\u*
      \U	  其後字符成為大寫，直到 \E 出現		     *s/\U*
      \l	  下一個字符成為小寫				     *s/\l*
      \L	  其後字符成為小寫，直到 \E 出現		     *s/\L*
      \e	  結束 \u、\U、\l 和 \L (注意: 不是 <Esc>!)	     *s/\e*
      \E	  結束 \u、\U、\l 和 \L				     *s/\E*
      <CR>	  把該行在此位置一分為二
		  (<CR> 以 CTRL-V <Enter> 方式輸入)		     *s<CR>*
      \r	  同上						     *s/\r*
      \<CR>	  插入一個回車 (CTRL-M)
		  (<CR> 以 CTRL-V <Enter> 方式輸入)		     *s/\<CR>*
      \n	  插入一個 <NL> (文件裡的 <NUL>)
		  (此處並不是換行)				     *s/\n*
      \b	  插入一個 <BS>					     *s/\b*
      \t	  插入一個 <Tab>				     *s/\t*
      \\	  插入單個反斜槓				     *s/\\*
      \x	  其中 x 是上面沒提到的任何一個字符:
		  保留作將來的擴展

示例: >
  :s/a\|b/xxx\0xxx/g		 修改 "a b"	 為 "xxxaxxx xxxbxxx"
  :s/\([abc]\)\([efg]\)/\2\1/g	 修改 "af fa bg" 為 "fa fa gb"
  :s/abcde/abc^Mde/		 修改 "abcde"    為 "abc"、"de" (兩行)
  :s/$/\^M/			 修改 "abcde"    為 "abcde^M"
  :s/\w\+/\u\0/g		 修改 "bla bla"  為 "Bla Bla"

注意: 在以前的版本裡，CTRL-V 以特殊的方式處理。因為和 Vi 不兼容，該功能已經被
去掉了，現在用反斜槓來替代。

命令		文本	結果 ~
:s/aa/a^Ma/	aa	a<line-break>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<line-break>a

(你需要輸入 CTRL-V <CR> 來得到這裡的 ^M)

"\1"，"\2" 等裡的數字是基於模式裡 "\(" 出現的順序 (從左到右)。如果一個括號組匹
配多次，最後一次的匹配被使用在 "\1"，"2" 等裡。例如: >
  :s/\(\(a[a-d] \)*\)/\2/      修改 "aa ab x" 為 "ab x"

如果括號和 '|' 組合使用，如 \([ab]\)\|\([cd]\)，兩者有一個會不匹配，所以 \1 或
者 \2 會為空。例如: >
  :s/\([ab]\)\|\([cd]\)/\1x/g   修改 "a b c d" 為 "ax bx x x"
<

以表達式方式替代				*sub-replace-expression*
						*sub-replace-\=*
當替代字符串以 "\=" 開始時，其餘部分被解釋為一個表達式。該功能不能遞歸調用。出
現在該表達式裡面的 substitute() 函數不能使用 "\=" 作為替代字符串。

除了 "<CR>"、"\<CR>" 和 "\\" 以外，|sub-replace-special| 提到的字符的特殊含義
這裡不適用。這樣，表達式裡應出現的反斜槓須加倍出現，要插入的 <CR> 之前要加上反
斜槓，如果你想分行，則使用不帶反斜槓的 <CR>。

為了方便起見，<NL> 字符也被用作換行符。在這之前加上反斜槓得到一個真正的 <NL>
字符 (在文件裡成為 NUL)。

如果結果是 |List|，連接其中的項目並以換行符分隔。這樣，每個項目單獨成為一行，
當然本身就包含換行符的除外。

完整的匹配可以用 "submatch(0)" 得到。首個括號裡的匹配可以用 "submatch(1)"，余
者類似。

小心: 分隔符不能出現在表達式裡！可以考慮使用 "@" 或者 ":" 那樣的字符。執行結果
裡出現分隔符不成問題。

例如: >
	:s@\n@\="\r" . expand("$HOME") . "\r"@
把換行符替代為包含 $HOME 值的一個新行。 >

	s/E/\="\<Char-0x20ac>"/g
把所有的 'E' 字符替代為歐元符號。詳見 |<Char->|。


4.3 搜索與替代						*search-replace*

							*:pro* *:promptfind*
:promptf[ind] [string]
			彈出搜索對話框。如果給出 [string]，它被用作初始的搜索
			字符串。
			{僅適用於 Win32、Motif 和 GTK GUI 環境}

						*:promptr* *:promptrepl*
:promptr[epl] [string]
			彈出搜索/替代對話框。如果給出 [string]，它被用作初始的
			搜索字符串。
			{僅適用於 Win32、Motif 和 GTK GUI 環境}

4.4 改變製表						*change-tabs*
							*:ret* *:retab*
:[range]ret[ab][!] [new_tabstop]
			把所有包含 <Tab> 的空白序列替代成由新的製表位
			[new_tabstop] 確定的空白序列。如果你不指定新的製表位，
			或者它為 0，Vim 使用原來的製表位 'tabstop'。
			已有的 Tab 的寬度總是用 'tabstop' 的當前值來計算。
			如果有 !，Vim 也在合適的時候，把只包含正常空格的字符串
			換成 Tab。
			如果置位了 'expandtab'，Vim 把所有的 Tab 換成相當的空
			格。
			該命令把 'tabstop' 設為新值。如果按照缺省的情況，在全
			文件上進行處理，視覺上應該不會有任何改變。
			小心: 該命令修改 C 程序中的字符串裡的任何 <Tab> 字符。
			要避免這一點，用 "\t" (無論如何，應該養成這個好的習
			慣)。
			":retab!" 也把空格序列換成 <Tab>，這可能會使 printf()
			引起混淆。
			{Vi 無此功能，僅在編譯時加入 |+ex_extra| 特性才有效}

							*retab-example*
下面的例子使用自動命令和 ":retab" 來編輯使用製表位為 8 的文件，但在編輯時製表
位設置為 4。警告: 字符串裡的空格會被改變。另見 'softtabstop' 選項。 >

  :auto BufReadPost	*.xx	retab! 4
  :auto BufWritePre	*.xx	retab! 8
  :auto BufWritePost	*.xx	retab! 4
  :auto BufNewFile	*.xx	set ts=4

==============================================================================
5. 複製並移動文本					*copy-move*

							*quote*
"{a-zA-Z0-9.%#:-"}	指定下次的刪除、抽出和放置命令使用的寄存器
			{a-zA-Z0-9.%#:-"} (大寫字符使得刪除和抽出命令附加到該
			寄存器) ({.%#:} 只能用於放置命令)。

							*:reg* *:registers*
:reg[isters]		顯示所有編號和命名寄存器的內容。但不列出用於 |:redir| 
			目的地的寄存器。
			{Vi 無此功能}

:reg[isters] {arg}	顯示 {arg} 裡提到的編號和命名寄存器的內容。例如: >
				:dis 1a
<			顯示寄存器 '1' 和 'a'。{arg} 裡可以用空格。
			{Vi 無此功能}

							*:di* *:display*
:di[splay] [arg]	和 :registers 相同。{Vi 無此功能}

							*y* *yank*
["x]y{motion}		抽出 {motion} 跨越的文本 [到寄存器 x]。如果沒有字符被
			抽出 (例如，在第一列執行 "y0") 並且 'cpoptions' 裡包括
			'E' 標誌位，這是一個錯誤。

							*yy*
["x]yy			抽出 [count] 行 [到寄存器 x] |linewise| 行動作。

							*Y*
["x]Y			抽出 [count] 行 [到寄存器 x] (等同於 yy，|linewise| 行
			動作)。如果你想要 "Y" 執行從光標到行尾的操作 (更合乎邏
			輯，但是與 Vi 不兼容)，用 ":map Y y$"。

							*v_y*
{Visual}["x]y		抽出高亮文本 [到寄存器 x] (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

							*v_Y*
{Visual}["x]Y		抽出高亮行 [到寄存器 x] (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

							*:y* *:yank*
:[range]y[ank] [x]	抽出 [range] 所指定的行 [到寄存器 x]。

:[range]y[ank] [x] {count}
			從 [range] 的最後一行開始 (缺省: 當前行
			|cmdline-ranges|) 抽出 {count} 行 [到寄存器 x]。

							*p* *put* *E353*
["x]p			放置文本 [從寄存器 x] 在光標之後 [count] 次。{Vi: 沒有
			計數}

							*P*
["x]P			放置文本 [從寄存器 x] 在光標之前 [count] 次。{Vi: 沒有
			計數}

							*<MiddleMouse>*
["x]<MiddleMouse>	從一個寄存器放置文本在光標之前 [count] 次。除非另外指
			定，否則用 "* 寄存器。
			光標停留在新文本的尾部。
			只有在 'mouse' 包含 'n' 或者 'a' 時鼠標才會工作。
			{Vi 無此功能}
			如果你有滾輪鼠標而且經常不小心粘貼了文本，你可以使用以
			下映射來關閉鼠標中鍵粘貼的功能: >
				:map <MiddleMouse> <Nop>
				:imap <MiddleMouse> <Nop>
<			你也許還想要關閉多鍵擊的功能。參見 |double-click|。

							*gp*
["x]gp			如同 "p"，但光標停留在新文本之後。{Vi 無此功能}

							*gP*
["x]gP			如同 "P"，但光標停留在新文本之後。{Vi 無此功能}

							*:pu* *:put*
:[line]pu[t] [x]	放置文本 [從寄存器 x] 在行號 [line] (缺省為當前行) 之
			後。它總是 |linewise| 行動作，因而這個命令可以用來把抽
			出的塊放置在新行上。
			光標停留在新行末行的第一個非空白處。
			寄存器也可以是 '='，跟隨一個可選的表達式。表達式繼續到
			該命令結束為止。你需要在 '|' 和 '"' 字符前加上反斜槓不
			讓它們終止你的命令行。例如: >
				:put ='path' . \",/test\"
<			如果 '=' 之後沒有表達式，Vim 使用前一個表達式。用
			":dis =" 你可以看到它。

:[line]pu[t]! [x]	放置文本 [從寄存器 x] 在行號 [line] (缺省為當前行) 之
			前。

["x]]p		    或					*]p* *]<MiddleMouse>*
["x]]<MiddleMouse>	類似 "p"，但調整當前行的縮進。只有在 'mouse' 包含 'n'
			或者 'a' 時鼠標才會工作。{Vi 無此功能}

["x][P		    或					*[P*
["x]]P		    或					*]P*
["x][p		    或					*[p* *[<MiddleMouse>*
["x][<MiddleMouse>	類似 "P"，但調整當前行的縮進。只有在 'mouse' 包含 'n'
			或者 'a' 時鼠標才會工作。{Vi 無此功能}

你可以用這些命令把文本從一個地方複製到另一個地方。首先，把文本用抽出、刪除或者
修改命令取到一個寄存器裡，然後用放置命令把寄存器的內容插入。你可以用這些命令把
文本從一個文件移動到另一個文件，因為 Vim 在切換緩衝區時保留所有的寄存器
(CTRL-^ 命令可用來快捷地切換文件)。

				*linewise-register* *characterwise-register*
除了 :put 以外，你可以用 "." 重複放置命令，你也可以撤銷它們。如果保存到寄存器
文本的命令是 |linewise| 行動作，Vim 把文本插入在光標所在的行之下 ("p") 或之上
("P")。不然，Vim 把文本插入在光標的之後 ("p") 或之前 ("P")。":put" 命令使得
Vim 總是把文本放在下一行。你可以用命令序列 "xp" 來交換兩個字母。你可以用 "ddp"
命令序列來交換兩行。你還可以用 "deep" 命令交換兩個單詞 (光標在第一個單詞之前的
空白上)。你更可以在放置命令之後用 "']" 或者 "`]" 命令把光標移動到插入文本之
後，或者用 "'[" 或 "`[" 把光標移動到文本的開始處。

						*put-Visual-mode* *v_p* *v_P*
在可視模式下使用如 |p| 或者 |P| 之類的放置命令時，Vim 試圖把選擇的文本替換成寄
存器的內容。是否工作如你所願決定於選擇的類型和寄存器裡文本的類型。對於列塊選擇
而言，它也決定於列塊的大小，和頭尾是否在已存在的字符上。(實現細節: 實際上，它
先把寄存器的內容放到選擇區之後，再刪除選擇區的內容。)
前次選擇的文本被放在無名寄存器中。如果希望把相同的文本重複放入可視選擇區多次，
請選用其它寄存器。例如，先抽出要複製的文本，再可視化選擇要替換的文本，然後使用
"0p。重複任意多次均可，而每次無名寄存器都會被改變。

							*blockwise-register*
如果你使用面向列塊的可視模式命令把文本存到寄存器裡，文本列塊會被插入在當前和其
後的行的當前列之前 ("P") 或之後 ("p")。Vim 使得整個文本列塊從同一列開始。這樣，
插入的文本看上去和抽出或刪除時看起來一樣。為了使之可能，Vim 可能需要把一些
<Tab> 字符替換成空格。不過，如果列塊的寬度不是 <Tab> 寬度的整數倍並且插入列塊
之後文本裡包含 <Tab> 的時候，那些文本可能就不會那麼整齊。

注意 在一個面向字符的抽出命令之後，Vim 把光標停留在最接近緩衝區開頭的第一個被
抽出的字符之上。這意味著 "yl" 不會移動光標，但是 "yh" 把光標向左移一格。
邏輯:		在 Vi 裡 "y" 命令跟一個反向的動作有時不會把光標移動到第一個被
		抽出的字符之上，因為屏幕沒有刷新。Vim 符合 Posix 的規範，總是
		把光標移動到第一個字符之上。
在一個面向行的抽出命令之後，光標放在第一行上，但是列保持不變，所以不必然在第一
個抽出的字符上。

共有九種類型的寄存器:					*registers* *E354*
1. 無名寄存器 ""
2. 10 個編號寄存器 "0 到 "9
3. 行內刪除寄存器 "-
4. 26 個命名的寄存器 "a 到 "z 或者 "A 到 "Z
5. 四個只讀寄存器 ":、".、"% 和 "#
6. 表達式寄存器 "=
7. 選擇和拖放寄存器 "*、"+ 和 "~ 
8. 黑洞寄存器寄存器 "_
9. 最近搜索模式寄存器 "/

1. 無名寄存器 ""				*quote_quote* *quotequote*
用 "d"、"c"、"s"、"x" 等命令刪除或者用 "y" 等抽出命令複製的文本都被 Vim 用來填
充該寄存器，不管是否用到別的專門寄存器 (例如 "xdd)。這就好像無名寄存器是指向最
近使用的那個寄存器的指針一樣。使用大寫寄存器進行添加時，無名寄存器包含和命名寄
存器相同的文本。'_' 寄存器是一個特例。"_dd 不把刪除的文本存在任何寄存器裡。
不指定寄存器的放置命令 (p 或 P) 使用無名寄存器的內容。你也可以用 '"' 作為名字
來訪問該寄存器。這意味著要輸入兩個連續的雙引號。寫入 "" 寄存器將實際寫到寄存器
"0 上。{Vi: 寄存器內容在更換文件時丟失，沒有 '"'}

2. 編號寄存器 "0 到 "9			*quote_number* *quote0*	*quote1*
					*quote2* *quote3* *quote4* *quote9*
Vim 把抽出和刪除命令的文本保存在這些寄存器裡。
   編號寄存器 0 包含最近抽出的文本，除非該命令用 ["x] 指定了別的寄存器。
   編號寄存器 1 包含了最近刪除或者修改的文本，除非該命令用 ["x] 指定了別的寄存
器或者該文本小於一行 (該情況下使用行內刪除寄存器)。以下移動命令在應用刪除操作
符時例外: |%|、|(|、 |)|、|`|、|/|、|?|、|n|、|N|、|{| 和 |}|。這時，總是使用
寄存器 "1 (為了和 Vi 兼容)。如果文本小於一行，同時使用 "- 寄存器。
   每來一次新的刪除和修改，Vim 把前一次的寄存器 1 的內容複製到寄存器 2，2 到
3，依此類推。而寄存器 9 的內容就丟失了。
{Vi: 編號寄存器的內容在更換文件時丟失；寄存器 0 不存在}

3. 行內刪除寄存器 "-					*quote_-* *quote-*
該寄存器保存刪除不到一行內容的命令的文本，除非該命令用 ["x] 指定了寄存器。
{Vi 無此功能}

4. 命名寄存器 "a 到 "z 或者 "A 到 "Z			*quote_alpha* *quotea*
Vim 只有在你指定的時候才使用這些寄存器。指定為小寫字母時替換原來的內容，指定為
大寫字母時附加到原來的內容。如果 'cpoptions' 裡有 '>' 標誌位，在附加文本前插入
一個換行符。


5. 只讀寄存器 ":、".、"% 和 "#
它們是 '%'、'#'、':' 和 '.'。你只能在 "p"、"P"、":put" 命令和 CTRL-R 的時候使
用它們。{Vi 無此功能}
						*quote_.* *quote.* *E29*
	".	包含最近插入的文本 (和插入模式命令 CTRL-A 和 CTRL-@ 插入的一
		樣)。注意: 它不適用於 CTRL-R 在命令行上的操作。它的工作方式稍
		有不同，例如，文本是被插入而不是放置的 ('textwidth' 和其它選項
		影響插入的內容)。
							*quote_%* *quote%*
	"%	包含當前文件名。
							*quote_#* *quote#*
	"#	包含輪換文件名。
						*quote_:* *quote:* *E30*
	":	包含最近執行過的命令行。例如: 用 "@:" 重複上次執行過的命令行命
		令。只有當一個命令行中至少一個字符是鍵入的，該寄存器才會保存命
		令行的內容。所以，如果命令行完全來自映射，該寄存器保持不變。
		{僅當編譯時加入 |+cmdline_hist| 特性才有效}

6. 表達式寄存器 "=				*quote_=* *quote=* *@=*
其實並沒有這麼一個寄存器可以儲存文本，但是這是用來在使用寄存器的命令中使用表達
式的一個方式。表達式寄存器是只讀的，你不能把文本放置其中。在 '=' 之後，光標移
到命令行上，這時你可以輸入任何的表達式 (見 |expression|)。所有普通的命令行編輯
命令都可以使用，還有一個表達式專門的歷史表。當你按回車結束命令行時，Vim 計算表
達式的結果。如果你用 <Esc> 結束，Vim 終止表達式。如果你不輸入表達式，Vim 使用
最近的表達式 (和 "/" 命令的處理相似)。

表達式的計算結果必須是一個字符串。數值結果會自動轉化為字符串。對 "p" 和 ":put"
命令而言，浮點數結果也會被轉化為字符串。如果結果為列表，每個成員被轉成字符串，
然後被單獨放在一行上。字典、函數引用類型的結果則產生錯誤信息 (通過 string() 轉
化)。

如果 "= 寄存器被 "p" 命令使用，該字符串會在 <NL> 字符處斷開。如果該字符串以
<NL> 結尾，則它被視為一個面向行的寄存器。{Vi 無此功能}

7. 選擇和拖放寄存器 "*、"+ 和 "~ 
用這些寄存器來保存和取得 GUI 界面選擇的文本。參見 |quotestar| 和 |quoteplus|。
如果剪貼板不存在或者不工作，使用無名寄存器。Unix 上，僅當 |+xterm_clipboard|
特性存在時剪貼板才可用。{Vi 無此功能}

注意 "* 和 "+ 在 X11 系統上有分別。關於該差別的解釋，參見 |x11-selection|。在
MS-Windows 上，"* 和 "+ 的使用實際上是等價的，可見 |gui-clipboard|。

						*quote_~* *quote~* *<Drop>*
只讀的 "~ 寄存器保存最近一次拖放操作放下的文本。如果有什麼東西被放到 Vim 上，
"~ 寄存器被填充，<Drop> 虛擬鍵被激活。如果你需要，你可以重定義該鍵的映射；缺省
的動作 (適用於所有模式) 是把 "~ 寄存器的內容插入到當前光標位置。{Vi 無此功能}
{僅當編譯時加入 |+dnd| 特性才有效，當前只適用於 GTK GUI 版本}

注意: "~ 寄存器僅用於在 Vim 上拖放普通文本。拖放 URI 列表在內部處理。

8. 黑洞寄存器 "_				*quote_*
當寫到這個寄存器時，什麼都不會發生。這可以用來刪除文本，而不影響任何正常的寄存
器。從該寄存器讀時，什麼都不會返回。{Vi 無此功能}

9. 最近搜索模式寄存器	"/			*quote_/* *quote/*
含有最近搜索的模式。它被 "n" 和 'hlsearch' 使用。可以用 ":let" 來修改。你可以
改變它使得 'hlsearch' 不經過實際的搜索直接高亮某些匹配。你不能把抽出或者刪除命
令的內容放到該寄存器上。搜索方向則可從 |v:searchforward| 得到。
注意 從函數返回時該值被復原 |function-search-undo|。
{Vi 無此功能}

							*@/*
你可以用 ":let" 命令寫到一個寄存器 |:let-@|。例如: >
	:let @/ = "the"

如果你用放置命令而不指定寄存器，Vim 使用上次填充的寄存器 (這也是無名寄存器的內
容)。如果你弄糊塗了，用 ":dis" 命令看看 Vim 會放置什麼內容 (該命令顯示所有的有
名和無名的寄存器；無名寄存器被標為 '"')。

下面三個命令總是針對整行工作。

:[range]co[py] {address}				*:co* *:copy*
			把 [range] 指定的行複製到 {address} 給出的行之下。

							*:t*
:t			和 :copy 等價。

:[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			把 [range] 指定的行移動到 {address} 給出的行之下。

==============================================================================
6. 文本排版						*formatting*

:[range]ce[nter] [width]				*:ce* *:center*
			在 [range] 指定範圍的行和 [width] 限定的列 (缺省為
			'textwidth'，如其為 0，則取 80) 範圍內的文本居中對齊。
			{Vi 無此功能}
			只有在編譯時加入 |+ex_extra| 特性時才有此功能。

:[range]ri[ght] [width]					*:ri* *:right*
			在 [range] 指定範圍的行和 [width] 限定的列 (缺省為
			'textwidth'，如其為 0，則取 80) 範圍內的文本靠右對齊。
			{Vi 無此功能}
			只有在編譯時加入 |+ex_extra| 特性時才有此功能。

							*:le* *:left*
:[range]le[ft] [indent]
			在 [range] 指定範圍的行的文本靠左對齊。其縮進的距離可
			由 [indent] 設置 (缺省為 0)。
			{Vi 無此功能}

							*gq*
gq{motion}		對 {motion} 動作跨越的行進行排版。
			排版使用如下三種方式之一:
			1. 如果 'formatexpr' 不為空，計算該表達式。每個緩衝區
			   的值可以不同。
			2. 如果 'formatprg' 不為空，使用外部程序。
			3. 否則，使用內部排版機制。

			第三種方式使用 'textwidth' 選項控制所有待排版行的行寬
			(見下)。
			如果 'textwidth' 選項為 0，則排版行寬設為屏幕的寬度
			(但最大寬度不超過 79)。
			'formatoptions' 選項控制排版的方式 |fo-table|。
			光標停留在排版行末行的第一個非空白處。
			注意: "Q" 命令以前執行此項功能。如果你還想繼續用 "Q"
			來排版，執行如下映射命令: >
				:nnoremap Q gq

gqgq							*gqgq* *gqq*
gqq			排版當前行。如帶計數排版相應多行。{Vi 無此功能}

							*v_gq*
{Visual}gq		排版高亮文本 ({Visual} 的部分參見 |Visual-mode|)。
			{Vi 無此功能}

							*gw*
gw{motion}		對 {motion} 動作跨越的行進行排版。和 |gq| 類似，但排版
			後光標恢復原位。而且不使用 'formatprg' 和 'formatexpr'
			選項。
			{Vi 無此功能}

gwgw							*gwgw* *gww*
gww			對當前行排版，其它和 "gw" 類同。{Vi 無此功能}

							*v_gw*
{Visual}gw		排版高亮文本，其它和 "gw" 類同。({Visual} 可見
			|Visual-mode|)。{Vi 無此功能}

例如: 要排版當前段落，可用: 					*gqap*  >
	gqap

"gq" 命令後，光標隨著指定的移動命令移動。這使得用 "." 進行連續排版成為可能。例
如，"gqj" (對當前行和下一行排版) 和 "gq}" (排版到段落尾) 便可如此。注意: 如果
設置了 'formatprg'，"gq" 把光標留在排版後的首行 (如同過濾命令那般)。

如果你想對當前段落排版後留在原來的位置，可用: >
	gwap
如果你想使段落自動排版，可以在 'formatoptions' 裡加入 'a' 標誌位。參見
|auto-format|。

如果 'autoindent' 選項打開，Vim 用首行的縮進距離排版其後的所有行。

排版不會改變空行 (但會改變只有空白字符的行！)。

如果有連接行的操作，應用 'joinspaces' 選項。

你可以設置 'formatexpr' 選項為某表達式或設置 'formatprg' 選項為外部程序名，Vim
會用之進行文本排版。'textwidth' 等選項對外部程序的排版不起作用。

							*right-justify*
Vim 沒有靠右控制對齊 (right justify) 文本的命令。你可以用 "par" 這樣的外部命令
來實現 (例如， "!}par" 對到段落尾的文本排版)，或者設置 'formatprg' 為 "par"。

							*format-comments*
用戶手冊的 |30.6| 一節給出註釋排版的總覽。

Vim 可以自動對註釋的插入和排版進行特殊處理。Vim 把以特定字符串開頭 (忽略空白) 
的行識別為註釋。以下是三種不同類型的註釋:

- 在每行的開頭都出現的註釋字符串。例如，外殼腳本使用的註釋行都以 "#" 開頭。
- 只在首行出現的註釋字符串。使用連字符 "-" 的本列表就是這樣的一個例子，
- 由三部分組成的註釋，包括起始字符串，結尾字符串，和兩者之間可選的行的起始字符
  串。三種字符串可分別指定。如下 C 風格的註釋就是如此:
	/*
	 * this is a C comment
	 */

'comments' 選項是一個由逗號分隔的列表。每個部分定義一種類型的註釋字符串。每個
部分的組成方式是:
	{flags}:{string}

{string} 是必須出現的字符串 (不作轉義)。

{flags}:
  n	可嵌套的註釋: 允許多個部分間的嵌套。例如，'comments' 為 "n:),n:>"。則
	以 "> ) >" 開始的行視為註釋。

  b	在 {string} 之後必須有空白字符 (<Space>、<Tab> 或 <EOL>)。

  f	該註釋字符串只在首行出現。下一行不重複註釋，但保留相同的縮進 (例如，帶
  	符號的列表 (bullet-list))。

  s	三段式註釋的起始字符串

  m	三段式註釋的中間字符串

  e	三段式註釋的結尾字符串

  l	左對齊。和 's' 或 'e' 一起使用。起始或結尾字符串的最左字符和中間字符串
	的最左字符對齊。
	這是缺省值，可以省略。詳情見下。

  r	右對齊。同上，不過不是最左字符而是最右字符。詳情見下。

  O	"O" 命令不把它當作註釋。

  x	允許三段式註釋用以下方式結束: 在中間字符串自動提供的情況下，在新行第一
	個動作是輸入結尾字符串的最後一個字符。詳情見下。

  {digits}
	在和 's' 或 'e' 一起使用時: 對自動插入的中間或結尾字符串增加 {digit}
	單位的位移。該位移以左對齊的位置為基準。詳情見下。

  -{digits}
	和 {digits} 類似，但減少縮進。這只對開始或結尾部分至少有相當數量的縮進
	時才有效。

如果一個字符串沒有 'f'、's'、'm' 或 'e' 任何一個標誌位，Vim 假設註釋字符串在每
行都重複出現。標誌位部分可以為空。

在 {string} 之前或之後的任何空白都是 {string} 的一部分，所以不要隨便留出開頭或
結尾的空白，除非空白的確是註釋字符串的一部分。

如果某個註釋字符串是另一個字符串的一部分，先指定完整的，再指定部分的。例如，要
包含 "-" 和 "->"，用 >
	:set comments=f:->,f:-

三段式註釋必須以開始、中間和結尾三部分給出，而且不能間雜其它的部分。一個三段式
C 註釋的例子是 >
	sr:/*,mb:*,ex:*/
為了避免形如 "*ptr" 的內容被識別為註釋，這裡的中間字符串包含了 'b' 標誌位。對
三段式註釋而言，Vim 從開始和中間字符串之後查找結尾字符串。如果找到，註釋就不會
再從下一行繼續。三段式註釋必須要有一個中間字符串，不然 Vim 無法識別中間的那些
行。

注意 上述三段式註釋定義裡的 "x" 標誌位。當你在一個 C-註釋裡按回車時，Vim 會自
動在新行後插入中間字符串: " * "。要結束註釋，你只需要在新行裡首先鍵入 "/"。這
樣就把中間字符串替換成結尾字符串並應用指定的對齊方式，成為了 " */"。從而省卻了
先按退格鍵的麻煩。


這裡是一個關於用於對齊的標誌位的例子，使得註釋看起來很突出 (也很像一個 1 字)。
考慮註釋字符串 >
	sr:/***,m:**,ex2:******/

                                   /***
                                     **<--右對齊，來自 "r" 標誌位
                                     **
  2 個單位的位移，來自 "2" 標誌位--->**
                                   ******/
該例中，第一行註釋是鍵入的，然後按回車四次，最後按 "/" 以結束註釋。

這裡是三部分註釋的一些細節。有三個時間點應用對齊和位移標誌位: 輸入起始字符串後
開啟新行、在結尾字符串前開啟新行、三部分註釋的自動結束。而結尾部分的對齊標誌位
要反過來看；這樣，相同的對齊標誌位在分別用於 "s" 和 "e" 時才會使起始和結尾部分
有相同的縮進。每個註釋部分只應用一種對齊方式，但位移優先於 "r" 和 "l" 標誌位。

打開 'cindent' 在很多情況下會覆蓋對齊標誌位。使用其它方法，如 |gq| 或 |=| 來重
新縮進也不會參考對齊標誌位。這些其它的排版選擇可以定義類似的行為。一個擔心是
'cindent' 雖然有眾多附加的選項來對註釋進行基於上下文的縮進，但不能再現三部分注
釋的縮進對齊。但 'indentexpr' 應該有能力很好地處理三部分註釋。

其它示例: >
   "b:*"	包含 "*" 開頭的行，但 "*" 後面不是空白的除外。這樣避免指針取值
		操作 "*str" 被識別為註釋。
   "n:>"	包含形如 ">"、">>"、">>>" 等開頭的行。
   "fb:-"	包含 "- " 開頭的列表，可用來自動排版。

該選項的缺省值是 "b:#"。這意味著 "#include" 開頭的行不會被認為是註釋，但
"# define" 是。這是個不得不然的妥協。

{僅當編譯時加入 |+comments| 特性才有效}

							*fo-table*
你可以使用 'formatoptions' 選項來控制 Vim 如何對文本進行排版。'formatoptions'
是一個字符串，它可以包含下列字符。缺省設置是 "tcq"。為了提高可讀性，你可以用逗
號分隔選項字符。

字符	 在 'formatoptions' 裡代表的含義   ~

t	使用 'textwidth' 自動迴繞文本
c	使用 'textwidth' 自動迴繞註釋，自動插入當前註釋前導符。
r	在插入模式按回車時，自動插入當前註釋前導符。
o	在普通模式按 'o' 或者 'O' 時，自動插入當前註釋前導符。
q	允許 "gq" 排版時排版註釋。
	注意 排版不會影響空行或者只有註釋前導符的行。這樣的行開啟一個新段落，
	註釋前導符的改變也是如此。
w	拖尾的空格指示下一行繼續同一個段落。而以非空白字符結束的行結束一個段
	落。
a	自動排版段落。每當文本被插入或者刪除時，段落都會自動進行排版。參見
	|auto-format|。
	如果 'c' 標誌位存在，該設置只對識別的註釋有效。
n	在對文本排版時，識別編號的列表。實際上，這裡使用了 'formatlistpat' 選
	項，所以可以使用任何類型的列表。出現在數字之後的文本縮進距離被應用到後
	面的行。數字之後可以有可選的 '.'、 ':'、')'、']' 或者 '}'。
	注意 'autoindent' 也必須置位。不要和 "2" 一起使用，效果不好。
	示例: >
		1. 第一項
		   迴繞文字
		2. 第二項
2	在對文本排版時，將段落第二行而非第一行的縮進距離應用到其後的行上。這適
	用於第一行有特殊縮進需要的段落。注意 'autoindent' 也必須置位。
	示例: >
			first line of a paragraph
		second line of the same paragraph
		third line.
v	Vi-兼容的插入模式自動迴繞: 只有在當前輸入命令鍵入的空白上才會分行。
	(注意: 這並不能 100% Vi 兼容。Vi 在這方面有些 "意想不到的特性"，換而言
	之，漏洞。它使用屏幕列而非實際的列。)
b	和 'v' 類似，但只有在鍵入空白時還沒抵達或者剛到迴繞邊界的時候才會自動
	迴繞。如果一行在開始插入之前已經超過 'textwidth' 指定的長度，或者在到
	達 'textwidth' 之時沒有輸入過空白，Vim 不會自動迴繞。
l	插入模式不分行: 當一行已經超過 'textwidth' 時，插入命令不會自動排版。
m	可以在任何值高於 255 的多字節字符上分行。這對亞洲文本尤其有用，因為每
	個字符都是單獨的單位。
M	在連接行時，不要在多字節字符之前或之後插入空格。優先於 'B' 標誌位。
B	在連接行時，不要在兩個多字節字符之間插入空格。有 'M' 標誌位時無效。
1	不要在單字母單詞後分行。如有可能，在它之前分行。


't' 和 'c' 不同組合方式決定 Vim 何時進行自動迴繞:
值	行為	~
""	沒有自動排版 (你可以用 "gq" 進行手工排版)
"t"	自動排版文本，不包括註釋
"c"	自動排版註釋，不包括文本 (對 C 程序適用)
"tc"	自動排版文本和註釋

注意 如果 'textwidth' 為 0，Vim 不會做任何自動排版 (但是會根據 'comments' 選項
自動插入註釋前導符)。但 'a' 標誌位存在時有例外。|auto-format|

注意 如果 'paste' 打開，Vim 也不會做任何排版。

注意 即使 Vim 不做自動迴繞，仍然可以把 'textwidth' 設為非零。'textwidth' 對
"gq" 的排版依然有用。

如果 'comments' 選項包含 "/*"、"*" 和/或 "*/"，Vim 有一套處理這些註釋更加聰明
的內嵌方法。在 "/*" 或 "*/" 之前或之後開始一個新行 (在 'formatoptions' 裡有
'r' 或者 'o' 的情況下)，會自動給出正確的開始部分。排版或者自動迴繞也會有相同的
處理。在以 "/*" 或者 "*" 開始並包含 "*/" 的行之後開啟新行，就不會插入註釋前導
符，而且新行的縮進由註釋起始行決定。
例如: >
    /* ~
     * 你的任何註釋。
     */ ~
    該行的縮進和以上註釋的起始行相同。

上述這些應該已經十分夠用了，尤其在與新的 :autocmd 命令協同使用時，可以為不同文
件類型提供不同的設置。

一些例子:
  適用於 C 代碼 (只對註釋排版): >
	:set fo=croq
< 適用於郵件/新聞 (排版所有文本，"o" 命令不開始註釋): >
	:set fo=tcrq
<

自動排版						*auto-format*

如果 'formatoptions' 裡包含 'a' 標誌位，在插入或者刪除文本時會自動進行排版。這
對編輯文本段落很好用。以下對如何使用這一功能提供一些提示:

- 你需要正確定義何謂段落。最簡單的方式是以空行分隔的為段落。如果沒有分隔的空
  行，考慮用 'w' 標誌位並在段落中除了最後一行以外，每行結尾加上一個空格。

- 你可以根據文件類型 |filetype|， 或者用 |modeline| 指定特定文件的方式，設置不
  同的 'formatoptions'。

- 將 'formatoptions' 設為 "aw2tq" 使得文本以如下方式縮進:

	    bla bla foobar bla 
	bla foobar bla foobar bla
	    bla bla foobar bla 
	bla foobar bla bla foobar

- 如果只想自動排版註釋，加上 'c' 標誌位。可用於源代碼。

- 設置 'textwidth' 為你希望的寬度。如果為零，使用 79 或屏幕寬度中較小的那個。

還有一些警告:

- 如果段落沒有正確分隔，任何改變都會使得所有相連的文本自動排版。考慮 >

	:set fo-=a

- 如果用 'w' 標誌位 (行尾的空格意味著段落的繼續) 並且用 |dd| 刪除了段落的末
  行，這段落自動和下一個段落合併為一個段落。

- 改變的文本被保存以備可能的撤銷之用。排版也是改變的一種。所以每次排版都會為撤
  銷保存文本。這會有相當的內存開銷。

- 排版一個很長的段落和/或複雜的縮進也許會相當慢。

==============================================================================
7. 文本排序						*sorting*

Vim 有排序函數和排序命令。排序函數可見: |sort()|。

							*:sor* *:sort*
:[range]sor[t][!] [i][u][r][n][x][o] [/{pattern}/]
			給 [range] 裡的行排序。如果沒有給出行範圍，給所有行排
			序。

			帶 [!] 則反向排序。

			帶 [i] 則忽略大小寫。

			帶 [n] 則排序基於每行的第一個十進制數 (在 {pattern} 匹
			配之後或之內)。
			數值包含前導的 '-'。

			帶 [x] 則排序基於每行的第一個十六進制數 (在 {pattern}
			匹配之後或之內)。忽略引導的 "0x" 或 "0X"。
			數值包含前導的 '-'。

			帶 [o] 則排序基於每行的第一個八進制數 (在 {pattern} 匹
			配之後或之內)。

			帶 [u] 則只保留完全相同的行的第一行 (如果帶 [i]，忽略
			大小寫的區別)。
			沒有這個標誌位，完全相同的行的序列會按照它們原來的順序
			被保留下來。
			注意 引導和拖尾的空白差異會導致不相同的行。

			如果指定 /{pattern}/ 並且沒有 [r] 標誌位，跳過匹配
			{pattern} 的文本，使得排序在匹配之後的內容上進行。
			除了斜槓以外，任何非字母的字符都可以。
			例如，要按第二個逗號分隔的字段排序: >
				:sort /[^,]*,/
<			按虛擬第 10 列的文本排序 (從而忽略製表和空格的區別): >
				:sort /.*\%10v/
<			按每行的第一個數值排序，不管它前面有什麼: >
				:sort /.\{-}\ze\d/
<			(說明: ".\{-}" 匹配任何文本，"\ze" 設置匹配結束位置，
			\d 匹配單個數位。)
			帶 [r] 則排序在匹配 {pattern} 的文本上進行，而不是如上
			所述的用它之後的文本。
			例如，要按每行的前三個字母排序且只看這三個字母: >
				:sort /\a\a\a/ r

<			如果使用 {pattern}，不匹配 {pattern} 的行按照它們原來
			的順序被保留，但和匹配 {pattern} 的行分開。如果反向排
			序，它們會以反向順序出現，並在排序好的行之後。否則它們
			會以原有順序出現，在排序好的行之前。

			如果 {pattern} 為空 (例如指定 //)，則使用最近使用的搜
			索模式。這樣你可以先試好模式，然後在執行。

注意 ":sort" 和 ":global" 一起使用並不能對匹配的行進行排序，這樣做沒有意義。

排序的細節取決於使用的庫函數。不能保證它是 "穩定" 排序，也不能保證排序依賴於當
前的 locale。你要自己試試才知道。

排序可以被中斷,但在整個過程裡如果中斷得太晚，最後可能會出現重複的行。這取決於
使用的系統庫函數。

 vim:tw=78:ts=8:ft=help:norl:
