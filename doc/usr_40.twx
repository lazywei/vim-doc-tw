*usr_40.txt*	For Vim version 7.3.  最近更新：2006年7月

		     VIM USER MANUAL - by Bram Moolenaar
		     譯者：lang2 http://vimcdoc.sf.net

			      創建新的命令


Vim 是一個可擴展的編輯器。你可以把一系列你常用的命令組合成一個新的命令。或者重
新定義一個現存的命令。各種命令的自動執行可以通過自動命令實現。

|40.1|	鍵映射
|40.2|	定義命令行命令
|40.3|	自動命令

            下一章: |usr_41.txt|  編寫 Vim 腳本
            前一章: |usr_32.txt|  撤銷樹
              目錄: |usr_toc.txt|

==============================================================================
*40.1*	鍵映射

簡單的映射已經在 |05.3| 介紹過了。基本的概念是將一系列的鍵輸入轉換成為另外一個
鍵輸入序列。這是一個很簡單，但是很有效的機制。
   最簡單的形式是將一個鍵輸入序列映射到一個鍵上。由於那些除了 <F1> 外的功能鍵
都沒有預先定義的功能，選擇它們作為映射對象是很有效的。例如: >

	:map <F2> GoDate: <Esc>:read !date<CR>kJ

這顯示了如何使用三種不同的運行模式。在用 "G" 移動到最後一行後，"o" 命令開始一
個新行並開始插入模式。然後文本 "Date: " 被輸入並用 <Esc> 離開插入模式。
   注意在 <> 內使用的特殊鍵。這叫尖括號記法。你要分別地輸入這些字符，而不是鍵
入要表示的鍵本身。這使得映射更具可讀性，而且你也可以方便地拷貝，粘貼文本。
   ":" 使得 Vim 回到命令行。":read !date" 命令讀取 "date" 命令的輸出並添加到當
前行之下。<CR> 是用來執行該命令的。
   到此為止，文本看起來像:

	Date:  ~
	Fri Jun 15 12:54:34 CEST 2001 ~

然後 "kJ" 將光標上移並將兩行連接起來。
   參閱 |map-which-keys| 可以幫助你決定應該使用哪些鍵來作映射。


映 射 與 運 行 模 式

":map" 命令定義普通模式的鍵映射。你也可以為其它運行模式定義映射。例如，":imap"
用來定義插入模式的映射。你可以用它來定義一個插入日期的映射: >

	:imap <F2> <CR>Date: <Esc>:read !date<CR>kJ

看起來很像前面為普通模式定義的 <F2> 映射。只是開始的地方有所不同。普通模式下的
<F2> 映射依然有效。這樣你就可以在各種模式下為同一映射鍵定義不同的映射。
   應該注意的是，雖然這個映射以插入模式開始，但它卻以普通模式結束。如果你希望
繼續插入模式，可以在最後加上 "a"。

下面是一個映射命令及其生效模式的總覽:

	:map		普通，可視模式及操作符等待模式
	:vmap		可視模式
	:nmap		普通模式
	:omap		操作符等待模式
	:map!		插入和命令行模式
	:imap		插入模式
	:cmap		命令行模式

操作符等待模式是當你鍵入一個操作符 (比如 "d" 或 "y") 之後，Vim 期待你鍵入一個
動作命令或者文本對像時的狀態。比如，當你鍵入命令 "dw"， 那個 "w" 就是在操作符
等待模式下鍵入的。

假定你想定義映射 <F7> 使得命令 d<F7> 刪除一個 C 程序塊 ({} 包括的文本)。類似的
y<F7> 會將程序塊拷貝到匿名的寄存器。因此，你所要做的就是定義 <F7> 來選擇當前的
語法塊。你可以用下面的命令做到: >

	:omap <F7> a{

這使得 <F7> 在操作符等待模式下選擇一個塊，就像是你鍵入了 "a{" 一樣。這個映射在
你不容易鍵入 { 時比較有用。


映 射 列 表

要查看當前定義的映射，使用不帶參數的 ":map" 命令。或者其它運行模式的變體。輸出
應該類似於:

	   _g		 :call MyGrep(1)<CR> ~
	v  <F2>		 :s/^/> /<CR>:noh<CR>`` ~
	n  <F2>		 :.,$s/^/> /<CR>:noh<CR>`` ~
	   <xHome>	 <Home>
	   <xEnd>	 <End>


第一列顯示該映射有效的運行模式。"n" 表示普通模式，"i" 表示插入模式，等等。空白
表示用 ":map" 命令定義的映射，也就是對普通和可視模式有效。
   列出映射的一個比較實用的目的是檢查 <> 表示的特殊鍵是否被識別了 (僅當支持多
色彩是有效)。例如，當 <Esc> 被用彩色顯示時，它表示轉義字符。否則，只是 5 個不
同的字符。


重 映 射

映射的結果會檢查其中包括的其他映射。例如，上面對 <F2> 的映射可以減短為: >

	:map <F2> G<F3>
	:imap <F2> <Esc><F3>
	:map <F3>  oDate: <Esc>:read !date<CR>kJ

在普通模式下 <F2> 被映射為：行進至最後一行，然後輸入 <F3>；在插入模式下先鍵入
<Esc> 後也輸入 <F3>。接下來 <F3> 也被映射，執行真正的工作。

假設你幾乎不使用 Ex 模式，並想用 "Q" 命令來排版文本 (就像舊版本的 Vim 那樣)。
下面的映射就能做到: >

	:map Q gq

但是，你總有需要用到 Ex 模式的時候。我們來將 "gQ" 映射為 Q，這樣你仍然可以進入
Ex 模式: >

	:map gQ Q

這樣一來當你鍵入 "gQ" 時它被映射為 "Q"。到現在為止一切順利。但由於 "Q" 被映射
為 "gq"， 輸入的 "gQ" 被解釋成為 "gq"， 你根本就沒進入 Ex 模式。
   要避免鍵被再次映射，使用 ":noremap" 命令: >

	:noremap gQ Q

現在 Vim 就知道了對 "Q" 不需要檢查與之相關的映射。對於每個模式都有一個類似的命
令:

	:noremap	普通，可視和操作符等待模式
	:vnoremap	可視模式
	:nnoremap	普通模式
	:onoremap	操作符等待模式
	:noremap!	插入和命令行模式
	:inoremap	插入模式
	:cnoremap	命令行模式


遞 歸 映 射

當一個映射調用它本身的時候，會無限制的運行下去。這可以被用來無限次重複一個操
作。
   例如，你有一組文件，每個的第一行都包括一個版本號。你用 "vim *.txt" 來編輯它
們。你現在正在編輯第一個文件。定義下面的映射: >

	:map ,, :s/5.1/5.2/<CR>:wnext<CR>,,

現在當你鍵入 ",," 時，上面的映射被觸發。它把第一行的 "5.1" 替換為 "5.2"。接著
執行 ":wnext" 來寫入文件並開始編輯下一個。映射以 ",," 結束。這又觸發了同一個映
射，再次執行替換操作，依此類推。
   這個映射會一直進行下去，直至遇到錯誤為止。在這裡可能是查找命令無法匹配到
"5.1" 。你可以自行插入 "5.1" 然後再次鍵入 ",,"。或者 ":wnext" 因為遇到最後一個
文件而失敗。
   當映射在中途遇到錯誤時，映射的剩餘部分會被放棄。你可用 CTRL-C 中斷映射。(在
MS-Windows 上用 CTRL-Break)。


刪 除 映 射

要刪除一個映射，使用 ":unmap" 命令。同樣，刪除映射的命令也和運行模式相關:

	:unmap		普通，可視和操作符等待模式
	:vunmap		可視模式
	:nunmap		普通模式
	:ounmap		操作符等待模式
	:unmap!		插入和命令行模式
	:iunmap		插入模式
	:cunmap		命令行模式

這裡有個小技巧可以定義一個對普通模式和操作符等待模式有效而對可視模式無效的映
射：先對三個模式都定義映射，然後將可視模式的那個刪除: >

	:map <C-A> /---><CR>
	:vunmap <C-A>

注意那 5 個字符 "<C-A>" 表示一個鍵組合 CTRL-A。

要清除所有的映射，使用 |:mapclear| 命令。現在你應該可以猜到各種模式下的變體了
吧。要當心使用這個命令，它不可能被撤銷。


特 殊 字 符

在 ":map" 命令後面可以追加另一個命令。需要用 | 字符來將兩個命令分開。這也就意
味著一個映射中不能直接使用該字符。需要時，可以用 <Bar> (五個字符)。例如:
>
	:map <F8> :write <Bar> !checkin %<CR>

":unmap" 命令有同樣的問題，而且你得留意後綴的空白字符。下面兩個命令是不同的:
>
	:unmap a | unmap b
	:unmap a| unmap b

第一個命令試圖刪除映射 "a "，後面帶有一個空格。

當要在一個映射內使用空格時，應該用 <Space> (七個字符): >

	:map <Space> W

這使得空格鍵移動到下一個空白字符分割的單詞。

在一個映射後不能直接加註釋，因為 " 字符也被當作是映射的一部分。你可以用 |" 繞
過這一限制。這實際上是開始一個新的空命令。例如: >

	:map <Space> W|     " Use spacebar to move forward a word


映 射 與 縮 寫

縮寫和插入模式的映射很像。對參數的處理它們是一樣的。它們主要的不同在於觸發的方
式。縮寫是由單詞之後的非單詞字符觸發的。而映射由其最後一個字符觸發。
   另一個區別是你鍵入的縮寫的字符會在你鍵入的同時被插入到文本內。當縮寫被觸發
時，這些字符會被刪除並替換成縮寫所對應的字符。當你鍵入一個映射時，直到你完成所
有的映射鍵而映射被觸發時，映射所對應的內容才會被插入。如果你置位 'showcmd' 選
項，鍵入的字符會顯示在 Vim 窗口的最後一行。
   有一個例外是當映射有歧義的時候。假定你有兩個映射: >

	:imap aa foo
	:imap aaa bar

現在，當你鍵入 "aa" 時，Vim 不知道是否要使用第一個映射。它會等待另一個鍵輸入。
如果是 "a"，第二個映射被執行，結果是 "bar"。如果是其它字符，例如空格，第一個映
射被執行，結果是 "foo"， 而且空格字符也會被插入。


另 外 ...

<script> 關鍵字可以被用來使一個映射僅對當前腳本有效。參見 |:map-<script>|。

<buffer> 關鍵字可以被用來使一個映射僅對當前緩衝區有效。參見 |:map-<buffer>|。

<unique> 關鍵字可以被用來當一個映射已經存在時不允許重新定義。否則的話新的映射
會簡單的覆蓋舊的。參見 |:map-<unique>|。

如果要使一個鍵無效，將之映射至 <Nop> (五個字符)。下面的映射會使 <F7> 什麼也干
不了: >

	:map <F7> <Nop>| map! <F7> <Nop>

注意 <Nop> 之後一定不能有空格。

==============================================================================
*40.2*	定義命令行命令

Vim 編輯器允許你定義你自己的命令。你可以像運行其他命令行命令一樣運行你自定義的
命令。
   要定義一個命令，像下面一樣執行 ":command" 命令: >

	:command DeleteFirst 1delete

現在當你執行 ":DeleteFirst" 命令時，Vim 執行 ":1delete" 來刪除第一行。

	備註:
	用戶定義的命令必須以大寫字母開始，但不能用 ":X"，":Next" 和 ":Print"。
	也不能用下劃線！你可以使用數字，但是不鼓勵這麼做。

要列出用戶定義的命令，執行下面的命令: >

	:command

像那些內建的命令一樣，用戶自定義的命令也可以被縮寫。你只需要鍵入足夠區別於其它
命令的字符就可以了。命令行補全也有效。


參 數 個 數

自定義命令可以帶一系列的參數。參數的數目必須用 -nargs 選項來指定。例如，上面
例子中的 :DeleteFirst 命令不帶參數，所以你也可以這樣來定義: >

	:command -nargs=0 DeleteFirst 1delete

不過，因為缺省參數數目為 0，你沒有必要加上 "-nargs=0"。其它可用的值是:

	-nargs=0	無參數
	-nargs=1	一個參數
	-nargs=*	任意數目的參數
	-nargs=?	沒有或一個參數
	-nargs=+	一個或更多參數


使 用 參 數

在命令的定義中，<args> 關鍵字可以用來表示命令帶的參數。例如: >

	:command -nargs=+ Say :echo "<args>"

現在當你輸入  >

	:Say Hello World

Vim 會顯示 "Hello World"。然而如果你加上一個雙引號，就不行了。例如: >

	:Say he said "hello"

要把特殊字符放到字符串裡，必須在它們的前面加上反斜槓，用 "<q-args>" 就可以: >

	:command -nargs=+ Say :echo <q-args>

現在上面的 ":Say" 命令會引發下面的命令被執行: >

	:echo "he said \"hello\""

關鍵字 <f-args> 包括與 <args> 一樣的信息，不過它將其轉換成適用於函數調用的格
式。例如:
>
	:command -nargs=* DoIt :call AFunction(<f-args>)
	:DoIt a b c

會執行下面的命令: >

	:call AFunction("a", "b", "c")


行 范 圍

有些命令需要一個範圍作為參數。要告訴 Vim 你需要定義這樣的命令，使用 -range 選
項。它可能的值如下:

	-range		允許範圍；缺省為當前行。
	-range=%	允許範圍；缺省為整個文件。
	-range={count}	允許範圍；只用該範圍最後的行號作為單個數字的參數，其缺
			省值為 {count}。

當一個範圍被指定時，關鍵字 <line1> 和 <line2> 可以用來取得範圍的首行和末行的行
號。例如，下面的命令定義一個將指定的範圍寫入文件 "save_file" 的命令 －
SaveIt: >

	:command -range=% SaveIt :<line1>,<line2>write! save_file


其 它 選 項

其它的一些選項有:

	-count={number}		命令可以帶 count 參數，缺省為 {number}。
				用 <count> 關鍵字可以訪問該參數。
	-bang			允許使用 !。若 ! 出現，<bang> 擴展為 !。
	-register		你可以指定一個寄存器。(缺省為無名寄存器。)
				指定的寄存器可通過 <reg> (即 <register>) 來操
				作。
	-complete={type}	給出命令行補全的方式。|:command-completion| 
				列出了所有可用值。
	-bar			命令後可用 | 加另外一個命令，或 " 加一個註釋。
	-buffer			命令僅對當前緩衝區有效。

最後，你還可以使用 <lt> 關鍵字來代表字符 <。這樣可以轉義上面提到的 <> 項目的特
殊含義。


重 定 義 和 刪 除

! 參數可以用來重新定義相同的命令: >

	:command -nargs=+ Say :echo "<args>"
	:command! -nargs=+ Say :echo <q-args>

要刪除自定義命令，使用 ":delcommand"。該命令只帶一個參數，那就是自定義命令的
名字。例: >

	:delcommand SaveIt

要一次刪除所有的自定義命令: >

	:comclear

要當心！這個命令無法撤銷。

關於所有這些內容的更多信息可參閱參考手冊: |user-commands|。

==============================================================================
*40.3*	自動命令

自動命令是一類特殊的命令。當某些事件，例如文件讀入或改變緩衝區等事件發生時，它
們會自動被執行。例如，通過自動命令你可以教 Vim 來編輯壓縮文件。這個功能被用在
|gzip| 插件裡。
   自動命令非常強大。如果你小心使用的話，自動命令可以省去你很多自己敲命令的麻
煩。如果不當心的話你就是自找麻煩。

假設你希望在每次寫入文件時自動的替換文件尾部的日期戳。先定義一個函數: >

	:function DateInsert()
	:  $delete
	:  read !date
	:endfunction

你需要在每次寫入文件之前想辦法調用該函數。下面這一行就能做到: >

	:autocmd FileWritePre *  call DateInsert()

"FileWritePre" 是這個自動命令的觸發事件：寫文件前 (pre)。"*" 是一個用來匹配文
件名的模式。這兒它匹配所有文件。
   如果這個命令生效，當你調用 ":write" 時，Vim 檢查是否有匹配 FileWritePre 事
件的自動命令並執行它們。然後才執行 ":write"。
   通用的 :autocmd 命令格式如下: >

	:autocmd [group] {events} {file_pattern} [nested] {command}

組名  [group] 是可選的。它被用來管理和調用命令 (後面再講)。{events} 參數是一個
觸發事件列表 (用逗號隔開)。
   {file_pattern} 是文件命令，通常帶有通配符。例如，用 "*.txt" 會使得自動命令
對所有文件名以 ".txt" 結尾的文件被調用。選項 [nested] 允許自動命令的嵌套 (見
下)。最後，{command} 是要被執行的命令。


事 件

最有用的事件之一是 BufReadPost。它在一個文件被調入編輯之後被觸發。常被用來設定
相關的選項。例如，你已知 ".gsm" 文件是 GNU 彙編程序源碼。為確保使用正確的語法
文件，可以定義這樣的自動命令: >

	:autocmd BufReadPost *.gsm  set filetype=asm

如果 Vim 能夠正確的識別文件類型的話，它將為你設定 'filetype' 選項。這會觸發
Filetype 事件。你可以利用這個來為某一類型的文件做編輯的準備工作。例如，要為文
本文件調入一組縮寫: >

	:autocmd Filetype text  source ~/.vim/abbrevs.vim

在開始編輯一個新文件時，你可以要求 Vim 插入一個模板: >

	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c

在 |autocmd-events| 可以找到一個完整的事件列表。


匹 配 模 式 

那個 {file_pattern} 參數實際上可以是一個以逗號分割開的模式列表。例如:
"*.c,*.h" 匹配所有文件名以 ".c" 和 ".h" 結尾的文件。
   常見的文件通配符都可以使用。這裡給出一個最常用的清單:

	*		匹配任意字符，任意多次
	?		匹配任意字符，一次
	[abc]		匹配 a、b 或 c
	.		匹配一個點 .
	a{b,c}		匹配 "ab" 和 "ac"

當模式包括斜槓 (/) 時 Vim 會比較路徑名。否則只有文件名的最後部分才用來作比較。
例如，"*.txt" 匹配 "/home/biep/readme.txt"。模式 "/home/biep/*" 也可以匹配那個
文件。但是 "home/foo/*.txt" 就不行。
   當包括斜槓時，Vim 會試著匹配文件的完整路徑 ("/home/biep/readme.txt") 和相對
路徑 (例如： "biep/readme.txt")。

	備註:
	當在使用反斜槓作為文件分隔符的系統 (如 MS-Windows) 上工作時，你也得在
	自動命令中使用正斜槓。這會使編寫匹配模式變得容易些，因為反斜槓有特殊的
	意義。它同時也使自動命令更具可移植性。


刪 除

要刪除一個自動命令，使用和定義它一樣的命令格式。但不要包括後面的 {command}
部分，而且要加上 !。例如: >

	:autocmd! FileWritePre *

這樣會刪除為 "FileWritePre" 事件定義的匹配 "*" 文件名模式的所有自動命令。


列 表

要列出當前定義的所有自動命令，用這個: >

	:autocmd

這個列表可能會相當長，特別是在使用了文件類型檢測時。你可以指定組，事件和／或
文件名模式來要求僅列出相關的命令。例如，要列出 BufNewFile 事件的所有自動命
令: >

	:autocmd BufNewFile

列出所有匹配文件名模式 "*.c" 的命令: >

	:autocmd * *.c

使用 "*" 作為事件會給出所有事件的列表。要列出 cprograms 組對應的自動命令: >

	:autocmd cprograms


組

當定義自動命令時用到 {group} 這一項時，自動命令會被分成組。比如說，這可以被用
來刪除一個組中的所有命令。
   在為某一個組定義數個自動命令時，可以使用 ":augroup" 命令。例如，我們來定義
一些用於 C 程序的自動命令: >

	:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END

這和下面的命令有一樣的效果: >

	:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3

要刪除 "cprograms" 組中的所有自動命令: >

	:autocmd! cprograms


嵌 套

一般的，某一事件觸發的自動命令在被執行時不會再觸發其它事件。例如，當因
FileChangedShell 事件而讀入一個文件時，那些被定義來設定語法的自動命令就不會被
觸發。要使那些命令被觸發，加上一個 "nested" 參數: >

	:autocmd FileChangedShell * nested  edit


執 行 自 動 命 令

Vim 允許你用模擬某一事件發生的辦法來觸發一個自動命令。這可以在一個自動命令裡用
來觸發另外一個。例如: >

	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("<afile>:r")

這定義了一個新文件開始編輯之後觸發的自動命令。這個文件的文件名必須以 ".new" 結
尾。其中的 ":execute" 命令利用表達式求值來組成一個新的命令並執行之。當編輯文件
"tryout.c.new" 時被執行的命令將是: >

	:doautocmd BufReadPost tryout.c

expand() 函數的參數是 "<afile>"，用來代表自動命令執行所關聯的文件。":r" 指定僅
使用其根部分。

":doautocmd" 執行於當前緩衝區。":doautoall" 命令於 "doautocmd" 命令類似但執行
於所有緩衝區。


使 用 普 通 模 式 命 令

自動命令所執行的命令是 "命令行" 命令。如果你想在其中執行普通模式命令，可以使用
":normal" 命令。例如: >

	:autocmd BufReadPost *.log normal G

這樣，當你編輯 *.log 文件時 Vim 會將光標移動到最後一行。
   使用 ":normal" 命令需要點技巧。首先，你要確保其參數是一個包括所有參數的完整
命令。當你用 "i" 進入插入模式時，你必須用 <Esc> 離開。如果你用 "/" 來開始查
找，你也必須用 <CR> 執行該查找命令。
   ":normal" 命令會使用其後的所有文本作為將要執行的命令。因此不可能用 | 來後跟
另一個命令。有個辦法可以繞過這個約束：把 ":normal" 命令放在 ":execute" 命令之
內。這個方法同時也方便了不可顯示的字符作為參數的傳遞。例如: >

	:autocmd BufReadPost *.chg execute "normal ONew entry:\<Esc>" |
		\ 1read !date

上面的例子還展示了如何用反斜槓來將一個長命令分為幾行。這可以用在 Vim 腳本中
(不能用在命令行)。

如果你想讓你的自動命令作一些複雜的操作，其中涉及在文件間跳轉然後回到原來位置，
你希望能夠恢復文件的視窗位置。|restore-position| 有些例子。


忽 略 事 件

有些時候，你並不想觸發自動命令。'eventignore' 選項包括了一組會被 Vim 完全忽略
的事件。例如，下面的命令會使得進入和離開窗口的事件被忽略掉: >

	:set eventignore=WinEnter,WinLeave

要忽略所有的事件，用下面的命令: >

	:set eventignore=all

要恢復到正常的狀態，把 'eventignore' 設定為空即可: >

	:set eventignore=

==============================================================================

下一章: |usr_41.txt|  編寫 Vim 腳本

版權: 見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
