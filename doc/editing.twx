*editing.txt*   For Vim version 7.3.  最新修改: 2010年8月


		  VIM 參考手冊    by Bram Moolenaar
				譯者: Willis
				http://vimcdoc.sf.net


編輯文件						*edit-files*

1.  簡介			|edit-intro|
2.  編輯單個文件		|edit-a-file|
3.  參數列表			|argument-list|
4.  寫入			|writing|
5.  寫入並退出			|write-quit|
6.  對話框			|edit-dialogs|
7.  當前目錄			|current-directory|
8.  編輯二進制文件		|edit-binary|
9.  加密			|encryption|
10. 修改時間			|timestamps|
11. 文件搜索			|file-searching|

==============================================================================
1. 簡介							*edit-intro*

用 Vim 編輯一個文件意味著:

1. 把該文件讀到緩衝區
2. 用編輯器命令修改緩衝區
3. 把緩衝區內容寫回文件

							*current-file*
只要你不保存緩衝區，原來的文件保持不變。如果你開始編輯一個文件 (把它的內容讀到
緩衝區裡)，該文件名被認作 "當前文件名"，或者說當前緩衝區的名字。命令行上，可以
用 "%" 來引用它 |:_%|。

							*alternate-file*
如果已經有了另外一個當前文件名，它會成為輪換文件名。命令行上，可以用 "#" 引用
它 |:_#|。你還可以用 |CTRL-^| 命令在當前和輪換文件之間切換。不過，輪換文件名在
使用 |:keepalt| 期間不予改變。

							*:keepalt* *:keepa*
:keepalt {cmd}		執行 {cmd}，在此期間保持當前輪換文件名不變。注意 間接
			調用的命令 (比如通過函數) 仍然可以設置輪換文件名。
			{Vi 無此功能}

所有文件名都會被記錄在緩衝區列表裡。在你輸入文件名以便編輯 (例如，用 ":e 文件
名") 或者寫回 (例如，用 ":w 文件名") 時，此文件名被加入該列表。你可以用緩衝區
列表來記住編輯過什麼文件並用 CTRL-^ 命令快速的從一個文件切換到另一個 (例如，以
便複製文本)。先敲入文件的編號再敲入 CTRL-^。{Vi: 只有一個輪換文件名}

CTRL-G		或				*CTRL-G* *:f* *:fi* *:file*
:f[ile]			顯示當前文件名 (如同輸入的那樣，除非使用過 ":cd")、光
			標位置 (除非置位了 'ruler' 選項) 和文件狀態 (只讀、已
			修改、讀入錯誤、新文件)。參見 'shortmess' 選項，瞭解如
			何可以簡化該消息。 {Vi 不包括列號}

:f[ile]!		和 |:file| 類似，但即使 'shortmess' 要求截短文件名，也
			不這麼做。

{count}CTRL-G		和 CTRL-G 類似，但顯示當前文件名的完整路徑。如果計數大
			於 1，則同時給出當前緩衝區號。{Vi 無此功能}

					*g_CTRL-G* *word-count* *byte-count*
g CTRL-G		顯示當前光標位置，以五種方式表達: 列、行、單詞、字符和
			字節計數。如果字符數和字節數相同，省略字符位置。
			如果當前行有字符佔據多於一個位置 (<Tab> 或其他特殊字
			符)，"實際" 列和屏幕列同時顯示，以連字號分隔。參見
			'ruler' 選項。{Vi 無此功能}

							*v_g_CTRL-G*
{Visual}g CTRL-G	和 "g CTRL-G" 類似，但顯示可視選擇區域的單詞、字符、行
			和字節計數。在面向列塊模式裡，列數也同時顯示。(關於
			{Visual} 見 |Visual-mode|。) {Vi 無此功能}

							*:file_f*
:f[ile][!] {name}	設置當前文件名為 {name}。可選的 ! 避免截短消息，就像
			|:file| 那樣。
			如果緩衝區已有名字，該名字成為 |alternative-file| 輪換
			文件名。新建一個列表外緩衝區來記住這個舊名字。
							*:0file*
:0f[ile][!]		刪除當前緩衝區的名字。可選的 ! 避免截短消息，就像
			|:file| 那樣。{Vi 無此功能}

:buffers
:files
:ls			列出當前已知的文件名。見 'windows.txt' |:files|
			|:buffers| |:ls|。{Vi 無此功能}

vim 會記住你輸入文件名的完整路徑。大多數情況下，文件名只以你輸入的方式顯示。但
":cd" 命令 |:cd| 使用後，就會看到完整路徑名。

							*home-replace*
如果設置了環境變量 $HOME，而文件名以該字符串開始，它的顯示會把 HOME 替換成
"~"。這麼做是為了使文件名的顯示較為簡潔。在讀寫文件時仍然使用完整路徑名，"~"
只供顯示文件名用。如果要替換名字實質上只有 "~" 的文件，會使用 "~/" (為了避免
設為 $HOME 的選項和設為 '~' 時的 'backupext' 混淆)。

保存緩衝區時，缺省使用當前文件名。這樣，如果你給出 "ZZ" 或者 ":wq" 命令，原有
的文件被覆蓋。如果你不想如此，給 ":write" 命令給出一個文件名參數，你可以把緩衝
區寫到另外一個文件裡。例如: >

	vim testfile
	[用編輯器命令修改緩衝區]
	:w newfile
	:q

這會建立文件 "newfile"，它是 "testfile" 經過修改的版本。"testfile" 文件保持不
變。無論如何，如果置位 'backup' 選項，Vim 會在原來的文件被覆蓋之前改名或複製。
如果你以後發現你需要原來的版本，你可以用這個備份文件。也可參見 'patchmode' 選
項。備份文件名通常是原來的文件加上 'backupext' 後綴。缺省的 "~" 比較奇特，目的
是為了防止意外覆蓋現存的文件。如果你喜歡 ".bak"，修改 'backupext' 選項。在
MS-DOS 機器上，當 Vim 檢測到正在使用的是 MS-DOS 或類似的文件系統 (例如，
messydos 或者 crossdos) 或者打開了 'shortname' 選項，多餘的點號被替換成 '_'。
通過設置 'backupdir'，備份文件也可存在別的目錄下。

							*auto-shortname*
技術上:	在 Amiga 上文件名可以長達 30 個字符。但在 MS-DOS 兼容的文件系統上只能
	用 8+3 個字符。Vim 試圖在創建 .swp 文件的時候檢測文件系統的類型。如果
	懷疑是一個類似 MS-DOS 的文件系統，則置位一個標誌位，它和設置
	'shortname' 選項有相同的效果。一旦你開始編輯一個新文件，該標誌位被復
	位。在根據當前文件名創建 ".swp" 和 ".~" 文件時，該標誌位起作用。但如果
	你在一個正常的文件系統上編輯文件，而寫到一個類似於 MS-DOS 的文件系統，
	該標誌位不會被置位。這種情況下，創建 ".~" 文件可能會失敗，你會得到一個
	錯誤消息。這種情況下，用 'shortname' 選項。

當你開始編輯而不給出文件名，會給出 "No File" 消息。如果 ":write" 命令帶一個文
件名參數，當前文件名被設為那個名字。這只有在 'cpoptions' 裡帶 'F' 標誌位 (缺省
的確是如此) 時才會發生 |cpo-F|。這對在空緩衝區裡編輯文本後寫入到文件有用。如果
'cpoptions' 裡包含 'f' 標誌位 (缺省_不_包含) |cpo-f|，在執行 ":read file" 時，
文件名被設置。這可用來先不帶參數啟動 Vim 再用 ":read file" 編輯文件。
如果設置了文件名而 'filetype' 為空，激活文件類型檢測的自動事件。
							*not-edited*
因為設置文件名並不是真正編輯該文件，你不會覆蓋它。這可由設置 "notedited" 標誌
位來完成。你可由 CTRL-O 或 ":file" 命令看到該標誌位是否設置。如果 "notedited"
標誌位已設置，它會包括 "[Not edited]"。當將緩衝區寫回當前文件名 (用 ":w!")
時，"notedited" 標誌位被重設。

							*abandon*
Vim 記住你是否修改了緩衝區。你所作的修改不會不小心丟失。如果試圖不寫回而退出，
或開始編輯別的文件，Vim 會拒絕。要繞過這重保護，在命令後加上 '!'。這樣，修改就
會丟失。例如: ":q" 在緩衝區修改後不會工作，但 ":q!" 會。要知道緩衝區是否修改，
用 "CTRL-G" 命令。如果緩衝區被修改，消息裡會有字符串 "[Modified]"。

如果你想不經提示而自動寫回改動，打開 'autowriteall' 選項。'autowrite' 是相關的
Vi-兼容選項，它並非對所有命令有效。

如果想保留修改了的緩衝區但不寫回，打開 'hidden' 選項。參見 |hidden-buffer|。

==============================================================================
2. 編輯單個文件						*edit-a-file*

							*:e* *:edit*
:e[dit] [++opt] [+cmd]	編輯當前文件。可用於在它被 Vim 之外的程序所改變的時候
			重新編輯當前文件。 如果當前緩衝區已經被修改而且沒有置
			位 'autowriteall'，或者文件不能被寫入，本命令失敗。
			另見 |++opt| 和 |+cmd|。
			{Vi: 無 ++opt}

							*:edit!*
:e[dit]! [++opt] [+cmd]
			總是編輯當前文件。放棄當前緩衝區任何已有的改變。如果你
			想從頭來過，這就會很有用。
			另見 |++opt| 和 |+cmd|。
			{Vi: 無 ++opt}

							*:edit_f*
:e[dit] [++opt] [+cmd] {file}
			編輯文件 {file}。
			如果當前緩衝區已被修改，這會失敗，除非置位了 'hidden'
			或者 'autowriteall' 並且文件能夠寫入。
			另見 |++opt| 和 |+cmd|。
			{Vi: 無 ++opt}

							*:edit!_f*
:e[dit]! [++opt] [+cmd] {file}
			總是編輯文件 {file}。放棄當前緩衝區任何已有的改變。
			另見 |++opt| 和 |+cmd|。
			{Vi: 無 ++opt}

:e[dit] [++opt] [+cmd] #[count]
			編輯第 [count] 個緩衝區 (根據 :files 顯示的結果)。
			該命令和 [count] CTRL-^ 一樣，但是 ":e #" 在輪換緩衝區
			沒有文件名時不能工作，而 CTRL-^ 則可以。
			另見 |++opt| 和 |+cmd|。
			{Vi: 無 ++opt}

							*:ene* *:enew*
:ene[w]			編輯一個新的無名緩衝區。如果當前緩衝區已被修改，這會失
			敗，除非置位了 'hidden' 或者 'autowriteall' 並且文件能
			夠寫入。
			如果 'fileformats' 非空，其給出的第一個格式將用於新的
			緩衝區上。如果 'fileformats' 為空，則使用當前緩衝區的
			'fileformat'。
			{Vi 無此功能}

							*:ene!* *:enew!*
:ene[w]!		編輯新的無名緩衝區。放棄當前緩衝區任何已有的改變。
			'fileformat' 的設置類似於 |:enew|。
			{Vi 無此功能}

							*:fin* *:find*
:fin[d][!] [++opt] [+cmd] {file}
			在 'path' 裡找到 {file}，然後編輯 |:edit| 它。
			{Vi 無此功能} {僅當編譯時加入 |+file_in_path| 特性才有
			效}

:{count}fin[d][!] [++opt] [+cmd] {file}
			和 ":find" 類似，但使用 'path' 的第 {count} 個匹配。這
			樣，":2find file" 會找到 'path' 裡的第二個 "file"。如
			果 'path' 裡文件的匹配不足所需之數，你會得到一個錯誤消
			息。

							*:ex*
:ex [++opt] [+cmd] [file]
			和 |:edit| 相同。

							*:vi* *:visual*
:vi[sual][!] [++opt] [+cmd] [file]
			用於 Ex 模式時: 退出 |Ex-mode|，回到普通模式。否則和
			|:edit| 相同。

							*:vie* *:view*
:vie[w][!] [++opt] [+cmd] file
			用於 Ex 模式時: 退出 |Ex-mode|，回到普通模式。否則和
			|:edit| 相同，但為本緩衝區置位 'readonly' 選項。{Vi 無
			此功能}

							*CTRL-^* *CTRL-6*
CTRL-^			編輯輪換文件 (和 ":e #" 等價)。
			多數情況下，輪換文件就是上次編輯的文件。這是切換兩個文
			件的一個快速方法。
			如果 'autowrite' 或 'autowriteall' 選項打開並且緩衝區
			被修改，則寫入文件。
			大多數情況下，^ 字符在鍵 6 之上，同時按 CTRL 和 6 會給
			出我們叫 CTRL-^ 的鍵碼。但在有的非-US 的鍵盤上 CTRL-^
			須以不同的方式生成。

[count]CTRL-^		編輯緩衝區列表裡第 [count] 個文件 (和 ":e #[count]" 等
			價)。這是切換文件的一個快速方法。
			詳情見上面 |CTRL-^|。
			{Vi 無此功能}

[count]]f						*]f* *[f*
[count][f		和 "gf" 一樣。它本身已被淘汰。

							*gf* *E446* *E447*
[count]gf		編輯光標之上或之後的文件名。助記: "goto file"。
			使用 'isfname' 選項來決定組成文件名的字符。拖尾的標點
			符號 ".,:;!" 被忽略。
			在 'path' 選項組成的目錄名列表查找文件。關於相對路徑和
			通配符，可見 'path' 選項。
			設置 'suffixesadd' 選項可以用來查找文件所要附加的後
			綴。如果文件找不到，用 'includeexpr' 來修改名字，然後
			再試一次。
			如果給出 [count]，'path' 裡找到的第 count 個文件被編
			輯。
			如果 Vim 拒絕放棄 |abandon| 當前文件，該命令失敗。
			如果你想在新窗口裡編輯文件，用 |CTRL-W_CTRL-F|。
			如果你想編輯新文件，用: >
				:e <cfile>
<			想使得 gf 總是如此工作，可以如此: >
				:map gf :e <cfile><CR>
<			如果名字是一個超文本鏈接，也就是看來像
			"type://machine/path" 這樣的，你需要 |netrw| 插件。
			對 Unix 而言，'~' 字符被擴展，比如在 "~user/file" 的場
			合。環境變量也得到擴展 |expand-env|。
			{Vi 無此功能}
			{僅在編譯時加入 |+file_in_path| 特性才有效}

							*v_gf*
{Visual}[count]gf	和 "gf" 相同，但是高亮文本被用來作為要編輯的文件名。
			'isfname' 被忽略。開頭的空白被忽略，除此以外，所有的空
			白和特殊字符被包括在文件名裡。
			({Visual} 可參見 |Visual-mode|。)
			{Vi 無此功能}

							*gF*
[count]gF		和 "gf" 相同，但如果文件名後面跟隨著數值，那麼光標將定
			位在該文件名的該行上。文件名和數值之間必須以一個非文件
			名 (見 'isfname') 和非數字字符分隔。文件名、分隔符和數
			值之間的空白被忽略。
			例如:
				eval.c:10 ~
				eval.c @ 20 ~
				eval.c (30) ~
				eval.c 40 ~

							*v_gF*
{Visual}[count]gF	和 "v_gf" 相同。

這些命令用來開始編輯單獨一個文件。這意味著該文件被讀入緩衝區裡並設置當前文件
名。打開哪個文件和當前目錄有關，見 |:cd|。

關於文件讀入以後給出的消息，參見 |read-messages|。

如果你把緩衝區內容弄亂了想從頭開始編輯，你可以用 ":e!" 命令。":e" 命令只有在你
改變當前文件名的時候有用。

							*:filename* *{file}*
除了這裡說明的事項以外，|cmdline-special| 也提到更多特殊項目，它們在期待文件名
時可用。

注意 除了 Unix 以外的系統: 在使用接受單個文件名的名字時 (如 ":edit file")，文
件名裡可以有空格，但是拖尾的空格被忽略。這可用於允許文件名有內含的空格的系統
(如 MS-Windows 和 Amiga)。示例: 命令 ":e   Long File Name " 會編輯文件 "Long
File Name"。在使用能接受多於一個文件名的命令時 (如 ":next file1 file2")，內含
的空格必須以反斜槓轉義。

						*wildcard* *wildcards*
{file} 裡的通配符被擴展。支持什麼通配符由系統決定。以下是一些通用的字符:
	?	匹配一個字符
	*	匹配任何東西，包括什麼都沒有
	**	匹配任何東西，包括什麼都沒有，遞歸進入目錄
	[abc]	匹配 'a'、'b' 或 'c'

要避免通配符的特殊含義，在前面加上反斜槓。不過，在 MS-Windows 上，反斜槓是路徑
分隔符，"path\[abc]" 在 'isfname' 選項裡有 "[" 的時候還是被看作通配符。一個簡
單避免該問題的方法是用 "path\[[]abc]"。這樣文件名變成 "path[abc]"。

					*starstar-wildcard*
在 Unix、Win32、Mac OS/X 和一些其它系統上，可以擴展 "**"。它允許你在目錄樹裡搜
索。最大深度可以到 100 層目錄。
注意 有些命令的工作方式略有不同。見 |file-searching|。
例如: >
	:n **/*.txt
找到文件:
	ttt.txt
	subdir/ttt.txt
	a/b/c/d/ttt.txt
如果使用了非通配字符，只匹配第一層目錄。例如: >
	:n /usr/inc**/*.h
找到文件:
	/usr/include/types.h
	/usr/include/sys/types.h
	/usr/inc_old/types.h

					*backtick-expansion* *`-expansion*
在 Unix 和一些其它系統上你可以在文件名裡用反引號。例如: >
	:e `find . -name ver\\*.c -print`
星號之前需要有反斜槓，以防 "ver*.c" 在執行 find 程序之前被外殼先擴展。
該功能對於多數其他系統也使用，但要求反引號必須包圍整個項目。你不能在第一個之前
和最後一個反引號之後有別的文本。

							*`=*
你可以用 `={expr}` 的語法來使用反引號擴展 Vim 表達式，而非外部命令。例如 >
	:e `=tempname()`
該表達式裡可以包含任何東西，因而可以用來避免 '"'、'|'、'%' 和 '#' 的特殊含義。
名字以換行符分隔。如果結果是 |List|，每個項目用作一個名字。換行符也分隔名字。

							*++opt* *[++opt]*
[++opt] 參數可以用來為某個命令強制指定 'fileformat'、'fileencoding' 或
'binary' 的值，並指定遇到壞字符的行為。其形式是: >
	++{optname}
或: >
	++{optname}={value}

其中 {optname} 是以下之一:	    *++ff* *++enc* *++bin* *++nobin* *++edit*
    ff     或  fileformat   超越 'fileformat' 之值
    enc    或  encoding	    超越 'fileencoding' 之值
    bin    或  binary	    置位 'binary'
    nobin  或  nobinary	    復位 'binary'
    bad			    指定壞字符的行為
    edit		    只用於 |:read|: 保持選項的值，就像編輯文件那樣

{value} 不能包含空白。它可以是這些選項任何可取之值。例如: >
	:e ++ff=unix
再次編輯相同的文件，但指定 'fileformat' 為 "unix"。 >

	:w ++enc=latin1 newfile
把當前緩衝區寫入到 "newfile"，以 latin1 編碼。

可以用多個 ++opt 參數，以空格分隔。它們都必須在任何 |+cmd| 參數之前。

								*++bad*
參數 "++bad=" 指定遇到不能轉化或者包含非法字節的字符時的行為。它可以是以下三種
形式之一:
    ++bad=X      單字節的字符，替代每個壞字符。
    ++bad=keep   保留壞字符，不予轉化。注意 這可能使得你的文本裡出現非法字節！
    ++bad=drop   刪除壞字符。

缺省就像用了 "++bad=?" 一樣: 每個壞字符被問號代替。有些地方會使用一個倒轉的問
號 (0xBF)。

注意 不是所有的命令都接受 ++bad 參數，但也不會報錯，例如 |:write|。

注意 在讀入文件時，'fileformat' 和 'fileencoding' 選項會被設為實際所用的格式。
在寫回時，這不會發生。因此下一次寫會使用選項的舊值。'binary' 選項也同樣如此。

							*+cmd* *[+cmd]*
[+cmd] 參數可以用來在新打開的文件定位光標或執行任何其他命令:
	+		從最後一行開始。
	+{num}		從第 {num} 行開始。
	+/{pat}		從匹配 {pat} 的第一行開始。
	+{command}	打開新文件以後執行 {command}。
			{command} 可以是任何 Ex 命令。
要在 {pat} 或 {command} 裡包含空白，在它之前加上反斜槓。反斜槓本身則要加倍。 >
	:edit  +/The\ book	     file
	:edit  +/dir\ dirname\\      file
	:edit  +set\ dir=c:\\\\temp  file
注意 最後一個例子裡反斜槓減半兩次: 一次用於 "+cmd" 參數，一次用於 ":set" 命
令。

							*file-formats*
'fileformat' 選項指定文件裡的換行符 (<EOL>) 風格:
'fileformat'    字符		   名字				~
  "dos"		<CR><NL> 或 <NL>   DOS 格式		*DOS-format*
  "unix"	<NL>		   Unix 格式		*Unix-format*
  "mac"		<CR>		   Mac 格式		*Mac-format*
以前還使用 'textmode' 。現在已經廢棄了。

在讀入文件時，以上列出的字符被解釋為換行符。DOS 格式 (MS-DOS、OS/2 和 Win32 缺
省值) 把 <CR><NL> 和 <NL> 都解釋為換行符。 注意 在以 DOS 格式寫入文件時，
會在每個單獨的 <NL> 之後加上 <CR> 字符。另見 |file-read|。

當寫入文件時，換行符用以上列出的字符寫入。DOS 格式使用 <CR><NL>。另見
|DOS-format-write|。

你可以從 DOS 格式讀入文件再以 Unix 格式寫回。這樣所有的 <CR><NL> 對會被換成
<NL> (假設 'fileformats' 包括 "dos"): >
	:e file
	:set fileformat=unix
	:w
反之，如果你從 Unix 格式讀入文件再以 DOS 格式寫回。所有的 <NL> 字符會被換成
<CR><NL> (假設 'fileformats' 包括 "unix"): >
	:e file
	:set fileformat=dos
	:w
如果你開始編輯新文件而 'fileformats' 選頂非空 (缺省)，Vim 會測試文件以何種格式
分隔行。如果設為 "unix,dos"，Vim 會檢查每行是帶 <NL> (Unix 和 Amiga) 還是帶
<CR><NL> 對 (MS-DOS)。只有當_所有_行都以 <CR><NL> 結尾，'fileformat' 才被設為
"dos"，否則，它被設為 "unix"。如果 'fileformats' 包含 "mac" 而且文件不含 <NL>
字符，'fileformat' 設為 "mac"。

如果 'fileformat' 選項在非 MS-DOS 的系統上設為 "dos"，消息 "[dos format]" 會提
示你發生了不同尋常的事情。 在 MS-DOS 系統上，如果 'fileformat' 設為 "unix"，你
也會得到消息 "[unix format]"。除了 Macintosh 以外的所有的系統中，如果
'fileformat' 設為 "mac"，你會得到消息 "[mac format]"。

如果 'fileformats' 選項為空而使用了 DOS 格式，但是在讀入文件時發現某些行不以
<CR><NL> 結尾，"[CR missing]" 會在文件消息裡列出。
如果 'fileformats' 選項為空而使用了 Mac 格式，但是在讀入文件時發現某些行有
<NL>，"[NL missing]" 會在文件消息裡列出。

如果新文件不存在，則當 'fileformats' 為空時使用當前緩衝區的 'fileformat'，否則
使用 'fileformats' 的第一個格式。

在開始編輯二進制、可執行或 Vim 腳本文件時，你應該置位 'binary' 選項。一個簡單
的方式是以 "-b" 選項啟動 Vim。該選項可以避免使用 'fileformat'。如果不設，你會
有單個 <NL> 字符被莫名其妙地換成 <CR><NL> 的風險。

你可以用 'key' 選項在寫回時給文件加密。它提供了相當安全性，防止別人讀到你的文
件。|encryption|


==============================================================================
3. 參數列表					*argument-list* *arglist*

如果你在啟動 Vim 的時候給出多個文件名，這些文件將被記住，即參數列表。你可以跳
轉到該列表裡的任何一個文件。

不要把它和 |:buffers| 命令裡的緩衝區列表混淆。參數列表在 Vi 裡已經存在，但
緩衝區列表是 Vim 新加入的。參數列表裡的文件名也會在緩衝區列表裡存在 (除非你用
|:bdel| 或 |:bwipe| 將其刪除)，但不在參數列表而出現在緩衝區列表的名字很常見。

該主題在用戶手冊的 |07.2| 一節已有介紹。

只有一個全局參數列表，所有窗口缺省都使用它。但可以創建局部於窗口的新參數列表，
見 |:arglocal|。

下面的命令使用參數列表，還有表達式函數 |argc()| 和 |argv()|。他們均作用於當前
窗口的參數列表。

							*:ar* *:args*
:ar[gs]			顯示參數列表，當前文件以方括號表示。

:ar[gs] [++opt] [+cmd] {arglist}			*:args_f*
			定義 {arglist} 為新的參數列表並編輯其中的第一個。如果
			已經作了修改而 vim 不能放棄 |abandon| 當前的緩衝區，該
			命令失敗。
			另見 |++opt| 和 |+cmd|。
			{Vi: 無 ++opt}

:ar[gs]! [++opt] [+cmd] {arglist}			*:args_f!*
			定義 {arglist} 為新的參數列表並編輯其中的第一個。忽略
			任何對當前緩衝區的改動。
			另見 |++opt| 和 |+cmd|。
			{Vi: 無 ++opt}

:[count]arge[dit][!] [++opt] [+cmd] {name}		*:arge* *:argedit*
			將 {name} 加到參數列表裡，並編輯之。
			如果 {name} 已經在參數列表裡存在，只編輯之。
			這和用 |:argadd| 然後 |:edit| 類似。
			注意 這裡只允許單個文件名，文件名裡的空格是允許的，就
			像 |:edit| 一樣。
			[count] 的用法和 |:argadd| 一樣。
			如果當前文件不能被放棄 |abandon|，[!] 是必需的。
			另見 |++opt| 和 |+cmd|。
			{Vi: 無 ++opt}

:[count]arga[dd] {name} ..			*:arga* *:argadd* *E479*
			將若干文件名 {name} 等加到參數列表裡。
			如果忽略 [count]， {name} 等加入到參數列表的當前項之
			後。不然，加到第 [count] 個文件之後。如果參數列表是
			"a b c"，而 "b" 是當前參數，那麼以下命令會導致:
				命令		新的參數列表 ~
				:argadd x	a b x c
				:0argadd x	x a b c
				:1argadd x	a x b c
				:99argadd x	a b c x
			這裡不會檢查重複項，因此一個文件可能加入參數列表兩次。
			不改變當前編輯的文件。
			{Vi 無此功能} {僅當編譯時加入 |+listcmds| 特性才有效}
			注意: 你也可以使用這個方法: >
				:args ## x
<			這會加入 "x" 項並對新的列表排序。

:argd[elete] {pattern} ..			*:argd* *:argdelete* *E480*
			從參數列表裡刪除匹配 {pattern} (可有多個) 的文件。
			{pattern} 為文件模式，見 |file-pattern|。"%" 可以用來
			刪除當前入口項。
			即使該命令從參數列表裡刪除了當前編輯文件，該文件保持被
			編輯。
			例如: >
				:argdel *.obj
<			{Vi 無此功能} {僅當編譯時加入 |+listcmds| 特性才有效}

:{range}argd[elete]	從參數列表裡刪除 {range} 範圍裡的文件。如果該範圍的最
			後一個數字過大，刪除直到最後一個參數為止。例如: >
				:10,1000argdel
<			刪除第 10 個和其後的參數，保留 1-9。
			{Vi 無此功能} {僅當編譯時加入 |+listcmds| 特性才有效}

							*:argu* *:argument*
:[count]argu[ment] [count] [++opt] [+cmd]
			編輯參數列表裡的第 [count] 個文件。在忽略 [count] 的時
			候，編輯當前入口項。如果已經作了修改而 vim 不能放棄
			|abandon| 當前的緩衝區，該命令失敗。
			另見 |++opt| 和 |+cmd|。
			{Vi 無此功能} {僅當編譯時加入 |+listcmds| 特性才有效}

:[count]argu[ment]! [count] [++opt] [+cmd]
			編輯參數列表裡的第 [count] 個文件。忽略任何對當前緩衝
			區的已有修改。在忽略 [count] 的時候，編輯當前入口項。
			另見 |++opt| 和 |+cmd|。
			{Vi 無此功能} {僅當編譯時加入 |+listcmds| 特性才有效}

:[count]n[ext] [++opt] [+cmd]			*:n* *:ne* *:next* *E165* *E163*
			編輯向後第 [count] 個文件。如果已經作了修改而 vim 不能
			放棄 |abandon| 當前的緩衝區，該命令失敗。另見 |++opt|
			和 |+cmd|。{Vi 沒有 count 和 ++opt}

:[count]n[ext]! [++opt] [+cmd]
			編輯向後第 [count] 個文件。忽略任何對當前緩衝區的已有
			修改。另見 |++opt| 和 |+cmd|。{Vi 沒有 count 和 ++opt}

:n[ext] [++opt] [+cmd] {arglist}			*:next_f*
			和 |:args_f| 相同。

:n[ext]! [++opt] [+cmd] {arglist}
			和 |:args_f!| 相同。

:[count]N[ext] [count] [++opt] [+cmd]			*:Next* *:N* *E164*
			編輯向前第 [count] 個文件。如果已經作了修改而 vim 不能
			放棄 |abandon| 當前的緩衝區，該命令失敗。另見 |++opt|
			和 |+cmd|。{Vi 沒有 count 和 ++opt}

:[count]N[ext]! [count] [++opt] [+cmd]
			編輯向前第 [count] 個文件。忽略任何對當前緩衝區的已有
			修改。另見 |++opt| 和 |+cmd|。{Vi 沒有 count 和 ++opt}

:[count]prev[ious] [count] [++opt] [+cmd]		*:prev* *:previous*
			和 :Next 相同。另見 |++opt| 和 |+cmd|。{Vi: 只有在某些
			版本存在}

							*:rew* *:rewind*
:rew[ind] [++opt] [+cmd]
			開始編輯參數列表的第一個文件。如果已經作了修改而 vim
			不能放棄 |abandon| 當前的緩衝區，該命令失敗。另見
			|++opt| 和 |+cmd|。{Vi 沒有 ++opt}

:rew[ind]! [++opt] [+cmd]
			開始編輯參數列表的第一個文件。忽略任何對當前緩衝區的已
			有修改。另見 |++opt| 和 |+cmd|。{Vi 沒有 ++opt}

							*:fir* *:first*
:fir[st][!] [++opt] [+cmd]
			":rewind" 的別名。{Vi 無此功能}

							*:la* *:last*
:la[st] [++opt] [+cmd]
			開始編輯參數列表的最後一個文件。如果已經作了修改而 vim
			不能放棄 |abandon| 當前的緩衝區，該命令失敗。另見
			|++opt| 和 |+cmd|。{Vi 無此功能}

:la[st]! [++opt] [+cmd]
			開始編輯參數列表的最後一個文件。忽略任何對當前緩衝區的
			已有修改。另見 |++opt| 和 |+cmd|。{Vi 無此功能}

							*:wn* *:wnext*
:[count]wn[ext] [++opt]
			寫回當前文件並開始編輯向後第 [count] 個文件。另見
			|++opt| 和 |+cmd|。{Vi 無此功能}

:[count]wn[ext] [++opt] {file}
			寫入當前文件到 {file} 並開始編輯向後第 [count] 個文
			件，除非 {file} 已經存在並且 'writeany' 選項被關閉。另
			見 |++opt| 和 |+cmd|。{Vi 無此功能}

:[count]wn[ext]! [++opt] {file}
			寫入當前文件到 {file} 並開始編輯向後第 [count] 個文
			件。另見 |++opt| 和 |+cmd|。{Vi 無此功能}

:[count]wN[ext][!] [++opt] [file]		*:wN* *:wNext*
:[count]wp[revious][!] [++opt] [file]		*:wp* *:wprevious*
			和 :wnext 相同，向前編輯而不是向後。{Vi 無此功能}

以上命令的 [count] 缺省為一。對有些命令可以使用兩個計數。後者 (右面那個) 被使
用。

如果沒有給出 [+cmd] 參數，光標定位於文件最後一個已知的位置。如果置位了
'startofline'，光標會定位於該行第一個非空白字符，不然，則使用最後一個已知列。
如果沒有最後已知的光標位置，光標會定位在第一行 (Ex 模式下則是最後一行)。

							*{arglist}*
參數列表裡的通配符會擴展，文件名會排序。這樣你可以用命令 "vim *.c" 編輯所有的
C 文件。在 Vim 裡面，":n *.c" 命令會做同樣的事。

空白用來分隔文件名。在空格或製表前加上反斜槓可以在文件名裡使用它們。例如，要編
輯單個文件 "foo bar": >
	:next foo\ bar

在 Unix 和一些其它系統上你還可以使用反引號，例如: >
	:next `find . -name \\*.c -print`
星號之前的反斜槓是必要的，它用來防止 "*.c" 在執行 find 程序之前被外殼擴展。

							*arglist-position*
如果有參數列表，你可以在窗口的標題上看到正在編輯哪個文件 (如果有一個窗口，而且
'title' 被置位)，或者通過 "CTRL-G" 命令，在文件消息裡看到。你會看到類似於
	(file 4 of 11)
的東西。如果 'shortmess' 包含 'f'，它會成為
	(4 of 11)
如果你還沒有編輯參數列表當前位置的文件，它會是
	(file (4) of 11)
這表示你在參數列表的第四個位置，不過還沒有開始編輯之。這發生於你剛做 ":e file"
的時候。


局 部 參 數 列 表

{Vi 無此功能}
{僅在編譯時加入 |+windows| 和 |+listcmds| 特性時才有效}

							*:arglocal*
:argl[ocal]		複製一個全局參數列表的局部備份。並不開始編輯另外一個文
			件。

:argl[ocal][!] [++opt] [+cmd] {arglist}
			定義一個新的局部於當前窗口的參數列表。除此以外，和
			|:args_f| 列表。

							*:argglobal*
:argg[lobal]		當前窗口使用全局參數列表。並不開始編輯另外一個文件。

:argg[lobal][!] [++opt] [+cmd] {arglist}
			當前窗口使用全局參數列表。和 |:args_f| 一樣，定義一個
			新的全局參數列表。所有使用全局參數列表的窗口都會看到這
			個新的列表。

可以有多個參數列表。他們可以在窗口之間共享。如果他們共享，在其中一個窗口修改參
數列表就會改變另一個窗口的列表。

如果一個窗口被分割，新的窗口從原來的窗口繼承參數列表。兩個窗口因而共享該列表，
直到其中一個窗口使用 |:arglocal| 或 |:argglobal| 來使用另外一個參數列表。


使 用 參 數 列 表

						*:argdo*
:argdo[!] {cmd}		對參數列表裡的每個文件執行 {cmd}。
			它的工作方式大致如下: >
				:rewind
				:{cmd}
				:next
				:{cmd}
				等等
<			如果當前文件不能被放棄 |abandon| 而且不存在 [!]，該命
			令失敗。
			如果一個文件檢測到錯誤，參數列表裡的其餘文件將不再被操
			作。
			參數列表裡的最後一個文件 (或發生錯誤的那個) 成為當前文
			件。
			{cmd} 可以包含 '|'，從而連接多個命令。
			{cmd} 不可修改參數列表。
			注意: 當命令執行時，Syntax 自動命令事件被加到
			'eventignore' 裡，從而被屏蔽。這樣顯著提高了編輯每個文
			件的速度。
			{Vi 無此功能} {僅當編譯時加入 |+listcmds| 特性才有效}
			另見 |:windo|、|:tabdo| 和 |:bufdo|。

示例: >
	:args *.c
	:argdo set ff=unix | update
它把 'fileformat' 選項設為 "unix"，並寫回現在已改變的所有的 *.c 文件。

示例: >
	:args *.[ch]
	:argdo %s/\<my_foo\>/My_Foo/ge | update
它把所有 *.c 和 *.h 文件裡的單詞 "my_foo" 換成 "My_Foo"。"e" 標誌位使得
":substitute" 命令對沒有使用 "my_foo" 的文件不提示錯誤。":update" 只有在發生改
變的時候才寫入文件。

==============================================================================
4. 寫入						*writing* *save-file*

注意: 如果 'write' 選項關閉，你不能寫入任何文件。

							*:w* *:write*
						*E502* *E503* *E504* *E505*
						*E512* *E514* *E667* *E796*
:w[rite] [++opt]	將整個緩衝區寫入當前文件。這是保存文件更動最普通的方
			式。如果置位了 'readonly' 選項或者其他原因不能寫入文
			件，它會失敗。
			關於 ++opt 可見 |++opt|，但只有 ++bin、++nobin、++ff
			和 ++enc 有效。

:w[rite]! [++opt]	和 ":write" 類似，但即使 'readonly' 已置位或者有其他原
			因寫入被拒絕，還是強制寫入。
			注意: 這可能會改變文件的權限和所有者，或者破壞 (符號)
			連接。在 'cpoptions' 裡加上 'W' 標誌位可以避免這一點。

:[range]w[rite][!] [++opt]
			將指定行寫入當前文件。這是很特別的，因為文件裡將不會包
			含緩衝區的所有行。

							*:w_f* *:write_f*
:[range]w[rite] [++opt]	{file}
			將指定行寫入文件 {file}，除非該文件已存在並且未置位
			'writeany' 選項。

							*:w!*
:[range]w[rite]! [++opt] {file}
			將指定行寫入文件 {file}。覆蓋已存在的文件。

						*:w_a* *:write_a* *E494*
:[range]w[rite][!] [++opt] >>
			將指定行附加到當前文件後。

:[range]w[rite][!] [++opt] >> {file}
			將指定行附加到文件 {file} 之後。'!' 強制寫入，即使該文
			件還不存在。

							*:w_c* *:write_c*
:[range]w[rite] [++opt] !{cmd}
			執行命令 {cmd}，以 [range] 指定的行作為它的標準輸入。
			(注意 ! 之前的空格)。{cmd} 以 ":!{cmd}" 類似的方式被執
			行，任何 '!' 被替換成前一個命令 |:!|。

":w" 命令缺省的 [range] 是整個緩衝區 (1,$)。如果寫回整個緩衝區，緩衝區不再被認
為已改變。用 ":w somefile" 寫到別的文件的情形則取決於 'cpoptions' 的 "+" 標誌
位。如果包含，即便緩衝區本身和其關聯的文件可能已不同，該寫命令還是復位
"modified" 標誌位。

如果 ":w" 給出一個文件名，它成為輪換文件。這可以用來，比如說，當寫入失敗而你想
再遲些再試一次: ":w #"。該功能可以通過從 'cpoptions' 選項裡去掉 'A' 標誌位來關
閉。

							*:sav* *:saveas*
:sav[eas][!] [++opt] {file}
			用文件名 {file} 保存當前緩衝區，並設置當前緩衝區的文件
			名為 {file}。前一個名字用作輪換文件名。[!] 用以覆蓋已
			存在的文件。
			如果 'filetype' 為空，在寫入文件前用新名字進行文件類型
			檢測。
			如果寫操作成功，復位 'readonly'。
			{Vi 無此功能}

							*:up* *:update*
:[range]up[date][!] [++opt] [>>] [file]
			和 ":write" 類似，但只有在緩衝區已修改的時候才寫入。
			{Vi 無此功能}


寫 入 多 個 緩 沖 區					*buffer-write*

							*:wa* *:wall*
:wa[ll]			保存所有已修改的緩衝區。沒有文件名或者只讀的緩衝區不在
			此列。{Vi 無此功能}

:wa[ll]!		保存所有已修改的緩衝區。即使是只讀的。但沒有文件名的緩
			沖區仍不會寫入。{Vi 無此功能}


如果你試圖覆蓋在別的地方修改的文件，Vim 會警告你。參見 |timestamp|。

			    *backup* *E207* *E506* *E507* *E508* *E509* *E510*
如果你寫入已存在的文件 (但非附加) 而打開了 'backup'、'writebackup' 或者
'patchmode' 選項，原來文件的一個備份會被建立。該文件或者由複製，或者由換名得
到 (見 'backupcopy')。在文件被成功寫入後，當置位 'writebackup' 選項而沒有置位
'backup' 時，該備份文件被刪除。當 'patchmode' 選項打開時，備份文件可能被改名。

							*backup-table*
'backup' 'writebackup'	動作	~
   關	     關		沒有備份
   關	     開		備份當前文件，寫入後刪除 (缺省)
   開	     關		刪除舊的備份，備份當前文件
   開	     開		刪除舊的備份，備份當前文件

當 'backupskip' 模式匹配被寫入的文件名，備份文件不會被創建。此時，'backup' 和
'writebackup' 被忽略。

如果 'backup' 選項置位，舊的備份文件 (與新的備份文件同名) 被刪除。如果沒有置位
'backup' 但置位了 'writebackup'，已有的備份文件不會被刪除。文件寫入時使用的是
另外一個文件名。

有些文件系統的崩潰可能導致備份文件和新寫入的文件同時丟失 (可能還在但包含不正確
數據)。這種情況下可以嘗試修復功能 |:recover|，因為交換文件在盤上保持一個同步的
備份，可能還有用。

'backupdir' 選項給出的目錄用於存放備份文件 (缺省在寫入文件的相同目錄)。

不管備份文件是否新建，它是否原始文件複製還是換名得來由 'backupcopy' 選項決定。
該選項的描述解釋了何時使用複製，何時使用換名。

如果備份文件創建失敗，寫入不會進行。除非命令中加上 '!'。

							*write-readonly*
如果 'cpoptions' 選項裡包含 'W'，Vim 拒絕覆蓋只讀文件。如果沒有該標誌位，":w!"
可以用來覆蓋只讀文件， 如果系統支持的話 (目錄本身必須是可寫的)。

							*write-fail*
如果新文件寫入失敗，要小心不要同時丟失了你的修改內容_和_原始的文件。如果沒有
備份文件而寫入新文件失敗的話，原始的文件已經沒有了！除 非 你 寫 了 文 件，不
要 退 出 VIM！如果創建了備份，它保存了原始文件的內容 (如果可能的話)。如果你退
出 Vim 並丟失了修改的部分，原始的文件很有可能還在。如果原始文件的保存也失敗的
話，你會得到一個錯誤信息，提示丟失了原始文件。

						*DOS-format-write*
如果 'fileformat' 為 "dos"，<CR><NL> 用作換行符 <EOL>。這是 MS-DOS，Win32 和
OS/2 的缺省行為。在其他系統中，"[dos format]" 信息會提示你使用了不同尋常的
<EOL>。
						*Unix-format-write*
如果 'fileformat' 為 "unix"，<NL> 用作換行符 <EOL>。在 MS-DOS，Win32 和 OS/2
上會顯示 "[unix format]"。
						*Mac-format-write*
如果 'fileformat' 為 "mac"，<CR> 用作換行符 <EOL>。在非 Mac 的系統上會顯示
"[mac format]" 消息。

另見 |file-formats| 和 'fileformat' 以及 'fileformats' 選項。

						*ACL*
ACL 代表訪問控制表 (Access Control List)。這是控制文件訪問權限一個高級方法。在
新的 MS-Windows 和 Unix 系統上，如果有文件系統的支持，可以使用之。
   Vim 試圖在寫入文件時保留 ACL 信息。備份文件會用和原始文件相同的 ACL 信息。
   ACL 信息也用來檢查文件是否只讀 (在打開文件時)。

						*read-only-share*
當 MS-Windows 共享網絡驅動器時，可以指定其為只讀。這意味著即使文件本身沒有只讀
屬性，你也不能寫入該文件。Win32 平台上的 Vim 會檢測只讀的網絡驅動器，並標記其
上的文件為只讀。你不能用 |:write| 修改。

						*write-device*
如果文件名其實是設備名，Vim 不會建立備份 (這也不可能)。你需要使用 "!"，因為設
備已經存在。Unix 上的示例: >
	:w! /dev/lpt0
MS-DOS 或 MS-Windows 上: >
	:w! lpt0
Unix 上當文件名不引用一個普通文件或者目錄時，檢測為設備。fifo 和命令管道對 Vim
而言視同設備。MS-DOS 和 MS-Windows 上以下名字檢測為設備:
	AUX
	CON
	CLOCK$
	NUL
	PRN
	COMn	n=1,2,3... 等
	LPTn	n=1,2,3... 等
名字大小寫均可。

==============================================================================
5. 寫入並退出						*write-quit*

							*:q* *:quit*
:q[uit]			退出當前窗口。如果是最後的一個，退出 Vim。如果已經有
			修改而且 Vim 拒絕放棄 |abandon| 當前的緩衝區，或者
			如果參數列表的最後一個文件還沒有被編輯，該操作失敗。
			如果有其它標籤頁，並且退出的是當前標籤頁的最後一個窗
			口，關閉當前標籤頁 |tab-page|。

:conf[irm] q[uit]	退出，但如果已經有修改或者參數列表的最後一個文件還未被
			編輯，給出提示。參見 |:confirm| 和 'confirm'。 {Vi 無
			此功能}

:q[uit]!		退出不保存，即使有可見的緩衝區發生了修改。不適用於隱
			藏的緩衝區。為了保證總能退出，用 ":qall!"。

:cq[uit]		在任何情形下，退出不保存，並返回一個錯誤代碼。參見
			|:cq|。此功能可用於 Manx 的 QuickFix 模式 (參見
			|quickfix|)。  {Vi 無此功能}

							*:wq*
:wq [++opt]		寫回當前的文件並且退出。如果文件只讀或者該緩衝區無名，
			寫回操作將失敗。如果參數列表的最後一個文件還沒有編輯，
			那麼退出操作將會失敗。

:wq! [++opt]		寫回當前的文件並且退出。如果當前緩衝區無名，則寫回操作
			將失敗。

:wq [++opt] {file}	寫入到 {file} 並且退出。 如果參數列表的最後一個文件還
			沒有編輯， 那麼退出操作將會失敗。

:wq! [++opt] {file}	寫入到 {file} 並且退出。

:[range]wq[!] [++opt] [file]
			同上，但只寫入 [range] 界定的那些行。

							*:x* *:xit*
:[range]x[it][!] [++opt] [file]
			和 ":wq" 類似， 但只有文件已修改時寫入才會實際進行。
			如果 'hidden' 被設置並且還有其他窗口，當前緩衝區會在
			寫入後被隱藏。

							*:exi* *:exit*
:[range]exi[t][!] [++opt] [file]
			同 :xit。

							*ZZ*
ZZ			如果文件被修改，寫回當前文件。然後退出。(和 :x 相
			同)。(注意: 如果有當前文件有多個窗口，該文件在被修改
			時會被寫回，當前窗口會被關閉)。

							*ZQ*
ZQ			退出，不檢查是否發生了修改 (等同於 ":q!")。
			{Vi 無此功能}

多 個 窗 口 和 緩 沖 區					*window-exit*

							*:qa* *:qall*
:qa[ll]		退出 Vim，除非存在修改過的緩衝區。(可以使用 ":bmod" 跳轉
		到下一個修改過的緩衝區)。如果置位了 'autowriteall'，所有
		被修改的緩衝區將被保存，一如調用了 |:wqall|。{Vi 無此功能}

:conf[irm] qa[ll]
		退出 Vim。如果存在修改過的緩衝區，給出提示。參見 |:confirm|。
		{Vi 無此功能}

:qa[ll]!	退出 Vim，不會保存任何的修改。 {Vi 無此功能}
		另見 |:cquit|，功能相同但使用非零的退出值。

							*:quita* *:quitall*
:quita[ll][!]	等同於 ":qall"。{Vi 無此功能}

:wqa[ll] [++opt]				*:wqa* *:wqall* *:xa* *:xall*
:xa[ll]		保存所有修改過的緩衝區並退出 Vim。如果其中有無名的、只讀的、
		或者其他原因寫入失敗的緩衝區，Vim 不會退出。{Vi 無此功能}

:conf[irm] wqa[ll] [++opt]
:conf[irm] xa[ll]
		保存所有修改過的緩衝區並退出 Vim。如果其中有只讀或者其他原因
		寫入失敗的緩衝區，給出提示。參看 |:confirm|。{Vi 無此功能}

:wqa[ll]! [++opt]
:xa[ll]!	保存所有修改過的緩衝區，甚至包括只讀的，然後退出 Vim。不過，
		如果有無名或者其他原因寫入失敗的緩衝區，Vim 仍然不會退出。
		{Vi 無此功能}

==============================================================================
6. 對話框						*edit-dialogs*

							*:confirm* *:conf*
:conf[irm] {command}	執行 {command}，如果有操作需要確認，顯示對話框。可用於
			":q"、":qa" 和 ":w" 命令 (後者用於超越只讀的設定)。

示例: >
  :confirm w foo
<	如果 "foo" 存在請求確認。 >
  :confirm q
<	如果有改變請求確認。 >
  :confirm qa
<	如果有任何修改過的未保存的緩衝區存在，對其中的每個緩衝區提示是保存還是
	放棄。還可以選擇 "save all" (保存所有) 或 "abandon all" (放棄所有)。

如果你希望總是用 ":confirm"，置位 'confirm' 選項。

			*:browse* *:bro* *E338* *E614* *E615* *E616* *E578*
:bro[wse] {command}	為 {command| 的參數顯示文件選擇對話框。目前這可用於
			|:e|、|:w|、|:wall|、|:wq|、|:wqall|、|:x|、|:xall|、
			|:exit|、 |:view|、|:sview|、|:r|、|:saveas|、|:sp|、
			|:mkexrc|、|:mkvimrc|、|:mksession|、|:mkview|、
			|:split|、|:vsplit|、|:tabe|、|:tabnew|、|:cfile|、
			|:cgetfile|、|:caddfile|、|:lfile|、|:lgetfile|、
			|:laddfile|、|:diffsplit|、|:diffpatch|、|:open|、
			|:pedit|、|:redir|、|:source|、|:update|、|:visual|、
			|:vsplit|，還有如果置位 'confirm' 的話，|:qall|。

			{僅對 Win32、Athena、Motif、GTK 和 Mac GUI 有效}
			如果不可用 ":browse"，你會得到錯誤消息。如果 |+browse|
			特性不存在或者 {command} 不支持該 (瀏覽) 功能，不顯示
			對話框，如常執行 {command}。
			":browse set" 和 |:options| 類同。
			關於 ":browse oldfiles"，另見 |:oldfiles|。

該語法最好通過若干範例說明之: >
	:browse e $vim/foo
<		在 $vim/foo 目錄裡打開瀏覽器並編輯選擇的文件。 >
	:browse e
<		在 'browsedir' 指定的目錄裡打開瀏覽器並編輯選擇的文件。 >
	:browse w
<		在當前緩衝區所在的目錄裡打開瀏覽器。缺省使用當前緩衝區的文件
		名。把緩衝區寫入到指定的文件。 >
	:browse w C:/bar
<		在 C:/bar 目錄裡打開瀏覽器，缺省使用當前緩衝區的文件名，把緩衝
		區寫入到指定的文件。
另見 |'browsedir'| 選項。
如果所用的 Vim 版本不支持瀏覽，該命令照原樣執行。

							*browsefilter*
對 MS Windows 而言，你可以修改瀏覽對話框的過濾 (filter)。設置 g:browsefilter
或 b:browsefilter 變量，你可以修改全局或局部於緩衝區的過濾設置。該變量應設為符
合如下格式的字符串 "{過濾標籤}\t{pattern};{pattern}\n"，其中的 {過濾標籤} 是出
現 "Files of Type" 組合框裡應出現的文字，而 {pattern} 是過濾文件名的模式。可以
給出多個模式，以 ";" 分隔。

Motif 使用相同的格式，但只使用第一個模式 (Motif 只提供一個模式，但可以編輯)。

例如，要使得對話框裡只顯示 Vim 文件，你可以用以下命令: >

     let g:browsefilter="Vim Scripts\t*.vim\nVim Startup Files\t*vimrc\n"

你可以通過在某個緩衝區上設置 b:browsefilter 變量超越全局過濾的設置。最有可能的
情況是在文件類型插件裡設置 b:browsefilter，以便瀏覽對話框只顯示和當前編輯的文
件所屬類型相關的項目。缺點是: 無法編輯一個新的不同類型的文件。要克服這一點，你
可以加上 "All Files\t*.*\n" 作為最後的過濾。用戶從而擁有訪問任何類型文件的選
擇。

==============================================================================
7. 當前目錄						*current-directory*

你也可以用 |:cd| 和 |:lcd| 命令換到別的目錄，所以你可以不用總是在文件名前輸入
目錄名。這也影響到外部命令的執行，例如 ":!ls"。

如果當前緩衝區被修改、'cpoptions' 裡有 '.' 標誌位而命令又不使用 "!"，那麼改變
目錄會失敗。

							*:cd* *E747* *E472*
:cd[!]			在非 Unix 系統上: 顯示當前目錄名。在 Unix 系統上: 改變
			當前目錄到主 (home) 目錄。在所有的系統上，用 |:pwd| 可
			以顯示當前目錄。

:cd[!] {path}		切換當前目錄為 {path}。如果 {path} 是相對路徑，則在
			|'cdpath'| 列出的目錄搜索之。
			這不會改變已經打開的文件，因為記住的是它們的完整路徑。
			但 |arglist| 裡的文件則可能會改變！
			MS-DOS 上這會同時改變當前的驅動器。
			要改變到當前文件的目錄: >
				:cd %:h
<
							*:cd-* *E186*
:cd[!] -		切換到上一個當前目錄 (在上個 ":cd {path}" 命令之前)。
			{Vi 無此功能}

							*:chd* *:chdir*
:chd[ir][!] [path]	和 |:cd| 相同。

							*:lc* *:lcd*
:lc[d][!] {path}	和 |:cd| 類似，但只設置當前窗口的當前目錄。別的窗口的
			當前目錄保持不變。{Vi 無此功能}

							*:lch* *:lchdir*
:lch[dir][!]		和 |:lcd| 相同。{Vi 無此功能}

							*:pw* *:pwd* *E187*
:pw[d]			顯示當前目錄名。{Vi: 沒有 pwd}
			另見 |getcwd()|。

只要沒有用過 |:lcd| 命令，所有窗口共享同一個當前目錄。切換到別的窗口的命令因此
不會改變當前目錄。
當某個窗口用了 |:lcd| 命令，所指定的目錄成為該窗口的當前目錄。沒用過 |:lcd| 的
窗口還是和全局的當前目錄同步。跳轉到另一個窗口時，當前目錄成為上次指定的本地當
前目錄。如果沒有指定過，則使用全局當前目錄。
如果使用 |:cd| 命令，當前窗口會丟失他的本地當前目錄，並從此以後使用全局當前目
錄。

|:cd| 的完整路徑名用於其後的文件讀寫。在某些網絡文件系統中，這可能會引起麻煩。
使用完整路徑名的結果是當前使用的文件名還是指向相同的文件。例如: 如果你有文件
a:test 和 目錄 a:vim。命令 ":e test" ":cd vim" ":w" 會覆蓋文件 a:test 而不是
a:vim/test。但如果你使用 ":w test" 文件 a:vim/test 會被覆蓋，因為你給出一個新
的文件名，因而與 ":cd" 之前所指向的文件業已不同。

==============================================================================
8. 編輯二進制文件					*edit-binary*

儘管 Vim 是用來編輯文本文件的，它也可用來編輯二進制文件。Vim 的 |-b| 參數 (b
代表二進制 (binary)) 使 Vim 以二進制模式進行文件讀寫操作，並設置二進制文件編輯
相關的一些選項 ('binary' 打開，'textwidth' 為 0，'modeline' 關閉，'expandtab'
關閉)。置位 'binary' 選項效果相同。不要忘記應在讀入文件之前進行該操作。

編輯二進制文件時要注意以下幾點:
- 在編輯可執行文件時，不要修改字符數。只用 "R" 或 "r" 命令來修改文本。不要用
  "x" 或退格鍵刪除字符。
- 設置 'textwidth' 選項為 0。不然，行會被意外的截為兩段。
- 如果 <EOL> 符不多，行會很長。如果你希望編輯屏幕顯示不下的行，重設 'wrap' 選
  項，使用橫向滾動。如果一行過長 (Amiga 上超過 32767 個字符，32 位系統中則大得
  多，見 |limits|)，你不能編輯該行。該行在讀入時會被截斷。也可能讀入發生 "out
  of memory" 錯誤。
- 確保在讀入文件_前_置位 'binary' 選項。不然，<CR><NL> 和 <NL> 都被認為行尾，
  從而在寫回時，<NL> 會被 <CR><NL> 取代。
- <Nul> 字符會在屏幕上顯示為 ^@。你可以用 "CTRL-V CTRL-@" 或 "CTRL-V 000" 輸入
  之 {Vi 不能處理文件裡的 <Nul> 字符}
- 插入 <NL> 字符會截斷一行。在將緩衝區寫入到文件時，<NL> 會作為 <EOL> 被寫入。
- 如果文件尾沒有 <EOL>，Vim 通常會自己加上。置位 'binary' 選項會禁止這一行
  為。你也可以讀取該選項的值來知道最後一行是否有 <EOL> (文本上你是看不到的)。

==============================================================================
9. 加密							*encryption*

Vim 可用加密的方式寫入文件並讀回。沒有正確的密鑰，加密文本不能被讀取。
{僅當編譯時加入 |+cryptv| 功能才有效}  *E833*

交換文件和撤銷文件的文本也被加密。

注意:
內存裡的文本是不加密的。系統管理員因此可以在你編輯時看到你的文本。用
":!filter" 或者 ":w !command" 過濾的文本也是不加密的，這些都可能造成文本洩露。
'viminfo' 文件也不加密。

_警告_: 如果在輸入密鑰時發生錯誤而且寫入文件後退出，這些文本就永遠丟失了。

使用加密的通常方法是用 ":X" 命令，它會提示你輸入一個密鑰。其後的一個寫入命令會
使用該密鑰加密文件。如果你以後編輯該文件，Vim 會要求你輸入密鑰。如果你的輸入正
確，文件是可讀的，不然，文本會顯示為亂碼。

							*:X*
:X	提示加密密鑰。輸入時不會反顯輸入的內容。別人即使看到屏幕，也不能看見你
	的密鑰。輸入的字符保存在 'key' 選項裡，它的值用來在寫入文件時加密該文
	件。在寫入之前，該文件保持不變。另見 |-x|。

'key' 選項裡的值在文件寫入時使用。如果該選項非空，寫入的文件會用它的值作為密鑰
加密。加密過的文件的頭部有個魔術數字，使得 Vim 可以識別這是加密文件。

要關閉加密，復位 'key' 選項為空值: >
	:set key=

使用 'cryptmethod' 選項來選擇加密方法為以下兩者之一: >
	:setlocal cm=zip       " 較弱的加密方法，後向兼容
	:setlocal cm=blowfish  " 較強的加盟方法
必須在寫入文件前進行。讀入加密文件時，自動設置該選項為文件寫入時選擇的方法。寫
入前改變 'cryptmethod' 就可以改變使用的加密方法。
要設置用於新文件的缺省方法，在 |vimrc| 文件中放入以下之一: >
	set cm=zip
	set cm=blowfish

寫入撤銷文件時，撤銷文件的文本使用相同的密鑰和方法。|persistent-undo|。

						*E817* *E818* *E819* *E820*
如果加密過程有錯，文本可以寫到文件裡，但再不能正確讀回來了。為此準備了一項測試
以確定加密順利完成。如果看到這些錯誤其中之一，不要以加密方式寫入文件！要修正
之，你需要重新編譯 Vim 程序。

*E831* 這是一個內部錯誤，"不應該發生"。如果你能重現該錯誤，請向開發者報告。

讀入加密文件時如果 'key' 選項非空，它被用作解密的密鑰。如果該值為空，你會得到
提示，輸入密鑰。如果你不輸密鑰或者密鑰不符，該文件以未解密的形式被編輯。使用錯
誤的密鑰不會有警告 (以增加暴力破解密鑰的難度)。

如果要以不同的密鑰讀入別的文件，設置 'key' 選項為空串，從而讓 Vim 給出提示輸入
新值。不要用 ":set" 命令輸入該值，否則別人在你身後就能看到了。

因為 'key' 選項的值應該是個秘密，永遠不要看它的值，也不要在 vimrc 文件裡設置。

如果你把如下諸行加到 "/etc/magic"、"/usr/share/misc/magic" 或者你系統支持的
"magic" 文件裡，你的加密文件可以被 "file" 命令識別: >
     0	string	VimCrypt~	Vim encrypted file
     >9	string	01	- "zip" cryptmethod
     >9	string	02	- "blowfish" cryptmethod


注意:
- 如果用 'charconvert' 轉換，不能實施加密。
- 你複製或者刪除的文本保存在編號的寄存器中。寄存器可以保存在 .viminfo 文件裡，
  從而可以讀到。修改你的 'viminfo' 選項以確保安全。
- 如果你走開一會兒，別入可能在 Vim 裡輸入命令，他不可能得到你的密鑰。
- 如果你輸入密鑰時發生錯誤，你就無法取回你的文本了！
- 如果你用 ":set key=value" 命令輸入密鑰，它會保存在歷史裡，從而在 viminfo 文
  件裡顯示 'key' 的值。
- 沒有 100% 的安全。Vim 的加密算法沒有經過健壯性的嚴格測試。
- 我們用的算法是可以破解的。一個 4 字符的密鑰需要大概一個小時，6 字符的密鑰需
  要一天 (在一台 Pentinum 133 PC 上)。這需要你知道文件裡一定會出現的若干文本。
  專家可以破解任何密鑰，如果文本已經被解密，則密鑰可以被推算出，而其他以相同密
  鑰加密的文件也能被解出。
- Pkzip 使用相同的加密方法，美國政府對其出口不持異議。
  Pkzip 的公共文件 APPNOTE.TXT 詳細描述了這一算法。
- Vim 起源於荷蘭。這是源代碼的出處。因此，加密代碼並非從美國出口。

==============================================================================
10. 修改時間					*timestamp* *timestamps*

Vim 記住文件開始編輯時的修改時間。這用來防止 (在你自己知道之前) 你有同一個文件
的不同版本。

在執行了外殼命令 (|:!cmd| |suspend| |:read!| |K|) 以後，Vim 會對窗口裡的所有緩
沖區的修改時間進行比較。Vim 會對在此期間被修改的文件執行相關的
|FileChangedShell| 自動命令或者顯示警告。GUI 上，在 Vim 取回輸入焦點的時候也會
發生。

							*E321* *E462*
如果你想自動重新載入在 Vim 之外被修改的文件的新內容，置位 'autoread' 選項。如
果你已經在 Vim 裡修改過這個文件，這不會工作。

注意 如果定義了 FileChangedShell 自動命令，你不會得到警告信息或者提示。該自動
命令應負責處理。

對目錄的修改也不會有警告 (例如用 |netrw-browse|)，除非你開始編輯一個新文件，但
它在外部被建立為一個目錄。

當 Vim 注意到一個文件的修改時間被修改並且該文件正在緩衝區裡等待編輯但還未經修
改，會先檢查文件內容是否相同，這是通過再次讀入該文件 (到一個隱藏緩衝區，該緩衝
區事後被立即刪除)，並比較兩個緩衝區的文本完成的。如果相同，你不會得到警告。

如果你覺得警告不夠及時或不夠充分，你可以使用如下命令。

							*:checkt* *:checktime*
:checkt[ime]		檢查是否有緩衝區在 Vim 之外被改變。 該命令檢查你是否有
			文件的兩個版本並給出警告。
			如果它在自動命令、":global" 命令或者任何非鍵盤輸入中調
			用，實際的檢查會延遲，直到副作用 (重新讀入文件) 不會有
			任何問題。
			每個已讀入的緩衝區會檢查相關的文件是否被改變。如果是，
			則 Vim 會採取行動。如果緩衝區沒有修改過而且置位了
			'autoread'，緩衝區被重新讀入。否則，你會被詢問是否重新
			讀入文件。如果文件被刪除，你會得到一個錯誤信息。如果文
			件過去不存在但現在已經存在，你會得到一個警告。
			一旦檢查過某個文件，他的修改時間被重置。因而，你不會被
			重複警告。

:[N]checkt[ime] {filename}
:[N]checkt[ime] [N]
			檢查某個特定緩衝區的修改時間。該緩衝區可以用名字、編號
			或者模式指定。


							*E813* *E814*
如果你指定 Vim 重載緩衝區，如果某可見窗口包含了該緩衝區，重載會在該窗口的上下
文中進行。否則，會使用一個特殊窗口，這使得大多數的自動命令可以執行。你不能關閉
這個窗口，還有一些其它特殊的限制。最好不要涉及到本緩衝區之外的對象。例如，設置
局部於窗口的選項可能會選錯窗口。分割窗口來做一些操作，然後關閉新分割的窗口應該
沒問題 (假定其它自動命令沒有副作用)。但關閉不相關的窗口和緩衝區就不好了。

在你寫入文件的時候，修改時間被檢查。如果發生了改變，Vim 會提示你是否要真的覆蓋
該文件:

	WARNING: The file has been changed since reading it!!!
	Do you really want to write to it (y/n)?

如果你按 'y'，Vim 會繼續寫入文件。如果你按 'n'，寫入操作被取消。如果你用 ":wq"
或者 "ZZ"，Vim 因而不會退出。從而你還有機會寫入文件。

通常，該消息意味著有人在編輯會話開始後，寫入到該文件裡。這可能是別人，這時你可
能想檢查你的修改和別人的修改是否可以合併。將文件寫到別的名字然後比較兩者的差
異 (可以用 "diff" 程序)。

當然也有可能你自己在另外一個編輯會話中或者用別的命令 (例如一個過濾命令) 修改了
該文件。這樣，你自己知道希望保留文件的哪個版本。

有一個情況即使在沒有任何錯誤的時候也會得到消息: Win32 系統在夏令時開始的時候。
Win32 庫的一些細節使得 Vim 對小時的變化有些混淆。第二天問題就沒有了。

==============================================================================
11. 文件搜索						*file-searching*

{僅當編譯時加入 |+path_extra| 特性才有效}

文件搜索目前用於 'path'、'cdpath' 和 'tags' 選項和 |finddir()| 和
|findfile()|。其他命令使用 |wildcards|，則略有不同。

有三種不同類型的搜索:

1) 向下搜索:						*starstar*
   向下搜索使用 '*'、'**' 或其他操作系統支持的通配符。'*' 和 '**' 是由 Vim 內
   部處理的，以適用於所有操作系統。注意 "**" 只在文件名開始處才被當作特殊的通
   配符。

   '*' 的使用很簡單: 匹配 0 個或更多字符。如果用搜索模式，應該是 ".*"。但注意
   文件搜索不使用 "." 元字符。

   '**' 則複雜的多:
      - _只_匹配目錄。
      - 匹配缺省最多可達 30 層的目錄。所以你可以用它整個目錄樹裡查找
      - 最大匹配的層數可以通過在 '**' 之後給出數字限定。
	這樣，'/usr/**2' 可以匹配: >
		/usr
		/usr/include
		/usr/include/sys
		/usr/include/g++
		/usr/lib
		/usr/lib/X11
		....
<	它_不_匹配 '/usr/include/g++/std'，因為這已到了第三層。
	允許的數字範圍是 0 ('**0' 被直接去掉) 到 100。如果給定的數字小於 0，則
	缺省為 30。如果大於 100，則使用 100。系統本身還有路徑長度的上限，通常
	是 256 或 1024 字節。
      - '**' 只能用於路徑的尾部，或者後面緊跟一個路徑分隔符，或者後面緊跟一個
	數字加一個路徑分隔符。

   你可以用任何順序混合 '*' 和 '**': >
	/usr/*/sys/**
	/usr/*tory/sys/**
	/usr/**2/sys/*

2) 向上搜索:
   這裡，你可以給出一個目錄，然後沿著目錄樹向上搜索一個文件。你可以給出若干終
   止目錄來限制搜索的範圍。終止目錄附加於路徑 (對 'path' 選項而言) 或文件名
   (對 'tags' 選項而言) 之後，中間以 ";" 分隔。如果需要多個終止目錄，一一列
   出，以 ';' 分隔。如果你不想要終止目錄 (搜索直到根目錄)，只要用 ";"。 >
	/usr/include/sys;/usr
<   會在以下位置搜索: >
	   /usr/include/sys
	   /usr/include
	   /usr
<
   如果你用相對路徑，則向上搜索始於 Vim 的當前目錄或當前文件的目錄 (如果相對路
   徑始於 "./" 並且 'cpoptions' 裡不含 'd' 的話)。

   如果 Vim 的當前路徑是 /u/user_x/work/release 而你用 >
	:set path=include;/u/user_x
<  然後用 |gf| 搜索文件，則文件在如下位置搜索: >
	/u/user_x/work/release/include
	/u/user_x/work/include
	/u/user_x/include

3) 混合向上/向下搜索
   如果 Vim 當前路徑是 /u/user_x/work/release 而你用 >
	set path=**;/u/user_x
<  然後用 |gf| 搜索文件，則文件在如下位置搜索: >
	/u/user_x/work/release/**
	/u/user_x/work/**
	/u/user_x/**
<
   _要小心_！這會消耗大量時間，因為對 '/u/user_x/**' 的搜索包括
   '/u/user_x/work/**' 和 '/u/user_x/work/release/**'。因此
   '/u/user_x/work/release/**' 被搜索三遍而 '/u/user_x/work/**' 被搜索兩遍。

   因而，在上例中你可能想如此設置 path: >
	:set path=**,/u/user_x/**
<   這會搜索:
	/u/user_x/work/release/** ~
	/u/user_x/** ~
    它會搜索相同的目錄群，但順序不同。

    注意 ":find"、":sfind" 和 ":tabfind" 命令目前不接受包含 url、使用雙星記號
    (/usr/**2) 或向上搜索 (;) 記號的 'path' 項目。

 vim:tw=78:ts=8:ft=help:norl:
