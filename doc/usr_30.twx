*usr_30.txt*	For Vim version 7.3.  最近更新：2008年6月

		     VIM 用戶手冊 - by Bram Moolenaar
		   譯者：wandys  http://vimcdoc.sf.net

			      編輯程序


Vim 有很多幫助編寫程序代碼的命令。例如：直接在 Vim 內編譯程序並跳轉到出錯位
置；根據語言種類自動設定縮進，還有對註釋進行排版。


|30.1|	編譯
|30.2|	C 文件縮進
|30.3|	自動縮進
|30.4|	其它縮進
|30.5|	製表符和空格
|30.6|	排版註釋格式

     下一章：|usr_31.txt|  使用 GUI
     前一章：|usr_29.txt|  在代碼間移動
       目錄：|usr_toc.txt|

==============================================================================
*30.1*	編譯

Vim 有個 "quickfix" 命令集。通過這些命令，你可在 Vim 內編譯程序並能直接跳轉到
出錯位置進行修正。你可以接著重新編譯並做修正，直到不再出錯為止。

下面的命令運行 "make" (包括你所給出的參數) 程序並捕捉其運行結果: >

	:make {arguments}

如果有錯誤產生那麼它們將被捕獲到。而且光標會停留在出現第一個錯誤的地方。
   讓我們看一個 "make" 的例子。當輸入 ":make" 後，屏幕出現如下的結果：

	:!make | &tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~

	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Press ENTER or type command to continue ~

你會看到編譯 "main.c" 文件 (見下) 出現的錯誤。按一下 <Enter>，Vim 會顯示文件
"main.c" 並將光標移到第一個出現錯誤行。你無需指定文件名或具體的行號，Vim 會根
據出錯信息定位相關位置。


		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
        光標 -> |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+

這個命令將光標移到下一個錯誤所在的行： >

	:cnext

光標跳轉到文件的最後一行 (第十行)，那裡有一個多餘的 '}'。
  有時由於空間不夠，Vim 會縮短出錯信息。如果你想查看詳細信息，可執行: >

	:cc

你可以通過 ":clist" 命令得到一個有關所有出錯信息的概覽。輸出的內容如下所示： >

	:clist
<	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~

只有那些含有文件名或行數的錯誤信息會被顯示。Vim 假定你對其它的信息不敢興趣。有
時你也許需要查看那些並不含文件名或行數的信息 (比如連接器輸出的有關未定義函數的
錯誤信息)。要查看所有信息，在命令後加上 "!" 就可以：
>
	:clist!
<	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~

Vim 會高亮顯示當前錯誤。如果你想回到上一個錯誤，執行：
>
	:cprevious

以下是一些其它的跳轉命令：

	:cfirst		到第一處錯誤
	:clast		到最後一處錯誤
	:cc 3		到第三處錯誤


指 定 編 譯 器

通過 'makeprg' 選項可以指定 ":make" 命令啟動的程序名。通常它被設定為 "make"。
但 Visual C++ 的用戶需要將它設定為 "nmake"：
>
	:set makeprg=nmake

你可以對這個選項指定參數。如有特殊字符，請用 '\' 來轉義。比如：
>
	:set makeprg=nmake\ -f\ project.mak

你還可以使用特殊的 Vim 內部關鍵字。比如用 '%' 來代替當前文件名： >
	:set makeprg=make\ %

這樣，當你編輯文件 "main.c" 時，運行 ":make" 命令會運行下面的程序：
>
	make main.c

這不太有用，所以你需要用 :r (root) 修飾符來稍稍修改一下：
>
	:set makeprg=make\ %:r.o

現在運行的程序就成了：
>
	make main.o

有關修飾符的更多信息，請查看這裡: |filename-modifiers|。


舊 的 出 錯 信 息 列 表

假設你用 ":make" 編譯了一個程序。其中的一個文件裡有個警告 (warning) 信息而另一
個文件中有一個出錯 (error) 信息。你修改了這個錯誤，並再次運行 ":make" 以參看它
是否已被糾正。現在你想查看剛才的那個警告信息。但由於含有警告的那個文件並沒有被
重新編譯，你無法在當前出錯信息列表中看到原來的警告信息。在這種情況下，你可以用
下面的命令來查看上一個出錯信息列表：
>
	:colder

然後你可以通過 ":clist" 和 ":cc {nr}" 命令來跳轉到出現警告的地方。
   要查看下一個出錯列表：
>
	:cnewer

Vim 可以記住十個出錯信息列表。


更 換 編 譯 器

要做到這一點，你需要告訴 Vim 所使用編譯器產生的錯誤信息格式。這可以通過
'errorformat' 來設定。這個選項幾乎可以配合任意一個編譯器的使用，但它的具體配置
卻很複雜。請在這裡查看詳細解釋：|errorformat|。

你可能會用到多種不同的編譯器。每次都設定 'makeprg' 選項，尤其是 'errorformat'
選項是很繁雜的。為此，Vim 提供一個簡便的方法。比如：要使用微軟的 Visual C++ 編
譯器：
>
	:compiler msvc

這個命令會找到適合 "msvc" 編譯器的 Vim 腳本文件並設定相關選項。
   你可以為編譯器編寫自己的腳本文件。請參考 |write-compiler-plugin|。


輸 出 重 定 向

"make" 命令會將運行結果重定向到一個錯誤文件中。具體的工作方式取決於很多方面，
比如 'shell' 選項。如果你的 ":make" 命令不能捕獲輸出，請檢查 'makeef' 和
'shellpipe' 選項。選項 'shellquote' 和 'shellxquote' 可能也會起作用。

如果你無法利用 ":make" 命令重定向輸出，一種變通的方法是在另一個窗口編譯程序並
將輸出重定向到一個文件中。然後你可在 Vim 中查看此文件：
>
	:cfile {filename}

這樣，你就可以像運行 ":make" 命令那樣跳轉到出錯的地方。

==============================================================================
*30.2*	C 風格文件縮進

合理的縮進會使程序更容易理解。Vim 提供了多種方法來簡化這項工作。要對 C 或 C 風
格如 Java 或 C++ 的程序縮進，請設定 'cindent' 選項。Vim 相當地瞭解 C 程序，它
會盡可能地為你自動縮進。通過 'shiftwidth' 選項，你可以指定下一級的縮進空格數。
4 個空格的效果很好。用一個 ":set" 命令就可做到：
>
	:set cindent shiftwidth=4

設定了這一選項之後，當你輸入了一個語句，比如 "if (x)" 後，下一行會自動向下一級
縮進。

				    if (flag)
	自動縮進           --->		do_the_work();
	自動取消縮進       <--	    if (other_flag) {
	自動縮進           --->		do_file();
	保持縮進			do_some_more();
	自動取消縮進       <--	    }

當你在大括號 ({}) 內輸入時，語句會在開始處縮進，而在結束處取消縮進。每次輸入
'}' 後都會取消縮進，因為 Vim 不知道你下一步將要輸入什麼。

自動縮進還能幫助你提前發現代碼中的錯誤。比如當你輸入了一個 '}' 後，如果發現比
預想中的縮進多，那可能缺少了一個 '}'。請用 "%" 命令查找與你輸入的 '}' 相匹配的
'{'。
   缺少 ')' 和 ';' 同樣會引起額外的縮進。當你發現比預料中多空白時，最好檢查一
下之前的代碼。

當你的代碼沒有被正確地排版，或者你插入或刪除了某些行時，你需要重新進行代碼縮
進。操作符 "=" 能完成這項功能，最簡單的格式是：
>
	==

這會縮進當前行。像其它的操作符一樣，有三種方式使用它。可視模式下，"=" 縮進選中
的行。一個有用的文本對象是 "a{"。它會選中當前 {} 區。這樣，要重新縮進光標所在
代碼塊：
>
	=a{

你還可以重新縮進整個文件：
>
	gg=G

但是，不要對已經手工縮進的文件使用此命令。自動縮進的確做得很好，但在某些情況下
你也許確實需要手工縮進。


設 定 縮 進 風 格

不同的人有不同的縮進風格。在默認情況下，Vim 採用了 90% 的程序員都使用的一種方
式並能很好地完成工作。但是，如果你想使用其它的風格，你可以通過 'cinoptions' 選
項來設定。
   'cinoptions' 默認為空，Vim 會使用默認風格。你可以在你希望改變的地方添加相應
的項目。例如，要使大括號的縮進如下所示：

	if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~

請使用這個命令：
>
	:set cinoptions+={2

還有很多其它的項目可供使用。請參考 |cinoptions-values|。

==============================================================================
*30.3*	自動縮進

你無需每次編輯 C 文件時都手工設定 'cindent' 選項。通過下面的命令你可以使它自動
化： 
>
	:filetype indent on

實際上，它不僅為 C 文件打開了 'cindent' 選項。首先，它會使 Vim 自動檢查文件類
型。語法高亮同樣需要此功能。
   一旦文件類型被識別，Vim 會為此類型的文件查找相關的縮進文件。(Vim 的發行中包
含了適合多種不同編程語言的縮進文件。) 該縮進文件將會被用來縮進當前文件。

如果你不喜歡這項功能，可以將它關閉：
>
	:filetype indent off

如果你不想為某種特定類型的文件進行縮進，你可以這樣做：
首先建一個只包括下行的文件：
>
	:let b:did_indent = 1

然後將其重命名為：

	{directory}/indent/{filetype}.vim

{filetype} 是文件類型的名字，比如 "cpp" 或 "java"。你可以用下面的命令來得到
Vim 識別到的文件類型名：
>
	:set filetype

對本文件，輸出會是：

	filetype=help ~

這樣你就可以用 "help" 來表示 {filetype}。
   對 {directory} 部分，你需要根據你的運行時目錄來設定。請查看下面命令的輸
出： 
>
	set runtimepath

請使用第一項 (也就是第一個逗號前的名字)。如果上面命令的輸出是：

	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~

你需要使用 "~/.vim" 來表示 {directory}。這樣最後的文件名就是：  

	~/.vim/indent/help.vim ~

除了關閉縮進選項，你還可以編寫自己的縮進文件。請參考 |indent-expression|。

==============================================================================
*30.4*	其它縮進

最簡單的自動縮進通過 'autoindent' 選項來完成，它會延續上一行的縮進。稍微聰明點
的是 'smartindent'，這個選項對那些沒有縮進文件可用的編程語言很有用。
'smartindent' 選項沒有 'cindent' 選項聰明，但要比 'autoindent' 聰明些。
   如果 'smartindent' 被設定，會在每個 '{' 處新增一級縮進，並在每個 '}' 處消
減。另外，對於 'cinwords' 選項所設定的所有單詞也會添加新一級的縮進。所有以 '#'
開始的行都會被特殊處理：所有縮進都被清除。這樣做是為了保持所有的預處理命令都在
第一列開始。縮進會在下一行中恢復。


修 正 縮 進

當你利用 'autoindent' 和 'smartindent' 選項延續上一行的縮進時，有很多時候你都
需要添加或刪除一個 'shiftwidth' 寬度的縮進。一個快速的方法是在插入模式下利用
CTRL-D 和 CTRL-T 命令。
   比如，當你需要輸入以下的 shell 腳本時：

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~

設定了這樣的選項：
>
	:set autoindent shiftwidth=3

你先輸入了第一行，按下回車後又輸入了第二行的開頭：

	if test -n a; then ~
	echo ~

這時你會發現你需要一個額外的縮進。輸入 CTRL-T，結果變為：

	if test -n a; then ~
	   echo ~

在插入模式下，CTRL-T 命令會加入一個 'shiftwidth' 寬度的縮進，無論光標在當前行
的什麼位置。
   你繼續輸入第二行，按下回車後又輸入了第三行。現在的縮進一切正常。然後你按下
回車輸入最後一行，現在的情況如下所示：

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~

要刪除這個多餘的縮進，可以在最後一行輸入 CTRL-D。這會刪除一個 'shiftwidth' 寬
度的縮進，無論光標在行中的什麼位置。
   在普通模式下，你可以用 ">>" 和 "<<" 命令來完成縮進的修正。'>' 和 '<' 是操作
符，因此你可以使用通常的那三種方式來指定你要縮進的行。一個有用的組合是：
>
	>i{

這個命令會縮進當前 {} 區內的行，'{' 和 '}' 本身並不被縮進。">a{" 會包括它們。
在下面的例子中，光標停留在 "printf" 上：

	原文			">i{" 之後		">a{" 之後

	if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~

==============================================================================
*30.5*	製表符和空格

'tabstop' 在缺省狀態下被設定為 8。儘管你可以改變它，但很快你就會遇到麻煩。其它
的程序不知道你用的製表符間隔值是多少，你的文件看起來會一下子改變許多。另外，很
多打印機都將製表符間隔值固定為 8。所以最好還是保留 'tabstop' 值不變。(如果你編
輯使用其它製表符間隔值的文件，請參考 |25.3| 來修正。)
   如果使用 8 個空格來縮進程序，你很快就會走到窗口的最右端；而用 1 個空格又看
不出足夠的差別。因此很多人喜歡用 4 個空格。這的確是個很好的折衷。
   由於一個製表符 (<Tab>) 是 8 個空格，而你又想使用 4 個空格來縮進，這樣你就無
法使用製表符來完成縮進。這裡有兩種解決辦法：

1. 混合使用製表符和空格。由於一個製表符佔用 8 個空格的位置，你的文件會含有更少
的字節數。插入或刪除一個製表符也要比 8 個空格快很多。

2. 只用空格。這就避免了那些使用不同製表符間隔值的文件所帶來的麻煩。

幸運的是，Vim 能夠同時很好地支持這兩種方式。


混 合 使 用 空 格 和 制 表 符

如果你使用製表符和空格的組合，你直接按正常情況編輯就行。Vim 缺省狀態下，能夠很
好地處理這些情況。
   通過設定 'softtabstop' 可以使工作變得更簡便。這個選項能使 <Tab> 看起來像是
被設定為 'softtabstop' 所指定的值，但實際上使用的確是製表符和空格的組合。
   當你執行下面的命令後，你每次按下 <Tab> 鍵，光標都會移動到下一個 "4 列" 邊
界：
>
	:set softtabstop=4
<
當你在第一列按下 <Tab> 鍵後，4 個空格會插入到文本中；再次按下 <Tab> 鍵，Vim 會
先刪除那 4 個空格，然後再插入一個製表符。Vim 會盡可能地使用製表符，並輔以空格
填補。
   刪除會以相反的方式進行。<BS> 鍵總是刪除 'softtabstop' 指定的數量。Vim 盡可
能地使用製表符，而用空格來填補空隙。
   下面的例子顯示了多次輸入製表符然後使用 <BS> 的情況。"." 代表一個空格而
"------->" 代表製表符。

	輸入			  結果 ~
	<Tab>			  ....
	<Tab><Tab>		  ------->
	<Tab><Tab><Tab>		  ------->....
	<Tab><Tab><Tab><BS>	  ------->
	<Tab><Tab><Tab><BS><BS>   ....

另一種方法是使用 'smarttab' 選項。當它被設定，Vim 對每個在縮進行中的製表符使用
'shiftwidth'，而對在第一個非空字符後輸入的 <Tab> 使用真的製表符。但 <BS> 鍵不
會像在 'softtabstop' 選項下那樣工作。


只 用 空 格

如果你不想在文件中出現製表符，可以設定 'expandtab' 選項：
>
	:set expandtab
<
當這個選項被設定，<Tab>鍵會插入一系列的空格。這樣你可以獲得如同插入一個製表符
一樣數量的空格。但你的文件中並不包含真正的製表符。
  退格鍵 (<BS>) 每次只能刪除一個空格。這樣如果你鍵入了一個 <Tab>，你需要鍵入
8 次 <BS> 才能恢復。如果你在調整縮進中，輸入 CTRL-D 會更快些。


制 表 符 與 空 格 的 相 互 轉 換

設定 'expandtab' 選項並不會影響已有的製表符。如果你想將製表符轉換為空格，可以
用 ":retab" 命令。使用下面的命令：
>
	:set expandtab
	:%retab

Vim 會在所有縮進中使用空格而非製表符。但是，所有非空字符後的製表符不會受到影
響。如果你想要轉化這些製表符，需要在命令中加入 !：
>
	:%retab!

這不大安全。因為它也許會修改字符串內的製表符。要檢查這種情況是否存在，可以執
行：
>
	/"[^"\t]*\t[^"]*"

這裡建議你不要在字符串中直接使用製表符。請用 "\t" 來替代，麻煩會少些。

將空格轉化為製表符的命令則恰好相反：
>
	:set noexpandtab
	:%retab!

==============================================================================
*30.6*	排版註釋格式

Vim 最了不起的地方之一就是它理解註釋。你可以要求 Vim 排版一段註釋。它會做得很
出色。
   比如，你有下面的一段註釋：

	/* ~
	 * This is a test ~
	 * of the text formatting. ~
	 */ ~

你可以要求 Vim 排版這段註釋。將光標定位到註釋開頭，然後輸入：
>
	gq]/

"gq" 是用來排版文本的操作符。"]/" 是移動到註釋尾的動作。命令的結果是：

	/* ~
	 * This is a test of the text formatting. ~
	 */ ~

注意 Vim 可以正確處理每行的開頭。
  另外一種方法是在可視模式下用 "gq" 排版選中的文本。

要在註釋中加入新的一行，先將光標移到中間一行，然後按 "o"。結果會如下所示：

	/* ~
	 * This is a test of the text formatting. ~
	 * ~
	 */ ~

Vim 會為你自動添加一個星號和空格，現在你可以輸入新的註釋。如果一行註釋長於
'textwidth'，Vim 會將其自動分開。同樣，星號和空格會被自動添加進來：

	/* ~
	 * This is a test of the text formatting. ~
	 * Typing a lot of text here will make Vim ~
	 * break ~
	 */ ~

要使用這些功能，你必須在 'formatoptions' 選項中指定一些標誌位：

	r	在插入模式下，輸入回車時插入星號。
	o	在普通模式下，使用 "o" 或 "O" 時插入星號。
	c	根據 'textwidth' 將註釋分行。

更多標誌位請參考 |fo-table|。


定 義 注 釋

'comments' 選項可以定義註釋的樣式。Vim 可以分辨單行註釋和那些包含開頭，中間，
結尾三部分的註釋。
   很多單行註釋都是以一個特殊的字符開頭。在 C++ 中是 //，在 Makefile 中是 #，
在 Vim 腳本中是 "。比如，要使 Vim 理解 C++ 註釋：
>
	:set comments=://
<
冒號將條目的標誌位和用來識別註釋的字符分開。'comments' 的一般格式是：

	{flags}:{text}

{flags} 部分可以為空 (就像本例)。
   不同的條目可以連接在一起，用逗號隔開。這樣可以在同時識別多種不同的註釋。比
如，讓我們編輯一個 email 信息。當回復時，別人寫的內容會以 ">" 和 "!" 字符開
頭：
>
	:set comments=n:>,n:!

這裡有兩個條目。一個識別以 ">" 開頭的註釋，一個識別以 "!" 開頭的註釋。兩個都設
定了 "n" 標誌位，這意味著註釋可以嵌套。也就是說，一個以 ">" 開始的行可以在 ">"
之後包括其它的註釋符號。這樣就可以用來排版下面的文本了：

        > ! Did you see that site? ~
	> ! It looks really great. ~
	> I don't like it.  The ~
	> colors are terrible. ~
	What is the URL of that ~
	site? ~

試著將 'textwidth' 設定為其它的值，例如 80。在可視模式下選中註釋，然後輸入
"gq"。結果為：

	> ! Did you see that site? It looks really great. ~
	> I don't like it.  The colors are terrible. ~
	What is the URL of that site? ~

你會注意到 Vim 並沒有將文本從一種註釋移動到另一種註釋。因為第一行以 ">!" 開
頭，而第二行以 ">" 開頭，Vim 知道它們是不同的註釋，所以第二行的 "I" 並沒有移到
上一行。


包 括 三 部 分 的 注 釋

C 語言註釋的樣式是：以 "/*" 開頭，中間含有 "*"，以 "*/" 結尾。我們可以通過
'comments' 選項來這樣進行設定：
>
	:set comments=s1:/*,mb:*,ex:*/

開始部分用 "s1:/*" 定義。"s" 表示三部分註釋的開始。冒號將標誌位與代表註釋的特
殊字符 "/*" 分開。這裡有一個標誌位 "1"。它指明註釋的中間部分有一個空格位置的偏
移。
   "mb:*" 的 "m" 表示這是註釋的中間部分。"b" 標誌位表示星號後要有空格。否則
Vim 會將形如 "*pointer" 的語句視為某個註釋的中間部分。
   "ex:*/" 中的 "e" 表示註釋的結尾。"x" 標誌位表示在 Vim 自動插入星號後，輸入
"/" 會刪除多餘的空格。

要瞭解更多細節，請參考 |format-comments|。

==============================================================================

下一章： |usr_31.txt|  使用 GUI

版權： 參見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
