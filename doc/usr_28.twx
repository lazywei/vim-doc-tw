*usr_28.txt*	For Vim version 7.3.	最近更新：2008年6月

		     VIM 用戶手冊 - Bram Moolenaar 著
		  譯者： Chimin Yen http://vimcdoc.sf.net

				   折疊


結構化的文本可以分為許多節。而一節之內可以再分小節。折疊允許你將一節顯示為一
行，並提供文本的概覽。本章將解釋各種實現折疊的方法。

|28.1|	什麼是折疊？
|28.2|	手動折疊
|28.3|	對折疊的操作
|28.4|	存儲和恢復折疊
|28.5|	依縮進折疊
|28.6|	依標誌折疊
|28.7|	依語法折疊
|28.8|	依表達式折疊
|28.9|	折疊未被改動的行
|28.10| 使用哪種折疊辦法呢？

       下一章: |usr_29.txt|  在代碼間移動
       前一章: |usr_27.txt|  查找命令及模式
         目錄: |usr_toc.txt|

==============================================================================
*28.1*	什麼是折疊？

折疊用於把緩衝區內某一範圍內的文本行顯示為屏幕上的一行。就像一張紙，要它縮短
些，可以把它折疊起來:

	+------------------------+
	| 行 1		 |
	| 行 2		 |
	| 行 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / 被折疊的行		  /
	/________________________/
	| 行 12		 |
	| 行 13		 |
	| 行 14		 |
	+------------------------+

那些文本仍然在緩衝區內而沒有改變。受到折疊影響的只是文本行顯示的方式。

折疊的好處是，通過把多行的一節折疊成帶有折疊提示的一行，會使你更好地瞭解對文本
的宏觀結構。

==============================================================================
*28.2*	手動折疊

試一試: 把光標置於某一段落內，並鍵入: >

	zfap

你將會看到該段落被一行高亮的文本所代替。你已經創建了一個折疊了。|zf| 是個操作
符，而 |ap| 是一個文本對象。你可以將 |zf| 操作符跟任何一個移動命令聯用，為所經
之處的文本創建一個折疊。 |zf| 也能在可視模式下使用。

若要再閱讀那些文本，可以鍵入以下命令以打開該折疊: >

	zo

你還可以用以下命令再關閉該折疊: >

	zc

所有的折疊命令都以 'z' 開頭。展開你的想像力，這個字母看起來就像一張折疊起來的
紙的側面。而 "z" 後面可用的字母，由於採用了幫助記憶方法選擇，很容易記得住:

	zf	F-old creation (創建折疊)
	zo	O-pen a fold (打開折疊)
	zc	C-lose a fold (關閉折疊)

折疊可以嵌套: 一個含有折疊的文本區可以被再次折疊。例如，你可以折疊本節內每一段
落，然後折疊本章內所有的節。試試看。你將注意到，打開全章的折疊，會將節的折疊還
原得跟以前一樣，有些打開，而有些關閉。

假定你已經創建了若干折疊，而現在需要閱覽全部文本。你可以移到每個折疊處，並鍵入
"zo"。若要做得更快，可以用這個命令: >

	zr

這將減少 (R-educe) 折疊。相反的操作是: >

	zm

這將折疊更多 (M-ore)。你可以重複 "zr" 和 "zm" 來打開和關閉若干層嵌套的折疊。

如果你有一個嵌套了好幾層深的折疊，你可以用這個命令把它們全部打開: >

	zR

這將減少折疊直至一個也不剩。而用下面這個命令你可以關閉所有的折疊: >

	zM

這將增加折疊，直至所有的折疊都關閉了。

你可以用 |zn| 命令快速禁止折疊功能。然後 |zN| 恢復原來的折疊。|zi| 切換於兩者
之間。以下步驟是一種實用的操作方法:
- 創建折疊，以獲取你的文件的概覽
- 移動到你要操作的地方
- 執行 |zi| 以便一邊看著文本，一邊編輯
- 再執行 |zi|  以便移動到另一處

在參考手冊中有更多關於手動折疊的內容: |fold-manual|

==============================================================================
*28.3*	對折疊的操作

當一些折疊關閉時，移動命令，如 "j" 和 "k" 會輕鬆的移過折疊，就像它是單個空行一
樣。這允許你快速移過折疊了的文本。

你可以向對待單行一樣複製，刪除和粘貼折疊。當你要改動某個程序裡的函數的先後次序
時，這是很實用的。首先，為 'foldmethod' 選擇一個正確的折疊方法，以保證每個折疊
包含了整個函數 (或稍缺一點兒)。然後，用 "dd" 命令刪除該函數，移動光標，並用
"p" 命令粘貼。如果函數中某些行在折疊之上，或之下，你可以利用可視模式下的選擇方
法:
- 把光標置於被移文本的首行
- 擊 "V" 鍵開始可視模式
- 把光標置於被移文本的末行
- 擊 "d" 鍵刪除被選中的行。
- 把光標移到新位置，並擊 "p" 鍵把文本粘貼在那兒。

有時候，查看或記住一個折疊在哪兒，挺不容易的。更別說用 |zo| 命令來打開了。要查
看那些已定義的折疊: >

	:set foldcolumn=4

這個命令將在窗口左邊顯示一小欄來標識各個折疊。一個 "+" 表示某個關閉的折疊。一
個 "-" 表示每個打開的折疊的開頭，而 "|" 則表示該折疊內其餘的行。

你可以在折疊欄內用鼠標點擊 "+"，以打開一個折疊。點擊 "-" ，或在它之下的某個
"|" ，將關閉一個打開的折疊。

打開所有光標行上的折疊用 |zO|。
關閉所有光標行上的折疊用 |zC|。
刪除一個光標行上的折疊用 |zd|。
刪除所有光標行上的折疊用 |zD|。

當你進入插入模式後，光標行上的折疊永遠不會關閉。那是要讓你看見你打的什麼字！

當光標前後跳轉至折疊，或在折疊上左右移動時，折疊就會自動打開。例如，零命令 "0"
打開光標下的折疊 (假設 'foldopen' 包含 "hor"，即默認設置)。'foldopen' 選項可以
修改，為指定的某一類命令打開折疊。如果你要光標遇到折疊，折疊就打開，那麼可以這
麼做: >

	:set foldopen=all

警告: 你將因此無法移到一個關閉的折疊上。你也許只想臨時用一用這個命令，然後把它
設回默認值: >

	:set foldopen&

你可以在移開折疊時自動關閉折疊: >

	:set foldclose=all

這個命令將重新把折疊級別 'foldlevel' 作用到所有的不含光標的折疊。你必須自己試
試看你會不會喜歡這個設置。用 |zm| 增加折疊級別，並用 |zr| 減少折疊級別 (減少折
疊的層次)。

折疊是限於本地窗口的。這允許你為同一緩衝區打開兩個窗口，一個帶折疊，而另一個不
帶折疊。或者，一個讓所有的折疊關閉，而另一個則讓所有的折疊打開。

==============================================================================
*28.4*	存儲和恢復折疊

當你放棄一個文件時 (開始編輯另一個)，其折疊狀態就丟失了。如果你稍後再回來編輯
同一文件，那麼，所有手動打開和關閉的折疊，全都恢復到它們的默認狀態了。如果折疊
是用手動方式創建的，則所有的折疊都消失了！為了保存折疊，可以用 |:mkview| 命
令: >

	:mkview

這將儲存那些影響文件視圖的設定及其它內容。你可以利用 'viewoptions' 選項修改儲
存的範圍。當你稍後回到同一文件時，你可以重新載入這個視圖: >

	:loadview

你可以為一個文件儲存多至十個視圖。例如，把當前設置儲存為第三個視圖，並載入第
二個視圖: >

	:mkview 3
	:loadview 2
<
注意 當你插入或刪除一些文本行時，視圖可能變得無效。還得檢查 'viewdir' 選項，它
指定視圖文件儲存在哪兒。你可能時不時需要刪除舊的視圖文件。

==============================================================================
*28.5*	依縮進折疊

使用 |zf| 來定義一個折疊很費事。如果你的文本依循一種結構，以較多的縮進表示較低
的層次，那麼，你可以採用縮進折疊的方法。這將為每一系列有相同縮進的行創建一個折
疊。縮進較多的行將成為嵌套的折疊。縮進折疊適用於許多編程語言。

我們來試試這個方法。先設定 'foldmethod' 選項: >

	:set foldmethod=indent

然後你可以用 |zm| 和 |zr| 命令增加和減少折疊。在下面這個例文上很容易看明白:

本行沒有縮進
	本行被縮進一次
		本行被縮進兩次
		本行被縮進兩次
	本行被縮進一次
本行沒有縮進
	本行被縮進一次
	本行被縮進一次

注意 縮進多少和折疊深度之間的關係倚賴於 'shiftwidth' 選項。每個 'shiftwidth'
選項規定的縮進寬度，在折疊深度上加一。這被稱為一個折疊級別。

當你使用 |zr| 和 |zm| 命令時，你實際上是在增加或減少 'foldlevel' 選項。你也可
以直接設置它: >

	:set foldlevel=3

這意味著，所有縮進等於或大於 'shiftwidth' 三倍的折疊將被關閉。折疊級別設定得越
低，越多的折疊將被關閉。當 'foldlevel' 為零時，所有的折疊都將被關閉。|zM| 把
'foldlevel' 設為零。相反的命令 |zR| 把 'foldlevel' 設為文件中最深的折疊級別。

因此，有兩種方法開啟和關閉折疊:
(A) 設定折疊級別。
    這提供了一種極快的 "縮小" 方法來查看文本結構，移動光標，以及重新 "放大" 到
    具體的文本。

(B) 利用 |zo| 和 |zc| 命令打開和關閉指定的折疊。
    這個方法允許你僅僅打開那些你要打開的折疊，而不影響其它的折疊。

這兩種方法可以結合起來用: 你可以先用幾次 |zm| 以關閉大多數折疊，然後用 |zo| 
打開一個指定的折疊。或者，用 |zR| 打開所有的折疊，然後用 |zc| 關閉指定的折疊。

但是，當折疊方法 'foldmethod' 的值為 "indent" 時，你不能手動定義折疊。因為那樣
會引起縮進寬度和折疊級別之間的衝突。

在參考手冊中有更多關於縮進折疊的內容: |fold-indent|

==============================================================================
*28.6*	依標誌折疊

文本中的標誌用於指定一個折疊區的起點和終點。標誌折疊可以精確地控制一個折疊究竟
包含哪些行文本。缺點是文本需要改動。

試試這個: >

	:set foldmethod=marker

以下列 C 程序片段為例:

	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */

請注意，折疊行將顯示位於標誌之前的文字。這正好用來說明該折疊包含了什麼。

令人十分困擾的是，當某些文本行移動後，標誌不再正確地配對。這種局面可以利用編號
標誌來避免。例如:

	/* global variables {{{1 */
	int varA，varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */

每一個編號標誌表示一個編號指定級別的折疊的開始。這將使任何較高層次的折疊在此結
束。你可以只用編號標誌的開始符定義所有的折疊。只有當你要明確地在另一個開始前結
束一個折疊時，你才需要加一個標誌停止符。

在參考手冊中有更多關於標誌折疊的內容: |fold-marker|

==============================================================================
*28.7*	依語法折疊

Vim 為每一種不同的語言使用一個不同的語法文件。語法文件為文件中各種不同語法項定
義顏色。如果你正用 Vim 在一個支持色彩的終端上閱讀本文，你所看見的色彩就是由語
法文件 "help" 定制的。
   在語法文件中，你可以加入一些帶有 "fold" 參數的語法項。這些語法項將定義折疊
區。這要求寫一個語法文件，把這些項目加入其中。編寫這樣一個文件是不容易的。但是
一旦寫成，所有折疊的創建就變成自動的了。
   在此，我們將假定你正使用一個已經寫好的語法文件。這樣的話，就沒更多解釋的必
要了。你可以像以上解釋過的那樣打開和關閉折疊。編輯文件時折疊會自動創建和刪除。

在參考手冊中有更多關於語法折疊的內容: |fold-syntax|

==============================================================================
*28.8*	依表達式折疊

表達式折疊類似於縮進折疊，但並非利用文本行的縮進，而是調用一個函數來計算一行的
折疊級別。當文本的一部分表明那些行屬於同一組時，你可以使用這個方法。一個例子是
電子郵件，其中引述的文本由行首的 ">" 來表示。要折疊這些引文，可以用以下命令: >

	:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))

你可以在這段文本上試式看:

> quoted text he wrote
> quoted text he wrote
> > double quoted text I wrote
> > double quoted text I wrote

以下是上例中 'foldexpr' 的解釋 (自裡至外):
   getline(v:lnum)			讀取當前行
   substitute(...,'\\s','','g')		從當前行刪除所有空白字符
   substitute(...,'[^>].*','','')	刪除行首那些 '>' 之後的任何字符
   strlen(...)				計算字符串的長度，即 '>' 的個數

注意 在 ":set" 命令中，每一個空格，雙引號和反斜線符之前，必須插入一個反斜槓。
如果這會把你搞糊塗，那麼就執行  >

	:set foldexpr

來檢查所產生的實際值。為了修正一個複雜的表達式，請使用命令行補全: >

	:set foldexpr=<Tab>

其中 <Tab> 是一個真實的 Tab 鍵。Vim 將填入以前的值，然後你可以編輯它。

當該表達式變得相對複雜時，你應當將其放入一個函數。然後設定 'foldexpr' 來調用該
函數。

在參考手冊中有更多關於表達式折疊的內容: |fold-expr|

==============================================================================
*28.9*	折疊未被改動的行

當你在同一窗口也設定 'diff' 選項時，這種折疊方法就很有用。|vimdiff| 命令為你設
定好了使用未改行折疊。例如: >

	:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1

在顯示同一文件的不同版本的每個窗口內執行這個命令。你將清楚地看到不同文件間的區
別，因為那些沒改動的文本都被折疊起來了。

更多細節參見 |fold-diff|。

==============================================================================
*28.10* 使用哪種折疊辦法呢？

所有這些可能性讓你感到納悶，你究竟應該選擇哪種方法。不幸的是，沒有放之四海皆准
的法則。這裡只給出一些提示。

如果存在一個語法文件，其中定義的折疊符合你正在使用的程序語言，那麼，語法折疊應
該是最好的選擇。否則，你也許得試著寫一個。這要求你相當的瞭解關於查找模式知識。
這並非易事。但一旦寫成，你將不必以手動的方式定義折疊了。

鍵入命令，手動折疊一個個文本區的方法可用於無結構特點的文本。然後用 |:mkview|
命令來儲存和還原折疊狀態。

標誌折疊法要求你修改文件。如果你與它人共享這個文件，或不得不遵守公司規定的標
准，那麼你也許得不到許可給文件加標誌。
   標誌折疊的主要優點是，你可以精確的把標誌放在你要的位置。那樣就避免了那種在
你剪切和粘貼折疊時漏了幾行文本的情況。並且，你還可以加個註釋，說明該折疊包含些
什麼。

縮進折疊法是那種在許多文件裡都用的著。但並不是每次都能成功的方法。當你無法採用
其它方法時，就用這種。然而，縮進折疊在做提綱時特別有用。你必須為每一層嵌套折疊
特意的使用同一縮進寬度 'shiftwidth'。

表達式折疊法能夠在幾乎任何有結構特定的文本中創建折疊。這種方法相當簡單，尤其當
折疊的開始和結束處能容易地被識別的時候。
   如果你用 "expr" 方法來定義折疊而無法得到完全滿意的結果。那麼你可以切換到手
動方法 "manual"。這麼做不會刪除那些已經定義好了的折疊。之後你便可以手動刪除或
增加折疊了。

==============================================================================

下一章: |usr_29.txt|  在代碼間移動

版權: 參見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
