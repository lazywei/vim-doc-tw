*develop.txt*	 For Vim version 7.3.   最後更新：2006年12月


		    Vim 參考手冊    作者：Bram Moolenaar
		  譯者：jwdu，iCrazy，tocer (http://vimcdoc.sf.net)


Vim 的開發						*development*

這一節的內容對那些想進一步開發 Vim 的人來說是很重要的。

1. 設計目標		|design-goals|
2. 編程風格		|coding-style|
3. 設計決定		|design-decisions|
4. 假定			|design-assumptions|

請先看一下 "src" 目錄下的 README.txt 以便對源代碼有一個總體的瞭解。

Vim 是開源軟件，鼓勵所有人參與並改進 Vim。如果你想遞交 patch，請使用 "diff -c"
來產生上下文 (context) 格式的 diff 文件。可以參考一下
http://www.vim.org/tips/tip.php?tip_id=618。

==============================================================================
1. 設計目標						*design-goals*

首先說最重要的內容 (概略的說一下)。

注意 許多項目是互相衝突的，但這是故意的。對於它們，你必須自己平衡一下。

VIM 是 ... 和 VI 兼 容 的				*design-compatible*

首先，必須使 Vim 能夠代替 Vi。如果用戶願意，他可以在兼容模式下使用 Vim 而且很
難發現它和原先的 Vi 有什麼不同。

例外：
- 在 Vim 中不再有明顯的 Vi 錯誤。
- 有很多不同的 Vi 版本。我用 3.7 (6/7/85) 版作為參考。但是如果可能，也會支持其
  它的版本。POSIX 中的 Vi 部分不是最主要的來源。
- Vim 中有一些新的指令，你不要因為某個命令在 Vi 中不存在，就指望它會失敗。
- Vim 有許多特性是 Vi 所沒有的。從 Vim 回到 Vi ，將會出現一些不可避免的問題。
- 有一些指令可能是很少用到 (open 模式、在崩潰時發送一封郵件等等)。只有你能說明
  為什麼應當加入這些功能，並且不會增加多少代碼量時，它們才會被加入。
- 對一些命令是否仍需兼容 Vi 是一個有爭議的問題。對這些，會使用一個選項標誌位。


VIM 是 ... 改 進 過 的					*design-improved*

Vim 的改良使它成為一個更好的 Vi，而沒有變成一個完全不同的編譯器。對它的擴展是
本著 "Vi 精神" 完成的。
- 盡可能多的使用鍵盤，鼠標需要第三隻手來操作，而我們沒有第三隻手。而且，許多終
  端沒有鼠標。
- 當使用鼠標操作時，盡量少回到鍵盤操作，避免鼠標和鍵盤的混合操作。
- 用一致的方式增加命令和選項。否則，人們將會很難發現並記住它們。請記住：以後會
  加入更多的命令和選項。
- 一個人們不知道的特性是一個無用的特性。不要添加不明顯的特性，或者至少在文檔中
  說明它們的存在。
- 盡量少用 CTRL 和其它修飾符，因為它們很難輸入。
- 因為對許多人來說，Vim 是他們剛接觸或不熟悉的，所以請盡量使 Vim 容易上手。
- 特性是可以無限增加的，對它們的選擇基於以下方面：(1) 使用者需要什麼 (2) 實現
  它需要多少工作量 (3) 的確有人會去實現它。


VIM 是 ... 多 平 台 的					*design-multi-platform*

Vim 設法支持盡可能多的平台，從而讓盡可能多的人能夠使用它。
- 支持多種終端。最小的需求是定位鼠標和清屏。指令最好用多數鍵盤都具有的那些鍵來
  執行。在映射鍵盤時，支持鍵盤上所有的鍵。
- 支持多種平台。必要條件是有人想在此平台上開發 Vim，而且不要把代碼搞亂。
- 支持多種編譯器和庫。並不是每個人都能夠安裝另一個編譯器或圖形庫。
- 人們經常從一個平台轉移到另一個平台，從圖形界面轉移到終端模式。特性應在每個版
  本中都加入，至少應該在盡可能多的版本中出現。盡量避免使用者為了有效的完成他們
  的工作而需要在不同平台間轉移。
- 也許有些特性在某些平台上沒有，或者只在某個平台上有，但這不意味著它不應當被實
  現。[這個和上一個原則明顯的衝突了，但我們必須在它們之間做個平衡。]


VIM 是 ... 具 有 詳 盡 文 檔 的				*design-documented*

- 一個沒有文檔的特性是一個無用的特性。針對新特性的補丁必須包含它的文檔。
- 文檔必須全面且容易理解。最好舉例說明問題。
- 請使文件盡可能的短，短文檔能使得找到它容易一些。

VIM 是 ... 速 度 快 、 體 積 小 的			*design-speed-size*

Vim 不能大量消耗系統資源，必須使它體積小且速度快。
- 計算機每年都在變得更快、更大。Vim 也可以同樣的變化，但是速度不能超過計算機的
  變化速度。要使 Vim 在老的計算機上也可以使用。
- 許多使用者經常從 shell 啟動 Vim。啟用時間必須盡量短。
- 指令必須有效的工作，它們消耗的時間要盡可能的短。有用的指令可以多消耗一點時
  間。
- 注意到許多人在慢速線路上使用 Vim，因此，要使通信的開銷盡可能的少。
- 如果一個顯著增加 Vim 體積的功能不被大多數人使用，應該可以關閉該功能。
- Vim 只是其它許多組件中的一個，不要把它弄成一個笨重的應用程序，倒要使它能夠和
  其它程序一起很好的工作。


VIM 是 ... 可 維 護 的					*design-maintain*

- 源代碼不應該變成一團糟。它應該是可靠的代碼。
- 所有的文件應使用相同的風格，使得它們易讀性強 |coding-style|。
- 根據需要有效的使用註釋！_不要_引用函數和參數名。要解釋它們的意義。
- 移植到另一個平台應該很容易，而不必改變太多獨立於平台的代碼。
- 使用面向對象的思想：把數據和代碼放在一起，波及到代碼其它部分的知識要盡可能
  的少。


VIM 是 ... 靈 活 的					*design-flexible*

Vim 應該讓使用它的人很容易在他們喜歡的風格下工作，而不強迫他們使用一個特定的方
式工作。這個對於那些有巨大影響的選項 (如 'compatible' 選項) 和其他細節都是一
樣。缺省值是經過認真挑選的，以便大多數使用者都樂意在默認設置下使用 Vim。用戶可
以用命令和選項來調整 Vim 來滿足他們和環境的需要。


VIM 不 是 ... 						*design-not*

- Vim 不是一個 shell 或操作系統。你不能在 Vim 內運行一個 shell 或使用它控制一
  個調試器。應該使用相反的方式工作：把 Vim 當作來自 shell 或 IDE 中的一個部分
  來使用。這裡有一個諷刺的說法："Vim 不像 Emacs 那樣會包含除廚房中的水槽以外的
  每件事物，但有人說如果你需要的話，卻可以用它來洗盤子。;-)"
  要在 Vim 中使用 gdb，參見：http://www.agide.org 和 http://clewn.sf.net。
- Vim 不是一個為了看起來漂亮而犧牲多平台一致性的華而不實的 GUI 編輯器。但我們
  依然歡迎有效的 GUI 特性。

==============================================================================
2. 編程風格						*coding-style*

這些是改變 Vim 源代碼的時候必須遵循的準則。為了保持源代碼的可讀性和可維護性，
請堅持使用這些原則。

這個列表是不完全的，請查看源代碼以獲得更多的例子。


修 改 代 碼						*style-changes*

修改代碼的基本步驟：
1. 首先調整文檔，這樣做將使你對你的更改如何影響使用者有一個印象。
2. 改變源代碼。
3. 檢查 ../doc/todo.txt，看看所作的修改是否影響其中的項目。
4. 用 "diff -c" 針對沒有改變的代碼和文檔，做一個補丁。
5. 寫一個修改了哪些地方的記錄，並把它加到補丁中。


普 通 函 數 的 使 用					*style-functions*

一些普遍使用的函數都有一個特殊的 Vim 版本。它們的引入是有原因的，因此，一般應
考慮使用這些 Vim 版本。

通用名		VIM 函數名	VIM 版本的不同
free()		vim_free()	檢查釋放 NULL 的情況
malloc()	alloc()		檢查內存不足的情況
malloc()	lalloc()	類似於 alloc()，但是支持長參數
strcpy()	STRCPY()	對於 char_u* 類型的參數，會自動將其轉換為
				(char*) 類型
strchr()	vim_strchr()	接受特殊字符
strrchr()	vim_strrchr()	接受特殊字符
isspace()	vim_isspace()	可以處理 ASCII 碼 > 128 的字符
iswhite()	vim_iswhite()	僅對 Tab 和空格返回真值
memcpy()	mch_memmove()	能處理範圍重疊的複製
bcopy()		mch_memmove()	處理重疊的複製
memset()	vim_memset()	對所有系統通用


名 稱							*style-names*

函數名不能超過 31 個字符的長度 (因為 VMS 的緣故)。

不要使用 "delete" 作為變量名稱，C++ 不喜歡這樣。

因為 Vim 需要在盡可能多的平台上運行，所以我們需要避免那些已經被系統定義過的名
稱。這裡是一個已知會造成麻煩的名稱列表 (使用正規表達式模式給出)。

is.*()		POSIX，ctype.h
to.*()		POSIX，ctype.h

d_.*		POSIX，dirent.h
l_.*		POSIX，fcntl.h
gr_.*		POSIX，grp.h
pw_.*		POSIX，pwd.h
sa_.*		POSIX，signal.h
mem.*		POSIX，string.h
str.*		POSIX，string.h
wcs.*		POSIX，string.h
st_.*		POSIX，stat.h
tms_.*		POSIX，times.h
tm_.*		POSIX，time.h
c_.*		POSIX，termios.h
MAX.*		POSIX，limits.h
__.*		POSIX，system
_[A-Z].*	POSIX，system
E[A-Z0-9]*	POSIX，errno.h

.*_t		POSIX，用於 typedefs。請用 .*_T 代替。

wait		不要使用它作為函數的參數，和 types.h 衝突
index		屏蔽全局聲明
time		屏蔽全局聲明
new		C++ 保留關鍵字
try		Borland C++ 不希望它作為變量名被使用。

basename()	GNU 串函數
dirname()	GNU 串函數
get_env_value()	Linux 系統函數


雜 項							*style-various*

類型定義 (typedef) 的名稱應該以 "_T" 結尾： >
    typedef int some_T;
宏 (define) 的名稱應該全部是大寫： >
    #define SOME_THING
特性 (feature) 應該總是以 "FEAT_" 開頭： >
    #define FEAT_FOO

不要使用 '\"'，一些編譯器不能處理它。用 '"' 比較合適。

不要使用：
    #if HAVE_SOME
一些編譯器不能處理它並報告說 "HAVE_SOME" 沒有被定義。
請使用
    #ifdef HAVE_SOME
或
    #if defined(HAVE_SOME)


風 格							*style-examples*

一般原則：每行一條語句。

錯誤：	    if (cond) a = 1;

正確：	    if (cond)
		a = 1;

錯誤：	    while (cond);

正確：	    while (cond)
		;

錯誤：	    do a = 1; while (cond);

正確：	    do
		a = 1;
	    while (cond);


函 數 的 開 始 ：

錯誤：	int function_name(int arg1, int arg2)

正確：	/*
	 * 解釋函數的功能。
	 *
	 * 解釋返回值。
	 */
	    int
	function_name(arg1, arg2)
	    int		arg1;		/* arg1 的簡短註釋 */
	    int		arg2;		/* arg2 的簡短註釋 */
	{
	    int		local;		/* local 的註釋 */

	    local = arg1 * arg2;

備註：不要使用 ANSI 風格的函數聲明。一些人仍然在使用不支持它的編譯器。


空 格 和 標 點						*style-spaces*

不要在函數名和括號間留空格：

錯誤：  func (arg);
正確：	func(arg);

但請在 if，while，switch 等之後留一個空格：

錯誤：	if(arg)		for(;;)
正確：	if (arg)	for (;;)

在逗號和分號後留一個空格：

錯誤：  func(arg1,arg2);	for (i = 0;i < 2;++i)
正確：	func(arg1, arg2);	for (i = 0; i < 2; ++i)

在 '='，'+'，'/' 等的前後各留一個空格：

錯誤：	var=a*5;
正確：	var = a * 5;

一般地：使用空行來把代碼分組。在每組代碼的上面寫上註釋，這樣就可以快速的知道這
些代碼是用來幹什麼的。

正確：	/* Prepare for building the table. */
	get_first_item();
	table_idx = 0;

	/* Build the table */
	while (has_item())
	    table[table_idx++] = next_item();

	/* Finish up. */
	cleanup_items();
	generate_hash(table);

==============================================================================
3. 設計決定						*design-decisions*

折疊

對同一個緩衝區可以有多種折疊形式。例如，一個窗口顯示函數體折疊後的文本，另一個
窗口顯示函數體。

折疊是一種顯示文本的方式。它不應該改變文本自身。所以折疊是被當作緩衝區文本 (緩
沖區行) 和窗口內顯示的文本 (邏輯行) 之間的過濾器來實現的。


為窗口命名

我們一般用單詞 "窗口" 來稱呼很多東西：屏幕上的一個窗口、xterm 窗口、Vim 中一個
用來查看緩衝區內容的窗口。
為避免混淆，我們給其他有時被稱作窗口的項目起了其他的名稱。這些是相關項目的概
述：

screen		整個屏幕。對於 GUI 來說，就是類似於 1024x768 像素之類的東西。
		Vim shell 可以使用整個屏幕 (例如，在控制台上運行時) 或它的一部
		分 (xterm 或 GUI)。
shell		Vim 這個應用程序。它可以覆蓋整個屏幕 (例如，在控制台上運行時) 
		或它的一部分 (xterm 或 GUI)。
window		用來查看緩衝區內容的地方。Vim 中可以包括很多窗口，還有命令行、
		菜單欄、工具欄等。它們被整合到 shell 中。


拼寫檢查						*develop-spell*

當要把拼寫檢查加進 Vim 時，考察了一些可用的拼寫檢查庫和程序。不幸的是，沒有一
個能提供足夠的能力使其能夠作為 Vim 的拼寫檢查引擎，原因很多：

- 缺乏對多字節編碼的支持。至少要支持 UTF-8，以便同一文件能使用多種語言。
  實時轉換未必總是可行的 (這需要 iconv 支持)。
- 對於那些程序和庫：如果不作任何改動，需要和 Vim 分開單獨安裝才能使用。一般來
  說，這不是不可以，但總是個問題。
- 性能：測試表明這些程序和庫可以像語法高亮那樣支持 (重畫時) 實時的拼寫檢查，但
  那些代碼所用的機制太慢了。例如使用哈希表的 Myspell。大部分的拼寫檢查程序使用
  字綴壓縮 (affix compression) 算法也會使其速度減慢不少。
- 使用像 aspell 這樣的外部程序需要設置通信機制。這會使可移植性變得複雜 (只考慮
  Unix 系統相對簡單點，但還遠遠不夠)。而且性能也是個問題 (大量的進程切換)。
- 缺乏對包含非單詞字符的單詞的支持，如 "Etten-Leur" 和 "et al."。需要把詞中每
  個部分都標識為好詞，但這樣就降低了檢測的可靠性。
- 缺乏對區域或方言的支持。例如，接受所有英語單詞並且單獨高亮出非加拿大的單詞是
  很困難的。
- 缺乏對生僻詞的支持。有很多詞拼寫正確但幾乎很少使用，卻有可能是拼寫錯誤的常用
  詞。
- 對於拼寫建議，速度不太重要，要安裝其他的程序或者庫也是可以接受的。但是這些程
  序或庫提供的單詞列表也許與拼寫檢查程序使用的不一致，給出的建議可能是拼寫檢查
  程序檢測出的拼寫錯誤的單詞。


拼寫建議					*develop-spell-suggestions*

對於實現拼寫建議，有兩種基本的方法：
1. 嘗試輕微改變錯誤的單詞，然後檢查能否和正確的單詞匹配。或者瀏覽正確單詞列
   表，輕微改變它們，看能否和錯誤的單詞匹配。這裡所指的改動包括：刪除一個字
   符，插入一個字符，交換兩個字符等。
2. 比較壞詞和好詞列表的發音來尋找匹配。可能也需要象第一種方法那樣對單詞做少許
   改變。

第一種方法的優勢在於查找錄入錯誤。在使用哈希表試驗和參考了其他拼寫檢查程序的方
案後，得出結論：trie (一種樹結構) 是理想方案。既可以減少內存佔用，又可以嘗試合
理的改變。例如，只有在能夠拼成正確單詞的情況下才插入字符。其他方式 (使用哈希
表) 需要在單詞的所有位置嘗試所有可能的字符。而且，哈希表需要單獨標識單詞的邊
界。而 trie 就不需要這樣做。這樣會簡化很多。

當我們知道單詞如何發音卻不知道如何拼寫時，按發音折疊匹配就很有用了。例如，單詞
"dictionary" 可能寫成 "daktonerie"。第一種方法需要嘗試的次數非常多，很難找到正
確的單詞。按發音匹配後，這兩個單詞變成了 "tkxnry" 和 "tktnr"，兩者僅有兩個字符
的差異。

為了通過相似的發音來查找單詞 (尋找按發音折疊等價的單詞)，我們需要所有發音相似
的單詞列表。為此，我們作了一些試驗來尋找最好的方法。可供選擇的方案是：
1. 在尋找拼寫建議時，實時進行發音匹配。這意味著瀏覽 trie 樹以尋找正確單詞，匹
   配每個單詞發音，並檢查它與錯誤單詞的不同。這種方式內存佔用少，但花費時間
   多。在一台比較快的電腦上，對於英文需要幾秒，這對於交互式使用還可以接受。但
   是對於某些語言，則超過 10 秒 (如：德語、加泰羅尼亞語)，這就慢得無法忍受了。
   對於成批處理 (自動更正)，所有的語言處理起來都很慢。
2. 把 trie 用於發音匹配的單詞，這樣查找時就可以和沒有用發音折疊的方法一模一
   樣。但這需要對每個相近的發音記住所有好詞的列表。這種方式搜索匹配很快，但是
   要佔用大量內存，其級別大約在 1M 到 10M 之間。對於某些語言，甚至會大於原單詞
   列表。
3. 類似於第二種方案，但用字綴壓縮 (affix compression) 並且只保存發音相近的單詞
   基本部分 (字根) 來減少內存開銷。aspell 就是這麼做的。缺點是，在按發音進行匹
   配前，需要從錯誤的單詞上分開字綴，這意味著在單詞頭和/或尾出現的錯誤會導致本
   方案失敗。而且當錯誤的單詞和正確的單詞間有很大不同時，本方案會變得很慢。

我們作出的選擇是使用第二種方案，並使用單獨的文件。這樣，有足夠內存的用戶可以得
到很好的拼寫建議，而內存不足或者只想要拼寫檢查而不需要建議的用戶就可以不用那麼
多內存。


單詞頻率

對建議進行排序時，知道單詞常見與否很有幫助。理論上，我們可以在字典中對應單詞保
存一個單詞頻率。但是每個單詞都需要計數。這會使單詞樹的壓縮效率大為降低。而且對
所有的語言都要維護單詞頻率，將是個繁重的任務。另外，最好優先考慮文本裡已經出現
的單詞。這樣在特定文本裡出現的單詞可以被建議列表優先列出。

現已實現的是統計已經顯示的單詞。哈希表用於快速查找單詞的計數。字綴文件的
COMMON 項目中列出的單詞會先有初始計數，這樣，即使新編輯文件時也能馬上用此功
能。

這還不夠理想，因為 Vim 運行的時間越長，單詞計數就會越大。但實際應用中，這仍然
比不使用單詞計數的情形要改進不少。

==============================================================================
4. 假定							*design-assumptions*

變量的大小：
char	    8 位有符號數
char_u	    8 位無符號數
int	    32 或 64 位有符號數 (16 位是可能的，但功能會有限制)
unsigned    32 或 64 位無符號數 (16 位情況同 int)
long	    32 或 64 位有符號數，可具有指針

注意：某些編譯器不能處理過長的源碼行或者字符串。C89 標準規定限制在 509 個字符
以內。

 vim:tw=78:ts=8:ft=help:norl:
